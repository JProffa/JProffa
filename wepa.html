<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN"
        "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">

<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="fi" lang="fi">
        <head>
                <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
          <title>Web-palvelinohjelmointi, syksy 2012</title>
                <link rel="stylesheet" href="stylesheets/common.css" type="text/css" media="screen, print" />
                <script type="text/javascript" src="javascripts/jquery-1.7.1.min.js"></script>
                <script type="text/javascript" src="javascripts/exercises.js"></script>                
                <script type="text/javascript" src="javascripts/common.js"></script>
                
                <script type="text/javascript" src="javascripts/shjs/sh_main.min.js"></script>
                <script type="text/javascript" src="javascripts/shjs/sh_java.min.js"></script>
                <script type="text/javascript" src="javascripts/shjs/sh_xml.min.js"></script>
                <link rel="stylesheet" href="stylesheets/shjs/sh_style.css" type="text/css" media="screen, print" />
                <link rel="stylesheet" href="stylesheets/exercises.css" type="text/css" media="screen, print" />
        </head>

        <body>
                <p><small>Tämä materiaali on lisensoitu Creative Commons BY-NC-SA-lisenssillä, joten voit käyttää ja levittää sitä vapaasti, kunhan alkuperäisten tekijöiden nimiä ei poisteta. Jos teet muutoksia materiaaliin ja haluat levittää muunneltua versiota, se täytyy lisensoida samanlaisella vapaalla lisenssillä. Materiaalien käyttö kaupalliseen tarkoitukseen on ilman erillistä lupaa kielletty.</small></p>

                <h2>Lukijalle</h2>

                <p>Tämä materiaali on tarkoitettu Helsingin yliopiston tietojenkäsittelytieteen laitoksen syksyn 2012 kurssille web-palvelinohjelmointi. Materiaaliin on vaikuttanut vahvasti Helsingin yliopistossa keväällä 2012 järjestetty kurssi web-sovellusohjelmointi, sekä siitä saatu palaute. Materiaalin kirjoittaja on Arto Vihavainen ja sen syntyyn ovat vaikuttaneet useat tahot, joista tärkeimmät ovat Matti Luukkainen ja Mikael Nousiainen. Syksyn kurssimateriaaliin liittyvistä ehdotuksista ja ajatuksista tulee kiittää muun muassa Kasper Hirvikoskea ja Hansi Keijosta. Erityinen kiitos kuuluu myös Martin Pärtelille, joka on mahdollistanut TMC:n käytön kurssilla.</p>

                <h3 id="web_sovelluksista">Web-sovelluksista yleisesti</h3>

                <p>Web-sovellukset koostuvat yleisesti ottaen kahdesta: palvelinpuolesta ja selainpuolesta. Palvelinpuoli hoitaa palvelimella tapahtuvan toiminnan, esimerkiksi tietokannan muokkauksen ja erilaiset laskentaoperaatiot. Selaimessa taas näytetään käyttäjälle data ja lähetetään tietoa palvelimelle, joka taas palauttaa käyttäjälle selaimessa näytettävää tietoa.</p>

                <p>Käytännössä web-sovellukset koostuvat datasta jolle on määritelty ilmaisumuoto. Selainohjelmointiin ja käyttöliittymäsuunniteluun keskityttäessä painotetaan ulkoasun ja sisällön erotusta toisistaan <a href="http://en.wikipedia.org/wiki/CSS" target="_blank">CSS</a>:n avulla, sekä luodaan interaktiivista toiminnallisuutta Javascriptiin ja nykyaikaisiin web-teknologioihin tukeutuen. <a href="http://en.wikipedia.org/wiki/HTML5" target="_blank">HTML5</a> tukee videoiden näyttämistä, musiikin soittamista ja piirtämistä, ja <a href="http://en.wikipedia.org/wiki/WebGL" target="_blank">WebGL</a> taas laajentaa Canvas-toiminnallisuutta tuoden 3D-tuen ja -kiihdytyksen selaimiin.</p>

                <p>Web-sovellukset eivät sisällä sivuja samalla tavalla kuin perinteiset web-sivut sisältävät. Vaikka web-sovelluksessa voi ulkopuolisen silmin olla esimerkiksi 5 sivua, uuden sisällön lisääminen tietokantaan tai vastaavaan tietoa tallentavaan järjestelmään mahdollistaa sivumäärän kasvattamisen ilman muutoksia lähdekoodissa. Käyttäjälle tarjotut hakutoiminnallisuudet mahdollistavat lähes rajattoman määrän sivuja; kukaan ei kirjoittaisi näitä käsin.</p>

                <p>Pieni määrä sivupohjia (ns. templateja) ja palvelinpuolen sovelluslogiikkaa mahdollistaa sivujen luomisen lennosta suoraan web-osoitetta tai lomakkeella lähettyä dataa käyttäen.</p>

                <p>Keskivertokäyttäjälle web-sovellukset näyttävät samalta kuin perinteiset web-sivut. Yksinkertaisen web-sovelluksen lähdekoodia katsottaessa voi olla mahdotonta päätellä ovatko sivut luotu dynaamisesti vai kirjoitettu jotain editoria käyttäen (tai käsin). Web-osoitteesta voi yrittää päätellä jotain (.html, ...), mutta oikeasti web-osoitteiden päätteet ovat vain osa osoitetta: .html -päätteisellä sivulla voi hyvin olla web-sovellus taustalla. Web-sovellus näyttää usein sovellukselta vain niille jotka muokkaavat sovellukseen liittyvää dataa. Sekä sovelluksen käyttö että datan muokkaus tapahtuu yleensä HTML-käyttöliittymää käyttäen. Web-sovellusta voi hallita myös työpöytäsovelluksella, joka muokkaa web-sovelluksen käyttämää dataa.</p>

                <p>Javascript (käytännössä AJAX, <em>Asynchronous JavaScript and XML</em>) mahdollistaa sivujen sisällön uudelleen lataamisen ja päivittämisen ilman että käyttäjän tarvitsee tehdä erillisiä pyyntöjä tai kirjoittaa uutta osoitetta selaimen osoitepalkkiin.  AJAX mahdollistaa muutosten tekemisen taustalla -- ilman että käyttäjän tarvitsee siirtyä sivulta toiselle -- joka pienentää web-sovellusten ja työpöytäsovellusten välistä eroa.</p>

                <p>Työpöytäsovellukset tarjoavat enemmän interaktiivisuutta ja nopeutta web-sovelluksiin verraten. Web-sovellukset mahdollistavat saumattomat ohjelmistojen päivitykset, todellisen tiedot ja dokumenttien jakamisen ja kevyet käyttöliittymät.</p>

                <p>Elämme jatkuvaa muutosta. Muutoksesta riippumatta web-sovellukset ovat järjestelmiä, jotka sisältävät dataa. Dataa voi käsitellä web-sivujen kautta ja muita rajapintoja käyttäen. Google tarjoaa Google Documents -palvelua ilmaiseksi kaikkien käyttöön, mahdollistaen käyttäjälle pääsyn dokumentteihin mistä tahansa. Microsoft tarjoaa kaikille ilmaista sähköpostipalvelua, verkko on täynnä ilmaisia webissä toimivia pelejä...</p>

                <p>Tälläkin hetkellä ohjelmistoyhtiöt ympäri maailmaa kehittävät uusia innovaatioita, jotka tulevat tulevaisuudessa syrjäyttämään perinteiset työpöytäsovellukset.</p>


                <h3 id="web_sovellusten_kehittäminen">Web-sovellusten kehittäminen</h3>

                <p>Sovellusten arkkitehtuurista perinteisesti puhuttaessa puhutaan talojen tai rakennusten rakentamisesta. Taloa suunnitellessa arkkitehdillä on selkeä tehtävä ja tavoitteet: kerää vaatimukset, tutki vaihtoehtoja ja luo pohjapiirrustus. Pohjapiirrustusta seuraten erillinen joukko työntekijöitä -- rakennusmiehet -- rakentaa konkreettisen rakennuksen.</p>

                <p>Ohjelmistoja suunniteltaessa arkkitehti osallistuu sekä ohjelmiston suunnitteluun että kehitykseen, eli konkreettiseen rakentamiseen.  Suunnittelussa hän aloittaa perustarpeista ja muutamasta huoneesta, jonka jälkeen jo muutama ihminen alkaa käyttämään rakennusta. Kun alkuperäinen suunnitelma on lähes valmis, rakennukseen muuttaa lisää ihmisiä. Nämä tarvitsevat lisää rakennukselta: uusia huoneita, pesulan, diskon ja luonnollisesti oleskelutilan, jossa on tilaa biljardipöydälle. Arkkitehti soveltaa alkuperäistä suunnitelmaansa mukauttamaan uudet ihmiset ja kehitystyö jatkuu.</p>

                <p>Toimintoja kehitettäessä alkuperäiset asukkaat eivät muuta pois, vaan valittavat jatkuvasta rakennusmelusta. Yhä enemmän ihmisiä muuttaa rakennukseen ja rakennukselta vaaditaan taas lisää (mm. cartingrata ja curlinghalli).</p>

                <p>Hyvän arkkitehtuurisuunnittelun perusta on mahdollisuuksien huomiointi. Huomioinnilla ei tarkoiteta sitä, että rakennetaan heti aluksi iso järjestelmä -- käytännössä järjestelmän valmistuessa sille ei olisi käyttäjiä sillä kaikki olisivat siirtyneet toiseen aiemmin tarpeellisia ominaisuuksia tarjonneeseen järjestelmään. Jos alkuperäinen suunnitelma tekee järjestelmän laajentamisesta vaikeaa, käyttäjät saattavat vaihtaa palvelua hitauden takia.</p>

                <p>Ohjelmistokehityksessä saadaan käytännössä hyvin harvoin ensimmäisellä yrityksellä rakennettua toimiva ja tyydyttävä ratkaisu. Jokaista ohjelmistoa joudutaan laajentamaan, rajaamaan ja refaktoroimaan. Asiakkaalla tai asiakkailla on käytännössä aina uusia toivomuksia ohjelmiston elinkaaren varrella.</p>

                <p>Arkkitehtuurin tulee mahdollistaa sopivan kokoisesta palasta aloittaminen sekä rakennettavan sovelluksen laajentaminen, myös toisten kehittäjien toimesta, mahdollisimman kevyesti. Hyvin harvat ohjelmistot ovat vain yhden ihmisen käsialaa, avoimeen lähdekoodiin ja online-versionhallintatyökaluihin (esim github) perustuvat projektit saavat ihmiset eri puolilta maailmaa tekemään työtä yhteisen mielenkiinnon parissa. Ryhmätyössä sovittujen käytänteiden (esim. nimeämiskäytänteet, versionhallinta, testaus, dokumentointi ym.) olemassaolo on oleellista. Kommunikointi niin koodin kautta kuin muita väyliä käyttäen on oleellista -- muuttujanimet <code>a, b, c, foo</code> ja <code>bar</code> aiheuttavat lukijalle lähinnä kylmiä väreitä.</p>

                <p>Web-sovelluskehityksessä nopeasta kehityssyklistä on paljon hyötyä. Työkaluja valittaessa tarkoituksena on välttää nurkkaan ajautumista: työkaluista tulee pystyä myös pääsemään eroon. On paljon hyödyllisempää miettiä asiaa päivä ja käyttää muutama päivä prototyypin tekemiseen, koska prototyyppiä voidaan parantaa kuukausia, kuin miettiä kuukausi ja sitouttaa itsensä kuukauden aikana luotuun suunnitelmaan. Mitä nopeammin toiminnallisuutta on olemassa, sitä nopeammin siitä saa palautetta.  Mitä vähemmän käytämme aikaa yksittäisen toiminnallisuuden toteuttamiseen -- <a href="http://en.wikipedia.org/wiki/KISS_principle" target="_blank">KISS</a> -- sitä helpommin siitä voi tarpeen vaatiessa hankkiutua eroon.</p>


                <h2 id="tyokalut">Kurssilla käytettävät työvälineet</h2>

                <p>Työkalut ovat oleellinen osa ohjelmistoryhmän yhteisten pelisääntöjä. Tällä kurssilla käytämme ohjelmointiympäristönä NetBeansia, ja ohjelmistoprojektien hallintaan Maven-projektinhallintatyökalua. Nykyaikaisestakin ohjelmistokehityksestä osa tapahtuu terminaalissa eli komentotulkissa, joten käytämme myös sitä kurssin aikana.</p>
                
                <p>Oletamme että käytössäsi on Google Chrome tai vastaavat web-sovelluskehittäjän apuvälineet sisältävä www-selain.</p>

<!--
* maven, no web
//-->
                <h3 id="ohjelmistoprojektin_hallinta">Ohjelmistoprojektien hallinta</h3>

                <p>Ohjelmistokehittäjän arjesta huomattava osa menee projekteihin liittyviin tehtäviin kuten ylläpitoon. Jokaisessa ohjelmistoprojektissa on erilaisia lähdekoodiin liittyviä tavoitteita, joita kehittäjien tulee pystyä toteuttamaan. Lähdekoodia tulee pystyä paketoimaan tuotantoon siirettäväksi paketiksi (esim -.jar ja -.war -tiedostot), lähdekoodiin liittyviä testejä tulee pystyä ajamaan erillisellä palvelimella ja lähdekoodista tulee pystyä generoimaan erilaisia raportteja sekä luonnollisesti dokumentaatiota.</p>

                <p>Työkalut kuten <em><a href="http://ant.apache.org/" target="_blank">Apache Ant</a></em> auttavat projektiin liittyvän lähdekoodin hallinnoinnissa ja kääntämisessä. Ant on käytännössä 2000-luvun alun vastine perinteisille Makefile-tiedostoille. Nykyaikaisempi <em><a href="http://maven.apache.org/" target="_blank">Apache Maven</a></em> auttaa käännösprosessin lisäksi projektiin liittyvien kirjastoriippuvuuksien automaattisessa hallinnassa. </p>

                <h3>Maven</h3>

                <p>Apache Maven on projektinhallintatyökalu, jota voi käyttää ohjelmakoodikäännösten automatisoinnin lisäksi lähes koko projektin elinkaaren hallintaan uuden projektin aloittamisesta lähtien. Maven tarjoaa ohjelmiston elinkaaren hallintaan joukon valmiiksi konfiguroituja vaiheita (<em>phase</em>), joita voidaan suorittaa komentoriviltä. Tyypillisiä jo olemassaolevia vaiheita ovat <em>test</em>, joka suorittaa projektiin liittyvät testit, sekä <em>package</em>, joka paketoi lähdekoodin projektityypistä riippuen sopivaan pakettiin. Oikeastaan maven on sovelluskehys plugin-komponenttien suoritukseen, yksinkertaisimmatkin tehtävät on tehty pluginien avulla.</p>

                <p>Jokaisella Maven-projektilla on elinkaari, joka sisältää vaiheet lähtien projektin validoinnista, kääntämisestä ja testaamisesta aina tuotantoon siirtämiseen asti. Tarkempi listaus projektin erilaisista vaiheista löytyy Mavenin <a href="http://maven.apache.org/guides/introduction/introduction-to-the-lifecycle.html#Lifecycle_Reference" target="_blank">dokumentaatiosta</a>. Kukin vaihe koostuu yhdestä tai useammasta projektiin liittyvästä tavoitteesta (<em>goal</em>), jotka suoritetaan vaiheen sisällä. Vaiheet riippuvat myös edellisistä vaiheista, esimerkiksi vaihetta <em>test</em> suoritettaessa Maven suorittaa ensin projektin validoinnin ja kääntämisen.</p>

                <p>Mavenin pluginarkkitehtuuri mahdollistaa hyvin monipuolisen toiminnallisuuden. Esimerkiksi raportointiin ja staattiseen koodianalyysiin löytyy omat pluginit, samoin kuin web-palvelimen käynnistämiselle projektin testausta varten. Mavenin plugineista löytyy (ei kattava) lista osoitteessa <a href="http://maven.apache.org/plugins/index.html" target="_blank">http://maven.apache.org/plugins/index.html</a>.</p>

                <p>Maven automatisoi uusien projektien luomisen <em>archetype</em>-pluginin avulla, jonka avulla käyttäjät voivat tarjota valmiita projektirunkoja toisilleen. Projektirungot toimivat pohjina uusille samaa arkkitehtuuria käyttäville projekteille. Runkojen avulla ohjelmistokehittäjät voivat jakaa hyviksi todettuja käytänteitä, ja ne helpottavat myös organisaatioiden sisällä tapahtuvaa erilaisiin projektityyppeihin liittyvien arkkitehtuurien ylläpitoa.</p>

                <p>Ohjelmistokehittäjän näkökulmasta yksi tärkeimmistä ominaisuuksista on riippuvuuksien automaattinen lataaminen. Mavenin avulla projektiin voi konfiguroida kirjastoriippuvuuksia, esimerkiksi riippuvuudet yksikkötestauskirjastoihin ja web-sovelluskehyksen kirjastoihin. Maven lataa riippuvuudet automaattisesti, jolloin kirjastoja ei tarvitse pitää esimerkiksi versionhallinnassa.</p> 

                <h4>Mavenin projektirakenne</h4>

                <p>Mavenin archetype-pluginia käyttäen uuden projektin luonti tapahtuu helposti. Luodaan uusi projekti, jota tarkastelemme seuraavaksi. Uuden projektin luominen tapahtuu komentoriviltä esimerkiksi seuraavan komennon avulla.</p>

<pre>
mvn archetype:generate -DgroupId=fi.organisaatio -DartifactId=sovelluksen-nimi
</pre>

                <p>Käytännössä komennossa <code>mvn archetype:generate</code> kutsutaan mavenin archetype-pluginin tavoitetta <code>generate</code>, ja annetaan sille kaksi parametria. Parametrilla <code>-DgroupId</code> kerrotaan katto-organisaation tai ryhmän tunnus, parametrilla <code>-DartifactId</code> kerrotaan luotavan sovelluksen nimi.</p>

                <p>Komento hakee archetype-pluginista valmit projektipohjat, ja kysyy ensin mitä pohjaa haluat käyttää. Tämän jälkeen maven kyselee muita tietoja luotavasta projektista. Koska haluamme vain tutustua tässä mavenin projektirakenteeseen, vastaillaan kysymyksiin enter-painalluksilla. Tällöin maven käyttää oletusvastauksia.</p>

                <p>Kun projekti on luotu, sillä on seuraavanlainen kansiorakenne. Kansiorakenteen saa kätevästi esille <code>tree</code>-komennon avulla.</p>

<pre>
$ tree
.
+-- sovelluksen-nimi
    +-- pom.xml
    +-- src
        +-- main
        ¦   +-- java
        ¦       +-- fi
        ¦           +-- organisaatio
        ¦               +-- App.java
        +-- test
            +-- java
                +-- fi
                    +-- organisaatio
                        +-- AppTest.java

10 directories, 3 files
</pre>

                <p>Sovelluksen ja testien lähdekoodit ovat eritelty erillisiin kansioihin. Projektin alla olevassa kansiossa <code>src</code> on projektiin liittyvät lähdekoodit. Kansion <code>src</code> alla on kansiot <code>main</code> ja <code>test</code>, joissa toisessa on projektiin liittyvää koodia, ja toisessa projektiin liittyvät testit. Maven-projektin konfiguraatiotiedosto <code>pom.xml</code> on projektin juuressa.</p>

                <h4>Project Object Model</h4>

                <p>Tiedoston pom.xml lyhenne pom tulee sanoista <em>Project Object Model</em>. XML-muotoinen pom sisältää projektiin liittyvän rakenteen, asetukset, kirjastoriippuvuudet ja erikseen konfiguroidut tavoitteet. Yksinkertaisimmillaan pom.xml -tiedosto sisältää kuvauksen organisaatiosta, projektin nimestä, versiosta ja lähdekoodin pakkausmuodosta. Edellisessä osiossa luodun projektin pom.xml -sisältö näyttää seuraavalta.</p>

<pre class="sh_xml">
&lt;project xmlns="http://maven.apache.org/POM/4.0.0" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
  xsi:schemaLocation="http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd"&gt;
  &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt;

  &lt;groupId&gt;fi.organisaatio&lt;/groupId&gt;
  &lt;artifactId&gt;sovelluksen-nimi&lt;/artifactId&gt;
  &lt;version&gt;1.0-SNAPSHOT&lt;/version&gt;
  &lt;packaging&gt;jar&lt;/packaging&gt;

  &lt;name&gt;sovelluksen-nimi&lt;/name&gt;
  &lt;url&gt;http://maven.apache.org&lt;/url&gt;

  &lt;properties&gt;
    &lt;project.build.sourceEncoding&gt;UTF-8&lt;/project.build.sourceEncoding&gt;
  &lt;/properties&gt;

  &lt;dependencies&gt;
    &lt;dependency&gt;
      &lt;groupId&gt;junit&lt;/groupId&gt;
      &lt;artifactId&gt;junit&lt;/artifactId&gt;
      &lt;version&gt;3.8.1&lt;/version&gt;
      &lt;scope&gt;test&lt;/scope&gt;
    &lt;/dependency&gt;
  &lt;/dependencies&gt;
&lt;/project&gt;
</pre>

                <p>Alussa on xml-tiedoston otsake, joka määrittelee käytetyn XML-skeeman. Tämän jälkeen määritellään projektin tiedot (groupId = ryhmä, artifactId = projekti, version = projektin versio, packaging = pakkausmuoto). Tämän jälkeen tulee sovelluksen nimi (usein sama kuin projekti), sekä projektiin liittyvä osoite. Näitä seuraa projektiin liittyvät asetukset, yllä olevassa tiedostossa on määritelty että projekti käyttää UTF-8 -merkistökoodausta. Alaosassa olevassa dependencies-osiossa määritellään kirjastot, joista projekti riippuu. Esimerkissä projektille on määritelty riippuvuus yksikkötestauksessa käytettävään JUnit-sovelluskirjastoon, jonka maven lataa automaattisesti. Riippuvuuden <code>scope</code>-osiolla voidaan määritellä vaihe, johon riippuvuus liittyy -- yllä JUnit-kirjastoa käytetään vain vaiheessa <code>test</code>. Käytännössä siis JUnit on käytössä vain testausta varten, mutta se ei tule olemaan lopullisessa tuotteessa.</p>

                <h4>Riippuvuuksien hallinta</h4>

                <p>Projektikonfiguraatiossa (pom.xml) olevassa dependencies-osiossa määritellään projektin riippuvuudet. Riippuvuuksia ei ole pakko olla yhtäkään, tai niitä voi olla useita. Käytettävät kirjastot riippuvat usein myös muista kirjastoista. Maven (versiosta 2 lähtien) lataa automaattisesti myös käytettävien kirjastojen tarvitsemat riippuvuudet: esimerkiksi JUnit-kirjaston uusin versio (tätä kirjoitettaessa 4.10) vaatii hamcrest-nimisen kirjaston. Voimme kuitenkin vain määritellä riippuvuudeksi JUnit-kirjaston ja antaa Mavenin hoitaa loput. </p>

                <p>Silloin tällöin riippuvuudet saattavat mennä ristiin. Esimerkiksi kirjasto A voi riippua kirjaston C versiosta 1.1, kun taas kirjasto B voi riippua kirjaston C versiosta 1.2. Tällä hetkellä Maven päättelee käytettävän kirjaston riippuvuuksien järjestyksen perusteella. Esimerkiksi alla olevassa konfiguraatiossa kirjastosta C käytettäisiin versiota 1.1 koska riippuvuus kirjastoon A on ennen riippuvuutta kirjastoon B.</p>

<pre class="sh_xml">
  &lt;dependencies&gt;

    &lt;dependency&gt;
      &lt;groupId&gt;tarjoaja-A&lt;/groupId&gt;
      &lt;artifactId&gt;kirjasto-A&lt;/artifactId&gt;
      &lt;version&gt;...&lt;/version&gt;
    &lt;/dependency&gt;

    &lt;dependency&gt;
      &lt;groupId&gt;tarjoaja-B&lt;/groupId&gt;
      &lt;artifactId&gt;kirjasto-B&lt;/artifactId&gt;
      &lt;version&gt;...&lt;/version&gt;
    &lt;/dependency&gt;

  &lt;/dependencies&gt;
</pre>


                <p>Riippuvuuksia voi myös sulkea pois <em>exclusions</em>-tagin avulla. Alla kirjaston A riippuvuutta kirjasto C ei ladattaisi ollenkaan, jolloin kirjaston B määrittelemä riippuvuus pääsee käyttöön.</p>

<pre class="sh_xml">
  &lt;dependencies&gt;

    &lt;dependency&gt;
      &lt;groupId&gt;tarjoaja-A&lt;/groupId&gt;
      &lt;artifactId&gt;kirjasto-A&lt;/artifactId&gt;
      &lt;version&gt;...&lt;/version&gt;
      &lt;exclusions&gt;
        &lt;exclusion&gt;
          &lt;groupId&gt;tarjoaja-C&lt;/groupId&gt;
          &lt;artifactId&gt;kirjasto-C&lt;/artifactId&gt;
        &lt;/exclusion&gt;
      &lt;/exclusions&gt;
    &lt;/dependency&gt;

    &lt;dependency&gt;
      &lt;groupId&gt;tarjoaja-B&lt;/groupId&gt;
      &lt;artifactId&gt;kirjasto-B&lt;/artifactId&gt;
      &lt;version&gt;...&lt;/version&gt;
    &lt;/dependency&gt;

  &lt;/dependencies&gt;
</pre>


                <p>Riippuvuudet ladataan valmiiksi määritellyistä kirjastovarastoista eli <em>repositorioista</em>. Käytännössä Mavenilla on muutamia oletuspaikkoja kirjastojen hakemiseen, mutta niitä voi myös konfiguroida lisää. Esimerkiksi harjoitustehtävissä olevissa konfiguraatioissa on määritelty TMC:n käyttämä repository TMC:hen liittyvien kirjastojen lataamiseen seuraavasti.</p>

<pre class="sh_xml">
  &lt;repositories&gt;

    &lt;repository&gt;
      &lt;id&gt;tmc&lt;/id&gt;
      &lt;name&gt;TMC repo&lt;/name&gt;
      &lt;url&gt;http://maven.testmycode.net/nexus/content/groups/public&lt;/url&gt;
      &lt;releases&gt;
        &lt;enabled&gt;true&lt;/enabled&gt;
      &lt;/releases&gt;
      &lt;snapshots&gt;
        &lt;enabled&gt;true&lt;/enabled&gt;
      &lt;/snapshots&gt;
    &lt;/repository&gt;

  &lt;/repositories&gt;
</pre>

                <p>Lisää tietoa riippuvuuksien hallinnasta löytyy mavenin <a href="http://maven.apache.org/guides/introduction/introduction-to-dependency-mechanism.html" target="_blank">dokumentaatiosta</a>. Hyviä paikkoja kirjastojen etsimiseen ovat muunmuassa <a href="http://search.maven.org/" target="_blank">http://search.maven.org/</a> ja <a href="http://mvnrepository.com/" target="_blank">http://mvnrepository.com/</a>.</p>

                <h4>Valmiita komentoja</h4>
                
                <p>Kirjoittaessamme pom.xml-tiedoston sisältävässä kansiossa komennon <code>mvn</code>, näemme viestin, joka valittaa komennon puuttumisesta. Viestin konkreettinen sisältö riippuu mavenin versiosta, esimerkiksi mavenin versiossa 2 oleellinen sisältö on seuraavanlainen. Kolmosversiossa viesti on vaikealukuisempi...</p>

<pre>
$ mvn
...
You must specify at least one goal or lifecycle phase to perform build steps.
The following list illustrates some commonly used build commands:

  mvn clean
    Deletes any build output (e.g. class files or JARs).
  mvn test
    Runs the unit tests for the project.
  mvn install
    Copies the project artifacts into your local repository.
  mvn deploy
    Copies the project artifacts into the remote repository.
  mvn site
    Creates project documentation (e.g. reports or Javadoc).

Please see
http://maven.apache.org/guides/introduction/introduction-to-the-lifecycle.html
for a complete description of available lifecycle phases.
...
</pre>


                <p>Selaamalla osoitteeseen <a href="http://maven.apache.org/guides/introduction/introduction-to-the-lifecycle.html" target="_blank">http://maven.apache.org/guides/introduction/introduction-to-the-lifecycle.html</a> näemme tarkemman listan toiminnoista, joita maven tarjoaa ohjelmistoprojektin eri elinkaarivaiheisiin.</p>

                <p><strong>Testien suorittaminen</strong></p>

                <p>Projektiin liittyvät testit suoritetaan käyttämällä mavenin vaihetta <code>test</code>. Käytännössä kukin vaihe liittyy johonkin tiettyyn pluginiin, esimerkiksi test-vaiheessa suoritetaan <code><a href="http://maven.apache.org/plugins/maven-surefire-plugin/" target="_blank">surefire</a></code>-pluginin tavoite <code>test</code>. Lisätietoja vaiheiden oletusplugineista löytyy <a href="http://maven.apache.org/guides/introduction/introduction-to-the-lifecycle.html#Setting_Up_Your_Project_to_Use_the_Build_Lifecycle" target="_blank">täältä</a>.</p>

                <p>Suoritetaan testit antamalla projektikansiossa komento <code>mvn test</code>.</p>

<pre>
$ mvn test
// tulostusta...
[INFO] ------------------------------------------------------------------------
[INFO] Building sovelluksen-nimi 1.0-SNAPSHOT
[INFO] ------------------------------------------------------------------------
// tulostusta...
-------------------------------------------------------
 T E S T S
-------------------------------------------------------
Running fi.organisaatio.AppTest
Tests run: 1, Failures: 0, Errors: 0, Skipped: 0, Time elapsed: 0.016 sec

Results :

Tests run: 1, Failures: 0, Errors: 0, Skipped: 0

[INFO] ------------------------------------------------------------------------
[INFO] BUILD SUCCESS
[INFO] ------------------------------------------------------------------------
// tulostusta
</pre>

                <p>Käytännössä projektiin liittyvät testitiedostot, joita esimerkkiprojektissamme on vain 1, suoritetaan. Jos testeissä on ongelmia, mavenista pääsee käsiksi niihin liittyviin raportteihin.</p>

                <p>Projektin konfiguraation muokkaus on helppoa kun tietää mitä tekee. Esimerkiksi yksikkötestauskirjaston JUnit version vaihtaminen vanhasta versiosta 3.8.1 versioon 4.10 onnistuu helposti. Käytännössä vain <code>version</code>-tägin sisältö tulee vaihtaa:</p>


<pre class="sh_xml">
  ...
  &lt;dependencies&gt;
    &lt;dependency&gt;
      &lt;groupId&gt;junit&lt;/groupId&gt;
      &lt;artifactId&gt;junit&lt;/artifactId&gt;
      &lt;version&gt;4.10&lt;/version&gt;
      &lt;scope&gt;test&lt;/scope&gt;
    &lt;/dependency&gt;
  &lt;/dependencies&gt;
  ...
</pre>

                <p>Jos testit suoritetaan nyt uudestaan komennolla <code>mvn test</code>, huomataan että maven lataa JUnit-version 4.10 käyttöösi. Koska JUnit on yhteensopiva taaksepäin, testit menevät läpi.</p>


<div class="tehtavat">
  <h3 id="maven_riippuvuudet">New Dependencies</h3>
 
  <p>Tutustu tehtävässä tulevaan pom.xml -pohjaan. Mukana on TMC:n vaatimia asetuksia, esimerkiksi TMCn oman pluginvaraston osoite. Tässä tehtävässä sinun tulee lisätä tehtäväpohjan pom.xml-tiedostoon seuraavanlainen riippuvuus.</p>

<pre class="sh_xml">
    &lt;dependency&gt;
      &lt;groupId&gt;org.slf4j&lt;/groupId&gt;
      &lt;artifactId&gt;slf4j-api&lt;/artifactId&gt;
      &lt;version&gt;1.6.6&lt;/version&gt;
    &lt;/dependency&gt;
</pre>

  <p>Kun olet lisännyt riippuvuuden, suorita projektiin liittyvät testit. Jos testit menevät läpi, palauta tehtävä.</p>
</div>

                <p><strong>Paketointi</strong></p>

                <p>Projektin paketointi tapahtuu vaiheessa <em>packaging</em>, joka suoritetaan komennolla <code>package</code>. Suorittamalla komento</p>

<pre>
mvn package
</pre>

                <p>Koska vaihe package tulee testien jälkeen, maven ensin kääntää ja testaa sovelluksen. Tämän jälkeen projekti paketoidaan projektijuuressa olevaan <code>target</code>-kansioon. Sovelluksesta luodun pakkauksen nimi tulee sisältämään sovelluksen nimen ja version, eli lopulliseksi paketin nimeksi tulee <code>sovelluksen-nimi-1.0-SNAPSHOT.jar</code>. Katsoessamme projektin kansiorakennetta, huomaamme että <code>target</code>-kansiossa on muutakin. Esimerkiksi <code>target/surefire-reports</code>-kansiossa on tarkemmat kuvaukset suoritetuista testeistä.</p>

<pre>
sovelluksen-nimi$ tree
.
+-- pom.xml
+-- src
¦   +-- main
¦   ¦   +-- java
¦   ¦       +-- fi
¦   ¦           +-- organisaatio
¦   ¦               +-- App.java
¦   +-- test
¦       +-- java
¦           +-- fi
¦               +-- organisaatio
¦                   +-- AppTest.java
+-- target
    +-- classes
    ¦   +-- fi
    ¦       +-- organisaatio
    ¦           +-- App.class
    +-- maven-archiver
    ¦   +-- pom.properties
    +-- sovelluksen-nimi-1.0-SNAPSHOT.jar
    +-- surefire
    +-- surefire-reports
    ¦   +-- fi.organisaatio.AppTest.txt
    ¦   +-- TEST-fi.organisaatio.AppTest.xml
    +-- test-classes
        +-- fi
            +-- organisaatio
                +-- AppTest.class

19 directories, 9 files
</pre>

                <p><strong>Projektin käännettyjen tiedostojen siistiminen</strong></p>

                <p>Mavenin komennolla <code>clean</code> saa siistittyä projektiin poistetut käännöstiedostot. Oletuksena se poistaa target-kansion.</p>

<pre>
sovelluksen-nimi$ mvn clean
...
[INFO] --- maven-clean-plugin:2.4.1:clean (default-clean) @ sovelluksen-nimi ---
[INFO] Deleting /home/arto/tmp/sovelluksen-nimi/target
[INFO] ------------------------------------------------------------------------
[INFO] BUILD SUCCESS
[INFO] ------------------------------------------------------------------------
...
sovelluksen-nimi$ tree
.
+-- pom.xml
+-- src
    +-- main
    ¦   +-- java
    ¦       +-- fi
    ¦           +-- organisaatio
    ¦               +-- App.java
    +-- test
        +-- java
            +-- fi
                +-- organisaatio
                    +-- AppTest.java

9 directories, 3 files
</pre>


                <h2 id="peruskomponentit">Webin peruskomponentit</h2>
                
                <p><em>"I just had to take the hypertext idea and connect it to the TCP and DNS ideas and  ta-da!  the World Wide Web."</em> -- <a href="http://en.wikipedia.org/wiki/Tim_Berners-Lee" target="_blank">Tim Berners-Lee</a></p>

                <p>Kolme internetin oleellisinta osaa ovat tapa yksilöidä palveluja ja palvelujen tarjoamia resursseja verkosta (DNS, <em>Domain Name Services</em> ja URI, <em>Uniform Resource Identifier</em>), protokolla viestien lähetykseen verkon yli (HTTP, <em>HyperText Transfer Protocol</em>) ja yhteinen dokumenttien esityskieli (HTML, <em>HyperText Markup Language</em>).</p>

                <h3>URI ja DNS</h3>
                
                <p><em>"The most important thing that was new was the idea of URI-or URL, that any piece of information anywhere should have an identifier, which will allow you to get hold of it."</em> -- Tim Berners-Lee</p>

                <p>Verkossa sijaitseva sivusto tunnistetaan sille annetun yksilöivän osoitteen perusteella. Osoite (URI eli Uniform Resource Identifier terminä käyttöön jäänyt URL <em>Uniform Resource Locator</em>) koostuu resurssin nimestä ja sijainnista, joiden perusteella kysyttyyn palvelimeen ja resurssiin voidaan muodostaa yhteys.</p>

                <p><em>Periaatteessa palvelimelle tehtävää kyselyä voidaan ajatella metodikutsuna, jonka tulee palauttaa arvo tai heittää poikkeus.</em></p>

                <p>Käytännössä kun käyttäjä kirjoittaa web-selaimen osoitekenttään URIn ja painaa enteriä, web-selain lähtee tekemään kyselyä annettuun osoitteeseen. Koska tekstimuotoiset osoitteet ovat käytännössä vain ihmisiä varten, tulee selaimen ensiksi kääntää haluttu osoite, esimerkiksi <code>www.mooc.fi</code>, IP-osoitteeksi. Jos IP-osoite on jo tiedossa esimerkiksi aiemmin osoitteeseen tehdyn kyselyjen takia, selain voi ottaa yhteyden IP-osoitteeseen. Jos taas IP-osoite ei ole tiedossa, tulee selaimen ensin tehdä kysely <a href="http://fi.wikipedia.org/wiki/DNS" target="_blank">DNS</a>-palvelimelle (<em>Domain Name System</em>), jonka tehtävänä on muuntaa tekstuaaliset osoitteet IP-osoitteiksi (esim. <code>http://www.cs.helsinki.fi -> 128.214.166.78</code>).</p>

                <p><em>Ilman DNS-palvelimia ihmisten tulisi muistaa IP-osoitteet ulkoa, joka käytännössä tarkoittaisi ettei nykyinen internet toimisi.</em></p>

                <p>IP-osoitteet yksilöivät tietokoneet, ja mahdollistavat koneiden löytämisen verkon yli. Käytännössä yhteys IP-osoitteen määrittelemään koneeseen avataan sovellustason HTTP-protokollan avulla kuljetustason TCP-protokollan yli. TCP-protokollan tehtävänä on varmistaa, että viestit pääsevät perille. Lisää tietoa konkreettisesta tietoliikenteestä kurssilla <a href="http://www.cs.helsinki.fi/courses/582202" target="_blank">Tietoliikenteen perusteet</a>.</p>

                <p>Kun palvelin vastaanottaa tiettyyn resurssiin liittyvän pyynnön, palauttaa se vastauksen kyselijälle. Kun selain saa vastauksen, tarkistaa se vastaukseen liittyvän <a href="http://httpcats.herokuapp.com/" target="_blank">statuskoodin</a> ja siihen liittyvät tiedot. Jos vastauksen saa tallettaa välimuistiin, tallennetaan se tulevaisuutta varten. Tämän jälkeen selain päättelee, mitä vastauksella tehdään, ja esimerkiksi renderöi vastaukseen liittyvän web-sivun käyttäjälle.</p> 

                <p>Käytännössä URIt näyttävät seuraavilta:</p>


<pre>
protokolla://isäntäkone[:portti]/polku/../[kohdedokumentti][?kyselyparametrit][#ankkuri]
</pre>

                <p>
                  <ul>
                    <li>protokolla: kyselyssä käytettävä protokolla, esimerkiksi http tai ftp.</li>
                    <li>isäntäkone: kone tai palvelin johon luodaan yhteys. Voi olla joko IP-osoite tai tekstuaalinen kuvaus.</li>
                    <li>portti: portti isäntäkoneella johon yhteys luodaan. HTTP-palvelimien oletusportti on 80. Jos palvelin käyttää eri porttinumeroa kuin 80, tulee se merkitä osoitteeseen. Portti käytännössä määrittelee prosessin, johon yritetään ottaa yhteyttä.</li>
                    <li>polku: periaatteessa polku resurssiin palvelimella. Käytännössä (nykyään) palvelun osoite, johon palvelin osaa osoittaa. Usein palvelut toimivat erillisessä koneessa sisäverkossa, ja ulkoverkkoon näkyvä kone vain toimii ohjaajana eli proxynä oikeaan palveluun.</li>
                    <li>kohdedokumentti: haettava resurssi, jos kohdedokumenttia ei ole määritelty palvelin päättelee oletusdokumentin. Usein index.html</li>
                    <li>kyselyparametrit: koostuu avain-arvo -pareista, joiden avulla palvelimelle pystyy toteuttamaan lisätoiminnallisuutta. Kuhunkin avaimeen liittyvä arvo esitetään = -merkillä, avain-arvo -parit erotetaan toisistaan &-merkillä.</li>
                    <li>ankkuri: kertoo mihin kohtaan dokumentissa tulee mennä.</li>
                  </ul>
                </p>

<div class="pohdi">
  <p><strong>Osoitteen osat</strong></p>
  
  <p>Tutki osoitetta <a href="http://www.googlefight.com/index.php?lang=en_GB&word1=Batman&word2=Superman" target="_blank">http://www.googlefight.com/index.php?lang=en_GB&word1=Batman&word2=Superman</a>. Mitkä tai mikä ovat/on osoitteen:</p>

    <ul>
      <li>protokolla</li>
      <li>isäntäkone</li>
      <li>portti</li>
      <li>polku</li>
      <li>kohdedokumentti</li>
      <li>kyselyparametrit</li>
      <li>ankkuri</li>
    </ul>

    <p>Mitkä näistä puuttuvat?</p>
</div>


                <h3>HTTP</h3>

                <p>HTTP (<em>HyperText Transfer Protocol</em>) on TCP/IP -protokollapinon sovellustason protokolla. Web-palvelimet ja selaimet keskustelevat HTTP-protokollaa käyttäen. HTTP-protokolla perustuu asiakas-palvelin malliin, jossa jokaista pyyntöä kohden on yksi vastaus (<em>request-response paradigm</em>). Käytännössä HTTP-asiakasohjelma (jatkossa selain) lähettää HTTP-viestin HTTP-palvelimelle (jatkossa palvelin), joka palauttaa HTTP-vastauksen. HTTP-protokollan versio 1.1 on määritelty <a href="http://www.w3.org/Protocols/rfc2616/rfc2616.html" target="_blank">RFC 2616</a>-spesifikaatiossa.</p>

                <h4>Asiakas-palvelin malli</h4>

                <p>Asiakas-palvelin -mallissa <em>(Client-Server model)</em> asiakkaat käyttävät palvelimen tarjoamia palveluja. Kommunikointi asiakkaan ja palvelimen välillä tapahtuu usein verkon yli siten, että asiakasohjelmisto ja palvelinohjelmisto sijaitsevat erillisissä fyysisissä sijainneissa (eri tietokoneilla). Palvelinohjelmisto tarjoaa yhden tai useamman palvelun, joita asiakasohjelmisto käyttää.</p>

                <p>Käytännössä asiakasohjelmisto tarjoaa käyttöliittymän ohjelmiston loppukäyttäjälle. Asiakasohjelmiston käyttäjän ei tarvitse tietää, että kaikki käytetty tieto ei ole hänen koneella. Käyttäjän tehdessä toiminnon asiakasohjelmisto pyytää tarpeen vaatiessa palvelimelta käyttäjän tarpeeseen liittyvää lisätietoa. Tyypillistä mallille on se, että palvelin tarjoaa vain asiakkaan pyytämät tiedot. Tällöin verkossa liikkuvan tiedon määrä pysyy vähäisenä.</p>

                <p>Asiakas-palvelin -malli mahdollistaa hajautetut ohjelmistot: asiakasohjelmistoa käyttävät loppukäyttäjät voivat sijaita eri puolilla maapalloa palvelinohjelmiston sijaitessa tietyssä paikassa.</p> 


<div class="pohdi">

  <p><strong>Chuck Norris</strong></p>

  <p>Valitse sopiva web-selain ja mene osoitteeseen <a href="http://www.imdb.com" target="_blank">http://www.imdb.com</a>. Kirjoita sivuston ylälaidassa olevaan kenttään "Chuck Norris" ja paina Enter. Mitkä seuraavista askeleista tapahtuivat asiakasohjelmistossa, mitkä palvelinohjelmistossa, mitkä muualla? Voit olettaa että asiakasohjelmistolla tarkoitetaan valitsemaasi web-selainta.</p>

  <ol>
    <li>Osoitteen http://www.imdb.com kirjoittaminen.</li>
    <li>Osoitetta http://www.imdb.com vastaavan palvelimen etsiminen.</li>
    <li>Sivun http://www.imdb.com näyttäminen web-selaimen käyttäjälle.</li>
    <li>Chuck Norrikseen liittyvien tietojen ja elokuvien haku.</li>
  </ol>

</div>

                <p>Haasteena perinteisessä asiakas-palvelin mallissa on se, että palvelin sijaitsee yleensä tietyssä keskitetyssä sijainnissa. Keskitetyillä palveluilla on mahdollisuus ylikuormittua asiakasmäärän kasvaessa. Kapasiteettia rajoittavat muunmuassa palvelimen fyysinen kapasiteetti (rauta), palvelimeen yhteydessä olevan verkon laatu ja nopeus, sekä tarjotun palvelun tyyppi. Esimerkiksi tietokantatransaktiota vaativat pyynnöt vievät huomattavasti enemmän aikaa kuin yksinkertaiset lukuoperaatiot. Asiakas-palvelin mallissa tuottaa haasteita myös vikasietoisuus, miten toimia jos palvelinkoneesta hajoaa esimerkiksi kovalevy?</p>

<div class="tehtavat">

  <h3>Knock-knock! Who's there?</h3>

  <p>Lähes kaikki sovellusten verkkoliikenne sovellustason protokollasta riippumatta käyttää TCP-yhteyksiä ja -portteja kommunikointiin. TCP-yhteyksiä käytetään Javassa <a href="http://docs.oracle.com/javase/6/docs/api/java/net/Socket.html" target="_blank"><code>Socket</code></a>- ja <a href="http://docs.oracle.com/javase/6/docs/api/java/net/ServerSocket.html" target="_blank"><code>ServerSocket</code></a>-luokkien avulla.</p>

  <p><a href="http://en.wikipedia.org/wiki/Knock-knock_joke">Eräs suosittu viestiprotokolla</a> (eli säännöstö, joka kertoo kuinka kommunikoinnin tulee kulkea) alkaa sanoilla <code>Knock knock!</code>. Toinen osapuoli vastaa tähän <code>Who's there?</code>. Ensimmäinen osapuoli vastaa jotain, esim. <code>Art</code>, jonka jälkeen toisen osapuolen tulee vastata <code>Art who?</code>. Tähän ensimmäinen osapuoli vastaa viestillä joka päättyy <code>"Bye."</code>.</p>

<pre>
Server: Knock knock!
Client: Who's there?
Server: Robin
Client: Robin who?
Server: Robin your house! Bye.
</pre>

  <p>Tehtäväpohjan mukana tulee projekti, johon palvelinpuolen toiminnallisuus on toteutettu valmiina luokassa <code>KnockKnockServer</code>. Palvelinohjelmisto kuuntelee vastaanottoa portissa <code>12345</code>.</p>

  <p>Tehtävänäsi on toteuttaa valmiiksi toteutettua palvelinkomponenttia varten asiakaspuolen toiminnallisuus, eli sovellus, joka tekee kyselyjä palvelimelle. Asiakaspuolen toiminnallisuutta varten on jo olemassa allaoleva runko, joka tulee myös mukana tehtäväpohjan luokassa <code>KnockKnockClient</code>.</p>

  <p>Täydennä asiakasohjelmisto annettujen askelten mukaan siten, että sitä voi käyttää kommunikointiin viestiprotokollapalvelimen kanssa.</p>

<pre class="sh_java">
        // Luodaan yhteys palvelimelle
        Socket socket = new Socket("localhost", port);

        Scanner serverMessageScanner = new Scanner(socket.getInputStream());
        PrintWriter clientMessageWriter = new PrintWriter(
                socket.getOutputStream(), true);

        Scanner userInputScanner = new Scanner(System.in);

        // Luetaan viestejä palvelimelta
        while (serverMessageScanner.hasNextLine()) {
            // 1. lue viesti palvelimelta
            // 2. tulosta palvelimen viesti standarditulostusvirtaan näkyville

            // 3. jos palvelimen viesti loppuu merkkijonon "Bye.", poistu toistolausekkeesta

            // 4. pyydä käyttäjältä palvelimelle lähetettävää viestiä
            // 5. kirjoita lähetettävä viesti palvelimelle. Huom! Käytä println-metodia.
        }
</pre>

  <p>Sinun tulee kirjoittaa asiakasohjelmiston lähdekoodi <code>KnockKnockClient</code>-luokan <code>start</code>-metodiin. Kun olet saanut ohjelmiston valmiiksi, suorita ohjelma, jotta voit kokeilla sitä. Tehtäväpohjan mukana on ohjelman käynnistävä <code>main</code>-metodin sisältävä luokka valmiina. Tulostuksen pitäisi olla esimerkiksi seuraavanlainen (käyttäjän syöttämät tekstit on merkitty punaisella):</p>

<pre>
Server: Knock knock!
Type a message to be sent to the server: <font color="red">Who's there?</font>
Server: Lettuce
Type a message to be sent to the server: <font color="red">Lettuce who?</font>
Server: Lettuce in! it's cold out here! Bye.
</pre>

 <p>Jos asiakasohjelmisto lähettää virheellisiä viestejä, reagoi palvelin siihen seuraavasti:</p>
<pre>
Server: Knock knock!
Type a message to be sent to the server: <font color="red">What?</font>
Server: You are supposed to ask: "Who's there?"
Type a message to be sent to the server: <font color="red">Who's there?</font>
Server: Lettuce
Type a message to be sent to the server: <font color="red">huh</font>
Server: You are supposed to ask: "Lettuce who?"
Type a message to be sent to the server: <font color="red">Lettuce who?</font>
Server: Lettuce in! it's cold out here! Bye.
</pre>

  <p>Kun ohjelma toimii mielestäsi vaaditulla tavalla, suorita ohjelman testit. Lähetä tehtävä lopulta TMC-palautusautomaattiin, kun tehtävän testit menevät läpi.</p>

</div>                

<div class="extra">
  <p>Periaatteessa web-palvelinohjelmistot toimivat kuten yllä toteutettu sovellus, mutta ne käyttävät kommunikointiin HTTP-protokollaa. Yllä olleessa tehtävässä toteutettiin osa selainta vastaavasta toiminnallisuudesta, palvelimen toiminnallisuus oli jo valmiina.</p>
  <p>Käytännössä web-selaimetkin ottavat yhteyden haluttuun osoitteeseen liittyvään porttiin, kirjoittavat sinne, ja lukevat sieltä palautettavaa tietoa.  </p>
  <p>Haluaisitko kirjoittaa web-sovelluksia socketeilla? Jotkut tekevät tätäkin työkseen!</p>
</div>


<!--
                <p>Käytännössä palvelimet ja selaimet kommunikoivat hyvin harvoin suoraan keskenään (poikkeuksia: omalla koneella toimivan palvelimen käyttö). Välissä on yksi tai useampi välityspalvelin, jonka tehtävänä on ohjata pyyntö eteenpäin. Yhteys selaimen ja palvelimen välillä muodostuu siis ketjusta koneita. Lähetettävä viesti ja siihen liittyvä vastaus kulkee kaikkien ketjussa olevien koneiden läpi.</p>

<div class="tehtavat">
  <h3>traceroute-työkalu</h3>

  <p>Linux-ympäristöissä on käytössä <code>traceroute</code>-työkalu, jolla voi tutkia viestin kulkemaa reittiä verkossa. Sitä käytetään kirjoittamalla</p>

<pre>
traceroute palvelun_osoite.net
</pre>

  <p>Vastauksena on lista palvelimista ja ajoista, jotka kertovat minkä verran viestillä meni kuhunkin osoitteeseen pääsemisessä. Alla esimerkki kyselystä <code>traceroute www.google.fi</code>. </p>

<pre>
$ traceroute www.google.fi
traceroute to www.google.fi (209.85.137.94), 30 hops max, 60 byte packets
 1  schengen.cs.helsinki.fi (128.214.9.157)  0.164 ms  0.137 ms  0.139 ms
 2  kumpula1-cs.fe.helsinki.fi (128.214.173.153)  0.488 ms  0.523 ms  0.602 ms
 3  vallila2-kumpula1.fe.helsinki.fi (128.214.173.22)  0.724 ms * *
 4  riippa-vallila2.fe.helsinki.fi (128.214.173.241)  0.625 ms  0.608 ms *
 5  * * *
 6  se-tug.nordu.net (109.105.102.61)  7.350 ms  7.406 ms  7.382 ms
 7  se-tug2.nordu.net (109.105.97.18)  7.268 ms  7.549 ms  7.520 ms
 8  * google-gw.nordu.net (109.105.98.6)  7.509 ms *
 9  * 209.85.250.192 (209.85.250.192)  7.717 ms 216.239.43.122 (216.239.43.122)  7.819 ms
10  209.85.249.40 (209.85.249.40)  17.190 ms 72.14.233.180 (72.14.233.180)  17.361 ms 209.85....
11  72.14.233.170 (72.14.233.170)  16.934 ms 72.14.233.172 (72.14.233.172)  16.845 ms  16.739 ms
12  209.85.254.33 (209.85.254.33)  27.601 ms *  18.017 ms
13  lpp01m02-in-f94.1e100.net (209.85.137.94)  16.781 ms  16.917 ms  19.168 ms
</pre>

  <p>Tracerouten näyttämät tähdet (<code>*</code>) tarkoittavat että lähetettyyn kyselyviestiin ei annettu vastausta, tai että vastaus katosi matkalla takaisin. Tätä kutsutaan yleisesti ottaen <code>packet loss</code>:iksi.</p>

  <p>Tehtävä: Kirjaudu jollekin TKTL:n koneelle ssh:n yli (esim melkille: melkki.cs.helsinki.fi), ja tutki mitä reittiä viestit kulkevat yhdysvaltojen puolustusministeriön verkkosivuille (<code>defense.gov</code>) ja FBI:n sivuille (<code>fbi.gov</code>). Ovatko verkkosivujen palvelimet samassa maanosassa? Perustele.</p> 
</div>

//-->

                <h4>HTTP-viestin rakenne: palvelimelle lähetettävä kysely</h4>
                
                <p>HTTP-protokollan yli lähetettävät viestit ovat tekstimuotoisia. Viestit koostuvat riveistä jotka muodostavat otsakkeen, sekä riveistä jotka muodostavat viestin rungon. Viestin runkoa ei ole pakko olla olemassa. Viestin loppuminen ilmoitetaan kahdella peräkkäisellä rivinvaihdolla.  Palvelimelle lähetettävän viestin, eli kyselyn, ensimmäisellä rivillä on pyyntötapa, halutun resurssin polku ja HTTP-protokollan versionumero.</p>

<pre>
PYYNTÖTAPA /POLKU_HALUTTUUN_RESURSSIIN HTTP/versio
otsake-1: arvo
otsake-2: arvo

valinnainen viestin runko
</pre>

                <p>Pyyntötapa kertoo HTTP-protokollassa käytettävän pyynnön tavan (esim. <code>GET</code> tai <code>POST</code>), polku haluttuun resurssiin kertoo haettavan resurssin sijainnin palvelimella (esim. <code>/index.html</code>), ja HTTP-versio kertoo käytettävän version (esim. <code>HTTP/1.0</code>). Alla esimerkki hyvin yksinkertaisesta -- joskin yleisestä -- pyynnöstä. Huomaa että pyyntöä tehdessä yhteys palvelimeen on jo muodostettu, eli palvelimen osoitetta ei merkitä erikseen.</p>

<pre>
GET /index.html HTTP/1.0

</pre>

                <p>Yksittäisen koneen dedikointi web-palvelimeksi jättää usein huomattavan osan koneen kapasiteetista käyttämättä. Nykyään yleisesti käytössä oleva HTTP/1.1 -protokolla mahdollistaa useamman palvelimen pitämisen samalla koneella virtuaalipalvelintekniikan avulla, jolloin yksittäiset palvelinkoneet voivat sisältää useita palvelimia. Käytännössä IP-osoitetta kuunteleva kone voi joko itsessään sisältää useita ohjelmistoilla emuloituja palvelimia, tai se voi toimia reitittimenä ja ohjata pyynnön tietylle esimerkiksi yrityksen sisäverkossa sijaitsevalle koneelle. Kun yksittäinen IP-osoite voi sisältää useampia palvelimia, pelkkä polku haluttuun resurssiin ei riitä oikean resurssin löytämiseen: resurssi voisi olla millä tahansa koneeseen liittyvällä virtuaalipalvelimella. HTTP/1.1 -protokollassa on pyynnöissä pakko olla mukana käytetyn palvelimen osoitteen kertova <code>Host</code>-otsake.</p>

<pre>
GET /index.html HTTP/1.1
Host: www.munpalvelin.net

</pre>


                <h4>HTTP-viestin rakenne: palvelimelta saapuva vastaus</h4>

                <p>Palvelimelle tehtyyn pyyntöön saadaan aina jonkinlainen vastaus. Jos tekstimuotoiseen osoitteeseen ei ole liitetty IP-osoitetta DNS-palvelimilla, selain ilmoittaa ettei palvelinta löydy. Jos palvelin löytyy, ja pyyntö saadaan tehtyä palvelimelle asti, tulee palvelimen myös vastata jollain tavalla.</p>

                <p>Palvelimelta saatavan vastauksen sisältö on seuraavanlainen. Ensimmäisellä rivillä HTTP-protokollan versio, viestiin liittyvä statuskoodi, sekä statuskoodin selvennys. Tämän jälkeen on joukko otsakkeita, tyhjä rivi, ja mahdollinen vastausrunko. Vastausrunko ei ole pakollinen.</p>

<pre>
HTTP/versio statuskoodi selvennys
otsake-1: arvo
otsake-2: arvo

valinnainen vastauksen runko
</pre>

               <p>Esimerkiksi:</p>
<pre>
HTTP/1.1 200 OK
Date: Sat, 07 Jan 2012 03:12:45 GMT
Server: Apache/2.2.14 (Ubuntu)
Vary: Accept-Encoding
Content-Length: 973
Connection: close
Content-Type: text/html;charset=UTF-8

.. runko ..
</pre>

                <h4>Statuskoodit</h4>

                <p>Statuskoodit (<em>status code</em>) kuvaavat palvelimella tapahtunutta toimintaa kolmella numerolla. Statuskoodien avulla palvelin kertoo mahdollisista ongelmista tai tarvittavista lisätoimenpiteistä. Yleisin statuskoodi on <code>200</code>, joka kertoo kaiken onnistuneen oikein. HTTP/1.1 sisältää viisi kategoriaa vastausviesteihin.</p>

<ul>
  <li>1**: informaatioviestit (esim 100 "Continue")</li>
  <li>2**: onnistuneet tapahtumat (esim 200 "OK")</li>
  <li>3**: asiakasohjelmistolta tarvitaan lisätoimintoja (esim 301 "Moved Permanently")</li>
  <li>4**: virhe pyynnössä tai erikoistilanne (esim 401 "Not Authorized" ja 404 "Not Found")</li>
  <li>5**: virhe palvelimella (esim 500 "Internal Server Error")</li>
</ul>

                <p>Lisätietoja statuskoodeista osoitteissa <a href="http://httpcats.herokuapp.com" target="_blank">http://httpcats.herokuapp.com</a>.<br><img src="img/200.jpg" /></p>


<div class="extra">
  <p><strong>telnet-työkalu</strong></p>

  <p>Linux-ympäristöissä on käytössä telnet-työkalu, jota voi käyttää yksinkertaisena asiakasohjelmistona pyyntöjen simulointiin. Telnet-yhteyden tietyn koneen tiettyyn porttiin saa luotua komennolla <code>telnet isäntäkone portti</code>. Esimerkiksi TKTL:n www-palvelimelle saa yhteyden seuraavasti:</p>

<pre>
$ telnet cs.helsinki.fi 80
</pre>

  <p>Tätä seuraa telnetin infoa yhteyden muodostamisesta, jonka jälkeen pääsee kirjoittamaan pyynnön.</p>

<pre>
Trying 128.214.166.78...
Connected to cs.helsinki.fi.
Escape character is '^]'.

</pre>

  <p>Yritetään pyytää HTTP/1.1 -protokollalla juuridokumenttia. Huom! HTTP/1.1 -protokollassa tulee pyyntöön lisätä aina Host-otsake. Jos yhteys katkaistaan ennen kuin olet saanut kirjoitettua viestisi loppuun, ota apuusi tekstieditori ja copy-paste. Muistathan myös että viesti lopetetaan aina kahdella rivinvaihdolla.</p>

<pre>
GET / HTTP/1.1
Host: cs.helsinki.fi

</pre>

  <p>Palvelin lähettää meille vastauksen, jossa on statuskoodi ja otsakkeita sekä dokumentin runko.</p>

<pre>
HTTP/1.1 302 Found
Date: Sun, 26 Aug 2012 18:31:30 GMT
Server: Apache/2.2.14 (Ubuntu)
Location: http://www.cs.helsinki.fi/
Vary: Accept-Encoding
Content-Length: 290
Content-Type: text/html; charset=iso-8859-1

&lt;!DOCTYPE HTML PUBLIC "-//IETF//DTD HTML 2.0//EN"&gt;
&lt;html&gt;&lt;head&gt;
&lt;title&gt;302 Found&lt;/title&gt;
&lt;/head&gt;&lt;body&gt;
&lt;h1&gt;Found&lt;/h1&gt;
&lt;p&gt;The document has moved &lt;a href="http://www.cs.helsinki.fi/"&gt;here&lt;/a&gt;.&lt;/p&gt;
&lt;hr&gt;
&lt;address&gt;Apache/2.2.14 (Ubuntu) Server at cs.helsinki.fi Port 80&lt;/address&gt;
&lt;/body&gt;&lt;/html&gt;
</pre>

  <p>Juuripolkua palvelimelta <code>cs.helsinki.fi</code> haettaessa palvelin vastaa että dokumentti on löytynyt (<code>302 Found</code>), mutta se sijaitsee muualla (<code>Location: http://www.cs.helsinki.fi/</code>).</p>

</p>
</div>

<div class="pohdi">
  <p><strong>Kuinka monta hyppyä?</strong></p>
  
  <p>Käytä telnetiä ja aloita osoitteesta <code>cs.helsinki.fi</code>, tavoitteenasi on päästä laitoksen etusivulle <code>http://www.cs.helsinki.fi/home/</code>. Kuinka monta uudelleenohjausta saat ennenkuin pääset etusivulle?</p>

</div>

                <h4>HTTP-protokollan pyyntötavat</h4>

                <p>HTTP-protokolla määrittelee kahdeksan erillistä pyyntötapaa (<em>Request method</em>). Yleisimmin käytetyt ovat <code>GET</code>, <code>POST</code> ja <code>HEAD</code>, joiden lisäksi on olemassa <code>PUT</code>, <code>DELETE</code>, <code>TRACE</code>, <code>OPTIONS</code> ja <code>CONNECT</code>. Pyyntötavat määrittelevät rajoitteita ja suosituksia viestin rakenteeseen ja niiden prosessointiin palvelinpäässä. Esimerkiksi <a href="http://jcp.org/aboutJava/communityprocess/mrel/jsr154/index2.html" target="_blank">Java Servlet API (versio 2.5)</a> sisältää seuraavan suosituksen GET-pyyntotapaan liittyen:</p>

                <p><em>The GET method should be safe, that is, without any side effects for which users are held responsible. For example, most form queries have no side effects. If a client request is intended to change stored data, the request should use some other HTTP method.</em></p>
                
                <p><em>The GET method should also be idempotent, meaning that it can be safely repeated. Sometimes making a method safe also makes it idempotent. For example, repeating queries is both safe and idempotent, but buying a product online or modifying data is neither safe nor idempotent.</em></p>

                <p>Suomeksi yksinkertaistaen: <code>GET</code>-tyyppisten pyyntöjen ei pitäisi muuttaa palvelimella olevaa dataa.</p>
                
                 <p><strong>GET</strong></p>
                
                <p>GET on yksinkertaisin pyyntötapa. Sitä käytetään esimerkiksi dokumenttien hakemiseen: kun kirjoitat osoitteen selaimen osoitekenttään ja painat enter, selain tekee GET-pyynnön. GET-pyynnöt eivät tarvitse otsaketietoja HTTP/1.1:n vaatiman Host-otsakkeen lisäksi. Mahdolliset kyselyparametrit lähetetään palvelimelle osana haettavaa osoitetta.</p>

<pre>
GET /lets/See?porkkana=1 HTTP/1.1
Host: t-avihavai.users.cs.helsinki.fi

</pre>

                <p><strong>POST</strong></p>
                
                <p>Käytännön ero POST- ja GET-kyselyn välillä on se, että POST-tyyppisillä pyynnoillä kyselyparametrit liitetään pyynnön runkoon. Rungon sisältö ja koko määritellään otsakeosiossa. POST-kyselyt mahdollistavat multimedian (kuvat, videot, musiikki, ...) lähettämisen palvelimelle.</p>

<pre>
POST /lets/See HTTP/1.1
Host: t-avihavai.users.cs.helsinki.fi
Content-Type: application/x-www-form-urlencoded
Content-Length: 10

porkkana=1
</pre>

                <p><strong>HEAD ja otsakkeet</strong></p>
                
                <p>HEAD-kyselyt ovat samantyyppisiä GET-kyselyiden kanssa, mutta niillä pyydetään palvelimelta vain haettavaan dokumenttiin liittyviä otsaketietoja. Tämä mahdollistaa muunmuassa muutosten seurannan palvelimelta saatavan <code>Last-modified</code>-otsakkeen avulla, sekä palvelimen toiminnallisuuden testaamisen.</p>

                <p>HEAD-kyselyä on perinteisesti käytetty välimuistitoiminnallisuuden toteuttamiseen, jolloin selaimen välimuistissa olevista dokumenteista on tehty ensiksi vain HEAD-kysely. Jos dokumentti ei ole muuttunut, eli otsake <code>Last-modified</code> sisältää tarpeeksi vanhan ajan, ei dokumenttiin liittyvää runkoa ole haettu.</p>

                <p>Luodaan telnetillä yhteys palvelimeen <code>www.cs.helsinki.fi</code> ja kysytään otsaketietoja resurssiin <code>/home/</code> liittyen. Käytämme HTTP:n versiota 1.1 (<code>HTTP/1.1</code>), joten lisäämme pyyntöön myös <code>Host</code>-otsakkeen.</p>

<pre>
$ telnet www.cs.helsinki.fi 80
Trying 128.214.166.78...
Connected to www.cs.helsinki.fi.
Escape character is '^]'.
HEAD /home/ HTTP/1.1
Host: www.cs.helsinki.fi 

</pre>

                <p>Vastauksena saamme palvelimen vastausrivin jossa on HTTP-versio, statuskoodi ja selvennys. Seuraavilla riveillä on otsakkeita, jotka tarjoavat lisätietoa haettavasta dokumentista ja käytettävästä palvelimesta.</p>
<pre>
HTTP/1.1 200 OK
Date: Sat, 07 Jan 2012 07:13:49 GMT
Server: Apache/2.2.14 (Ubuntu)
X-Powered-By: PHP/5.3.2-1ubuntu4.11
Last-Modified: Sat, 07 Jan 2012 07:13:51 GMT
Cache-Control: store, no-cache, must-revalidate
Cache-Control: post-check=0, pre-check=0
Vary: Accept-Encoding
Content-Type: text/html; charset=utf-8
</pre>

                <p>Vastauksesta huomataan että TKTL:n palvelin on huonosti konfiguroitu: <code>Last-Modified</code> -otsake, joka kertoo milloin resurssia on muokattu, määrittelee tulevaisuudessa olevan päivämäärän. Otsake <code>Date</code> taas kertoo hetken, jolloin pyyntö on tehty. Otsakkeissa on myös muuta hyödyllistä tietoa. Esimerkiksi otsake <code>Cache-Control</code> sisältää välimuistitoiminnallisuuteen liittyviä ohjeita; arvo <code>no-cache</code> määrittelee että sivun ajankohtaisuus tulee aina varmistaa palvelimelta. Huomaamme myös mielenkiintoisen arvon <code>store</code>, jota -- sen yleisessä käytössä olemisesta huolimatta -- ei määritellä HTTP/1.1 -otsakkeeseen <code>Cache-Control</code> liittyvässä <a href="http://www.w3.org/Protocols/rfc2616/rfc2616-sec14.html#sec14.9" target="_blank">osiossa</a> (arvo <code>store</code> on määrittelemätön laajennus). Käytännössä TKTL:n verkkosivu pyrkii siihen, että selain ei tallenna sitä välimuistiin.</p>

                <p>Nykyaikaisempi tapa on HEAD-pyynnön sijaan resurssin version tarkastamiseen on <code>ETag</code>-otsakkeen käyttö osana GET-pyyntöä. GET-pyyntöä suoritettaessa pyynnön mukana lähetetään otsakkeena resurssin version yksilöivä tunnus. Jos palvelimella oleva versio on sama kuin selaimen tiedossa oleva yksilöivä tunnus, palvelin voi palauttaa yksinkertaisesti vastauksen <code>HTTP 304 Not Modified</code>, eli resurssi ei ole muuttunut. Kuten HEAD-pyynnössä, myös ETag-otsaketta käyttävässä GET-pyynnössä resurssi tulee olla jo kerran ladattu.</p>

<div class="extra">
  <p><strong>curl-työkalu</strong></p>

  <p>Telnetin lisäksi curl on hyödyllinen apuväline pyyntöjen tekemiseen ja tarkasteluun. Curl tarjoaa parametrin <code>-i</code> (<em>include headers in output</em>), jota voi käyttää palvelimen palauttamien otsaketietojen tarkasteluun. Esimerkiksi kysely <code>curl -i hs.fi</code> palauttaa seuraavat tiedot:</p>

<pre>
$ curl -i hs.fi
HTTP/1.1 301 Object Moved
Location: http://www.hs.fi/
Content-Length: 0

</pre>
</div>

<!--
* HTTP, tilattomuus, tilallisuus
<//-->

                <h3>HTTP on tilaton protokolla</h3>

                <p>HTTP on tilaton protokolla, eli se ei tarvitse jatkuvasti avoinna olevaa yhteyttä toimiakseen. Tämä tarkoittaa sitä, että HTTP ei osaa yhdistä samalta käyttäjältä tulevia pyyntöjä toisiinsa, jolloin jokainen tehty pyyntö käsitellään omana erillisenä pyyntönään. Käytännössä yhden web-sivustonkin hakeminen saattaa sisältää kymmeniä pyyntöjä, sillä jokaiseen sivuun liittyy joukko kuvia ja skriptitiedostoja, joista kukin on oma erillinen resurssinsa.</p>

                <p>Vaikka HTTP on tilaton protokolla, on asiakkaan tunnistamiseen käytetty pitkään erilaisia kiertotapoja. Klassinen tapa kiertää HTTP:n tilattomuus on ollut säilyttää GET-muotoisessa osoitteessa parametreja, joiden perusteella asiakas voidaan identifioida palvelinsovelluksessa. Parametrien käyttö osoitteissa ei ole kuitenkaan ongelmatonta: osoitteessa olevia parametreja voi helposti muokata käsin, jolloin palvelinsovelluksesta saattaa löytyä tietoturva-aukkoja tai ei-toivottua käyttäytymistä.</p>

<div class="extra">
  <p>Eräässä järjestelmässä verkkokaupan toiminnallisuus oli toteutettu siten, että GET-parametrina säilytettiin numeerista ostoskorin identifioivaa tunnusta. Käyttäjäkohtaisuus oli toteutettu palvelinpuolella siten, että tietyllä GET-parametrilla näytettiin aina tietyn käyttäjän ostoskori. Uusien tuotteiden lisääminen ostoskoriin onnistui helposti, sillä pyynnöissä oli aina mukana ostoskorin tunnistava GET-parametri. Ostoskorit oli valitettavasti identifioitu juoksevalla numerosarjalla. Henkilöllä 1 oli ostoskori 1, henkilöllä 2 ostoskori 2 jne.. Koska käytännössä kuka tahansa pääsi katsomaan kenen tahansa ostoskoria vain osoitteessa olevaa numeroa vaihtamalla, olivat ostoskorien sisällöt välillä hyvin mielenkiintoisia.</p>
</div>


                <p>HTTP-protokollan tilattomuus ei pakota palvelinohjelmistoja tilattomuuteen. Palvelimella tilaa pidetään yllä jollain tietyllä tekniikalla, joka taas ei näy HTTP-protokollaan asti. Nykyään yleisin tekniikka tilattomuuden kiertämiseen on evästeiden käyttö.</p>


                <h4>HTTP-protokollan tilattomuuden kiertäminen: evästeet</h4>

                <p>HTTP on tilaton protokolla, eli käyttäjän toimintaa ja tilaa ei pysty pitämään yllä puhtaasti HTTP-yhteyden avulla. Käytännössä suurin osa verkkosovelluksista kuitenkin sisältää käyttäjäkohtaista toiminnallisuutta, jonka toteuttamiseen sovelluksella täytyy olla jonkinlainen tieto käyttäjästä ja käyttäjän tilasta. HTTP/1.1 tarjoaa mahdollisuuden tilallisten verkkosovellusten toteuttamiseen evästeiden (<em>cookies</em>) avulla.</p>

                <p>Asettamalla käyttäjän tekemän pyynnön vastaukseen eväste, tulee käyttäjän jatkossa pyyntöä tehdessä aina palauttaa kyseinen eväste pyynnön otsaketietoina. Tämä tapahtuu automaattisesti selaimen toimesta. Evästeitä käytetään istuntojen (<em>session</em>) ylläpitämiseen: istuntojen avulla pidetään kirjaa käyttäjästä useampien pyyntöjen yli.</p>

                <p>Evästeet toteutetaan otsakkeiden avulla. Kun käyttäjä tekee pyynnön palvelimelle, ja palvelimella halutaan asettaa käyttäjälle eväste, palauttaa palvelun vastauksen mukana otsakkeen <code>Set-Cookie</code>, jossa määritellään käyttäjäkohtainen evästetunnus. Set-Cookie voi olla esimerkiksi seuraavan näköinen:</p>

<pre>
Set-Cookie: SESS57a5819a77579dfb1a1466ccceee22a0=0hr0aa2ogdfgkelogg; Max-Age=3600; Domain=".helsinki.fi"
</pre>

                <p>Ylläoleva palvelimelta lähetetty vastaus ilmoittaa pyytää selainta tallettamaan evästeen. Selaimen tulee jatkossa lisätä eväste <code>SESS57a5819a77579dfb1a1466ccceee22a0=0hr0aa2ogdfgkelogg</code> jokaiseen <code>helsinki.fi</code>-osoitteeseen. Eväste on voimassa tunnin, eli tunnin kuluttua se voi poistaa. Tarkempi syntaksi evästeen asettamiselle on seuraava:</p>

<pre>
Set-Cookie: nimi=arvo [; Comment=kommentti] [; Max-Age=elinaika sekunteina] 
                      [; Expires=parasta ennen paiva] [; Path=polku tai polunosa jossa eväste voimassa]
                      [; Domain=palvelimen osoite (URL) tai osoitteen osa jossa eväste voimassa]
                      [; Secure (jos määritelty, eväste lähetetään vain salatun yhteyden kanssa)]
                      [; Version=evästeen versio]
</pre>


                <p>Evästeet tallennetaan selaimen sisäiseen evästerekisteriin, josta niitä haetaan aina kun käyttäjä tekee kyselyn johonkin osoitteeseen. Evästeet lähetetään palvelimelle jokaisen viestin yhteydessä <code>Cookie</code>-otsakkeessa. </p>

<pre>
Cookie: SESS57a5819a77579dfb1a1466ccceee22a0=0hr0aa2ogdfgkelogg
</pre>

                <p>Evästeiden nimet ja arvot ovat yleensä monimutkaisia ja satunnaisesti luotuja niiden yksilöllisyyden takaamiseksi. Samaan osoitteeseen voi liittyä myös useampia evästeitä. Yleisesti ottaen evästeet ovat sekä hyödyllisiä että haitallisia: niiden avulla voidaan luoda yksiöityjä käyttökokemuksia tarjoavia sovelluksia, mutta niitä voidaan käyttää myös käyttäjien seurantaan ympäri verkkoa.</p> 

<div class="pohdi">
  <p><strong>Kekseliästä</strong></p>

  <p>Isossa osassa selaimia on valmiiksi web-sovelluskehityksessä hyödyntäviä apuvälineitä. Esimerkiksi uudemmat Google Chrome-selaimet tarjoavat hyödyllisen työvälineen sivustojen sisällön tarkasteluun. Painamalla F12 tai valitsemalla Tools -> Developer tools, pääset tutkimaan sivun lataamiseen ja sisältöön liittyvää statistiikkaa. Lisäneuvoja löytyy <a href="https://developers.google.com/chrome-developer-tools/docs/overview" target="_blank">Google Developers</a> -sivustolta.</p>

  <p>Avaa developer tools, ja mene osoitteeseen <a href="http://www.hs.fi" target="_blank">http://www.hs.fi</a>. Valitsemalla developer toolsien välilehden <code>Resources</code>, löydät valikon erilaisista sivuun liittyvistä resursseista. Avaa <code>Cookies</code> ja valitse vaihtoehto <code>www.hs.fi</code>. Kuinka moni palvelu pitää sinusta kirjaa kun menet Helsingin sanomien sivuille?</p>

</div>

                <h3>HTML</h3>

                <p><em>"In '93 to '94, every browser had its own flavor of HTML. So it was very difficult to know what you could put in a Web page and reliably have most of your readership see it."</em> -- Tim Berners-Lee</p>

                <p>HTML on rakenteellinen kuvauskieli, jolla voidaan esittää linkkejä sisältävää tekstiä sekä tekstin rakennetta. HTML koostuu elementeistä, jotka voivat olla sisäkkäin ja peräkkäin. Elementtejä käytetään ohjeina dokumentin jäsentämiseen ja käyttäjälle näyttämiseen. HTML-dokumenteissa elementit avataan elementin nimen sisältävällä pienempi kuin -merkillä (&lt;) alkavalla ja suurempi kuin -merkkiin (&gt) loppuvalla merkkijonolla (&lt;elementin_nimi&gt), ja suljetaan merkkijonolla jossa elementin pienempi kuin -merkin jälkeen on vinoviiva (&lt;/elementin_nimi&gt).</p>

                <p>HTML:ää voi ajatella myös puumaisena kielenä. Juurisolmuna on elementti <code>&lt;html&gt;</code>, jonka lapsina ovat elementit <code>&lt;head&gt;</code> ja <code>&lt;body&gt;</code>.</p>

                <p>Jos elementin sisällä ei ole muita elementtejä tai tekstisolmuja (tekstiä), voi elementin avata ja sulkea samalla merkkijonolla: (&lt;elementin_nimi /&gt;).</p> 

                <p>HTML:stä on useita erilaisia standardeja, joista viimeisin on HTML5, a.k.a. <a href="http://blog.whatwg.org/html-is-the-new-html5" target="_blank">HTML</a></p>

<pre class="sh_xml">
&lt;!DOCTYPE html&gt;
&lt;html lang="fi"&gt;
&lt;head&gt;
  &lt;meta charset="UTF-8"&gt;
  &lt;title&gt;selainikkunassa näkyvä otsikko&lt;/title&gt;
&lt;/head&gt;
&lt;body&gt;
  &lt;p&gt;Tekstiä tekstielementin sisällä, tekstielementti runkoelementin sisällä, 
     runkoelementti html-elementin sisällä. Elementin sisältö voidaan asettaa
     useammalle riville.&lt;/p&gt;
&lt;/body&gt;
&lt;/html&gt;
</pre>

                <p>Ylläoleva HTML5-dokumentti sisältää dokumentin tyypin ilmaisevan aloitustägin (<code>&lt;!DOCTYPE html&gt;</code>), dokumentin aloittavan html-elementin (<code>&lt;html&gt;</code>), otsake-elementin ja sivun otsikon (<code>&lt;head&gt;</code>, jonka sisällä <code>&lt;title&gt;</code>), sekä runkoelementin (<code>&lt;body&gt;</code>).</p>

                <p>Elementit voivat sisältää attribuutteja, joille voi antaa arvoja. Esimerkiksi ylläolevassa esimerkissä html-elementille on määritelty erillinen attribuutti <em>lang</em>, joka kertoo dokumentissa käytetystä kielestä.  Ylläolevan esimerkin otsakkeessa on myös metaelementti, jota käytetään lisävinkin antamiseen selaimelle: "dokumentissa käytetään utf-8 merkistöä". Tämä kannattaa olla dokumenteissa aina.</p>

                <p>Nykyaikaiset web-sivut sisältävät paljon muutakin kuin sarjan HTML-elementtejä. Linkitetyt resurssit, kuten kuvat ja tyylitiedostot, ovat oleellisia sivun ulkoasun ja rakenteen luomisessa. Selainpuolella suoritettavat skriptitiedostot, erityisesti Javascript, ovat luoneet huomattavan määrän syvyyttä nykyaikaiseen web-kokemukseen. Tällä kurssilla emme juurikaan paneudu selainpuolen toiminnallisuuteen, mutta sitä varten on tulossa erillinen kurssi <a href="http://www.cs.helsinki.fi/courses/582354" target="_blank">Web-selainohjelmointi</a>.</em>

                <h4>Lomakkeet</h4>
                
                <p>Lomakkeita käytetään tiedon lähettämiseen web-palveluille. HTML-elementti lomakkeelle on&lt;form&gt;. Lomake-elementille voidaan antaa attribuutteina toiminto (<code>action</code>), jolle voidaan määrittelee osoite mihin lomakkeen sisältö lähetetään, ja lomakkeen lähetystapa (<code>method</code>). Lomakkeen lähetystapa (<code>GET</code> tai <code>POST</code>) kertoo lähetetäänkö lomakkeen tiedon kyselyparametreina osana osoitetta (<code>GET</code>) vai pyynnön yhteydessä erillisenä datana (<code>POST</code>). Käytetään lähetystapaa <code>POST</code>.</p>

<pre class="sh_xml">
&lt;form action="kohdeosoite" method="POST"&gt;
</pre>

                <p>Jos attribuuttia <code>action</code> ei ole määritelty, lähetetään lomake oletuksena nykyiseen osoitteeseen. Attribuutin <code>method</code> oletusarvo on <code>GET</code>.</p>

                <p><strong>Lomakekentät</strong></p>
                
                <p>Lomake-elementin alle voi asettaa useita erilaisia kenttiä. Jos kentän arvon haluaa lähettää eteenpäin, tulee kentällä olla attribuutti nimi (<code>name</code>), jonka arvoa käytetään kenttään asetetun tiedon avaimena. </p>
<ul>

  <li>tekstikenttä: <br/><input type="text" name="kentan_nimi" />
<pre class="sh_xml">
&lt;input type="text" /&gt;
</pre></li>

  <li>salasanakenttä: <br/><input type="password" name="kentan_nimi" />
<pre class="sh_xml">
&lt;input type="password" /&gt;
</pre></li>

  <li>tekstialue: <br/><textarea name="tekstialue"></textarea><br/>Toisin kuin monet muut lomakkeen kenttäelementit, tekstialue tulee sulkea erillisellä elementillä. 
<pre class="sh_xml">
&lt;textarea name="tekstialue"&gt;&lt/textarea&gt;
</pre></li>

  <li>valintaruutu: <br/>
    <input type="checkbox" name="porkkanaa" /> Porkkanaa<br/>
    <input type="checkbox" name="naurista" /> Naurista<br/>
    <input type="checkbox" name="kaalia" /> Kaalia<br/>
    Selaimesta riippuen valintaruudun tiedot lähetetään lomakkeen mukana vain kentän ollessa valittuna. 
<pre class="sh_xml">
&lt;input type="checkbox" name="porkkanaa" /&gt; Porkkanaa &lt;br/&gt;
&lt;input type="checkbox" name="naurista" /&gt; Naurista &lt;br/&gt;
&lt;input type="checkbox" name="kaalia" /&gt; Kaalia &lt;br/&gt;
</pre>
</li>

  <li>valintanappi:<br/>
    <input type="radio" name="valinta" value="porkkanaa"/> Porkkanaa<br/>
    <input type="radio" name="valinta" value="naurista"/> Naurista<br/>
    <input type="radio" name="valinta" value="kaalia"/> Kaalia<br/>
    Valintanappia käytettäessä vain yksi saman name-attribuutin omistava radio-tyyppinen input-elementti voi olla valittuna. Lomaketta lähetettäessä valitun elementin attribuutin <code>value</code> arvo lähetetään <code>name</code> attribuutin arvona.
<pre class="sh_xml">
&lt;input type="radio" name="valinta" value="porkkanaa"/&gt; Porkkanaa&lt;br/&gt;
&lt;input type="radio" name="valinta" value="naurista"/&gt; Naurista&lt;br/&gt;
&lt;input type="radio" name="valinta" value="kaalia"/&gt; Kaalia&lt;br/&gt;
</pre></li>

  <li>lähetysnappi:<br/>
    <input type="submit" value="Lähetä" /><br/>
    Lähetysnappia painettaessa lomakkeen tiedot lähetetään kohdeosoitteeseen valitulla lähetystavalla.
<pre class="sh_xml">
&lt;input type="submit" value="Lähetä" /&gt;
</pre></li>

  </ul>
                <p><strong>Lomakkeen lähettäminen</strong></p>

                <p>Kun lomake lähetetään selain ohjaa käyttäjän kohdeosoitteeseen siten, että lähetettävän lomakkeen tiedot ovat mukana selaimen tekemässä pyynnössä. Jos lomakkeen lähetystapa on <code>GET</code>, on lomakkeen tiedot osana osoitetta. Lähetystavassa <code>POST</code> arvot tulevat erillisinä.</p>

                <p>Alla on lomake jolla voi visualisoida tietojen lähettämistä. Lomakkeiden toimintona on <a href="http://t-avihavai.users.cs.helsinki.fi/lets/See" target="_blank">http://t-avihavai.users.cs.helsinki.fi/lets/See</a>), jossa on pyynnössä saatujen tiedojen tulostava web-palvelu.</p>

<div class="naytto">
                <p>
                  <form method="POST" action="http://t-avihavai.users.cs.helsinki.fi/lets/See">
                    <label>Käyttäjätunnus: <input type="text" name="tunnus" /></label>
                    <label>Salasana: <input type="password" name="salasana" /></label>
                    <input type="submit" />
                  </form>
                </p>
</div>
                    
<pre class="sh_xml">
&lt;form method="POST" action="http://t-avihavai.users.cs.helsinki.fi/lets/See"&gt;
  &lt;label&gt;Käyttäjätunnus: &lt;input type="text" name="tunnus" /&gt;&lt;/label&gt;
  &lt;label&gt;Salasana: &lt;input type="password" name="salasana" /&gt;&lt;/label&gt;
  &lt;input type="submit" /&gt;
&lt;/form&gt;
</pre>

                <h4>Elementtien tunnistaminen</h4>

                <p>HTML-elementit muodostavat niinkutsutun DOM-puun, joka sisältää kaikki HTML-sivun elementit ja niiden ominaisuudet. Tämän kurssin puitteissa DOM-puu jää hyvin pieneen sivurooliin, ja tärkeintä omalta kannaltamme on seuraavat asiat:</p>


                <p>Lomakekentillä olevat nimi-attribuutit (name) ja niihin liittyvät arvot lähetetään lomakkeen attribuutin <code>action</code> määrittelemään osoitteeseen. GET-tyyppiset pyynnön lisäävät attribuutit osaksi osoitetta, POST-tyyppisissä pyynnöissä attribuutit kulkevat osana pyyntöä.</p>

                <p>Tutkitaan alla olevaa lomaketta:</p>

                    
<pre class="sh_xml">
&lt;form method="GET" action="http://t-avihavai.users.cs.helsinki.fi/lets/See"&gt;
  &lt;label&gt;Viesti &lt;input type="text" name="viesti" /&gt;&lt;/label&gt;
  &lt;input type="submit" /&gt;
&lt;/form&gt;
</pre>

                <p>Kun lomakkeessa painetaan submit-nappia, lomake lähetetään GET-tyyppisenä pyyntönä osoitteeseen <code>http://t-avihavai.users.cs.helsinki.fi/lets/See</code>. Lomakkeesta lähtevät tiedot liittyvät lomakkeen kenttiin. Yllä olevassa lomakkeessa on tasan yksi lomakekenttä: viesti. Kentät tunnistetaan lomaketta lähetettäessä niiden <code>name</code>-attribuutin mukaan. Koska lomakkeen lähetystyyppi on GET (<code>method="GET"</code>), liitetään lomakkeen kentät osaksi osoitetta.</p>

                <p>Esimerkiksi, jos lomakkeen viesti-kenttään kirjoitetaan teksti <code>Hei</code>, ja lomake lähetetään, kysely tehdään osoitteeseen <code>http://t-avihavai.users.cs.helsinki.fi/lets/See?viesti=Hei</code>. Huomaa että lomakkeen sisältämät tiedot on jo osana osoitetta.</p>

                <p>HTML-dokumentin muodostamaa puuta läpikäydessä elementit voidaan tunnistaa sekä niiden nimen, että niiden <em>tunnuksen</em> perusteella. Tunnus, eli <code>id</code>, on erillinen elementit yksilöivä attribuutti. Esimerkiksi ylläolevassa lomakkeessa olevaan viestikenttään voi liittää tunnuksen seuraavasti:</p>
                    
<pre class="sh_xml">
&lt;form method="GET" action="http://t-avihavai.users.cs.helsinki.fi/lets/See"&gt;
  &lt;label&gt;Viesti &lt;input type="text" name="viesti" id="viesti" /&gt;&lt;/label&gt;
  &lt;input type="submit" /&gt;
&lt;/form&gt;
</pre>

                <p>Nyt lomakkeessa oleva viestikenttä voidaan tunnistaa myös sen tunnuksen perusteella. Tunnusten käyttämisen tarve selkenee kurssilla <em>Web-selainohjelmointi</em>, nyt vain todetaan että niitä tarvitaan. Jos haluat lisää tietoa aiheeseen liittyen, <a href="http://www.w3schools.com/" target="_blank">W3Schools</a> tarjoaa hyvän pohjustuksen DOM-puiden <a href="http://www.w3schools.com/htmldom/default.asp" target="_blank">läpikäyntiin ja muokkaamiseen</a>.</p>


<div class="tehtavat">
  <h3>First Html Form</h3>
  
  <p>Tehtäväpohjassa tulee mukana web-projekti, jonka rakenne on seuraavanlainen:</p>
<pre>
$ tree
.
+-- pom.xml
+-- src
    +-- main
    ¦   +-- java
    ¦   ¦   +-- wad
    ¦   ¦       +-- ekalomake
    ¦   ¦           +-- servlet
    ¦   ¦               +-- RequestParametersServlet.java
    ¦   +-- resources
    ¦   +-- webapp
    ¦       +-- index.jsp
    ¦       +-- WEB-INF
    ¦           +-- web.xml
    +-- test
        +-- java
            +-- wad
                +-- ekalomake
                    +-- servlet
                        +-- RequestParametersServletTest.java

</pre>

  <p>Projektille on jo konfiguroitu osoite <code>/view</code> jota kuuntelee luokka <code>RequestParametersServlet</code>. Luokka tulostaa pyynnössä mukana tulevat parametrit käyttäjän näkyville.</p>
  
  <p>Tehtävänäsi on toteuttaa <code>webapp</code>-kansiossa (NetBeansin projektinäkymässä kansio <code>Web Pages</code>) olevaan <code>index.jsp</code>-sivuun seuraavannäköinen lomake:</p>
  
  <p><img src="img/teht-4-kuva.png" border=1/></p>
  
  <p>Lomakkeen Nimi-kentän <code>id</code> sekä <code>name</code> attribuuttien arvon tulee olla <code>name</code>. Osoite-kentällä <code>id</code> ja <code>name</code> attribuuttien arvon tulee olla <code>address</code>. Jokaisen lipputyypin nimi tulee olla <code>ticket</code>. Vihreää lippua kuvaavan valinnan id:n tulee olla <code>ticket-green</code> ja arvon <code>green</code>. Vastaavasti keltaista lippua kuvaavan valinnan id:n tulee olla <code>ticket-yellow</code> ja arvon <code>yellow</code>, ja punaista lippua kuvaavan valinnan id:n tulee olla <code>ticket-red</code> ja arvon <code>red</code>.</p>

  <p>Käytä lomakkeen action-attribuutin arvona merkkijonoa "${pageContext.request.contextPath}/view". Merkkijonon <code>${pageContext.request.contextPath}</code> merkitys selviää myöhemmin. Lomakkeen metodilla ei ole väliä tässä tehtävässä.</p>

  <p>Kun olet saanut lomakkeen valmiiksi, suorita siihen liittyvät testit. Kun testit menevät läpi, lähetä tehtävä TMC:lle.</p>

</div>

                
                <p></p>
               
<div class="extra">
  <p>NetBeans ei oletusasetuksillaan suostu käynnistämään web-palvelinta valittaessa <code>Run project</code>, jos projektiin liittyvät testit eivät mene läpi. Voit muuttaa projektin oletusasetuksia valitsemalla projektin nimen oikealla hiirennapilla -&gt; Properties -&gt; Actions. Valitse Action <code>Run project</code>, ja lisää sille ominaisuus <code>skipTests=true</code>. Tämän jälkeen palvelin käynnistyy vaikka testit eivät mene läpi.</p>

  <p><img src="img/skip-tests-on-run.png"/></p>
    
  <p>Voit myös käynnistää web-pohjaiset projektit komentoriviltä Jetty-palvelimen avulla. Komento <code>mvn jetty:start</code> käynnistää palvelimen projektin target-kansiossa olevilla tiedostoilla.</p>

</div>


                <h2>Hello Web!</h2>

                <p>Tutustutaan tässä osiossa web-sovellusten rakenteeseen, sekä yksinkertaisten web-sovellusten toteuttamiseen servleteillä. Osa kappaleessa olevista esimerkeistä on tarkoitettu sillaksi HTTPn ja palvelimilla toimivien ohjelmistojen välillä. Sovellukset, joita tässä kappaleessa tehdään ovat osittain kivikautisia ja edustavat vahvasti myös huonoa ohjelmointityyliä. Haukumme itseämme jo nyt.</p>

<!--
* hello world
* chat -> bugit -> tietoturva
  * XSS
//-->
                <h3>Servletit</h3>

                <p>Servletit ovat Javan teknologia dynaamisen palvelinpuolen web-toiminnallisuuden toteuttamiseen. Nimi Servlet tulee siitä, että servletit palvelevat (<em>serve</em>) käyttäjän tekemiä pyyntöjä: ne vastaanottavat pyyntöjä sekä myös vastaavat niihin. </p>

                <p>Käytännössä Servlettejä toteutettaessa ohjelmoija perii javan valmiin <a href="http://docs.oracle.com/javaee/6/api/javax/servlet/http/HttpServlet.html" target="_blank">HttpServlet</a>-luokan, ja korvaavat yhden tai useamman sen tarjoamista metodeista. Yläluokka HttpServlet tarjoaa metodeja yleisimpien HTTP-protokollan pyyntöjen käsittelyyn. Esimerkiksi metodilla <code>doGet</code> käsitellään GET-tyyppinen pyyntö, kun taas metodilla <code>doPost</code> käsitellään POST-tyyppinen pyyntö.</p>

                <p>Jokaisella pyyntöä käsittelevällä metodilla on parametrina kaksi rajapintaluokkaa: <a href="http://docs.oracle.com/javaee/6/api/javax/servlet/http/HttpServletRequest.html" target="_blank">HttpServletRequest</a> sisältää käyttäjän palvelimelle tekemän pyynnön tiedot ja <a href="http://docs.oracle.com/javaee/6/api/javax/servlet/http/HttpServletResponse.html" target="_blank">HttpServletResponse</a> sisältää käyttäjälle palvelimelta lähetettävän vastauksen. Rajapintaluokkien konkreettinen toteutus on käytettävän palvelimen toteuttajien vastuulla, Java tarjoaa vain rajapintamäärittelyt. Palvelinohjelmiston toteuttaja, <em>me</em>, taas käyttävät rajapintoja esimerkiksi pyynnön tietojen tarkasteluun ja vastauksen määrittelyyn.</p>

               <p>Palvelimella toimiva web-sovellus voi koostua yhdestä tai useammasta Servletistä. Muutamissa esimerkeissä esiintyvä <em>lets</em>-sovellus sijaitsee osoitteessa <a href="http://t-avihavai.users.cs.helsinki.fi/lets/" target="_blank">http://t-avihavai.users.cs.helsinki.fi/lets/</a>. Sovellukseen liittyy useampia Servlettejä, joista jokainen kuuntelee yhtä tai useampaa osoitetta. Esimerkiksi osoitteeseen <a href="http://t-avihavai.users.cs.helsinki.fi/lets/See" target="_blank">http://t-avihavai.users.cs.helsinki.fi/lets/See</a> on konfiguroitu Servlet, jonka tehtävänä on pyyntöön liittyvien otsakkeiden ja parametrien tulostaminen.</p>

               <p>Servlettien kuuntelemat polut konfiguroidaan Javan web-sovelluksiin liittyvässä web.xml-tiedostossa.</p>

               <p>Uudempi Servlet 3.0-spesifikaatio on osittain poistanut web.xml-tiedoston käytön servlettien konfiguroinnista: osa xml-tiedostoissa tapahtuvasta konfiguraatiosta on siirtynyt annotaatioden avulla tapahtuvaksi. Käytämme tällä kurssilla kuitenkin vielä hieman vanhempaa Servlet 2.5-spesifikaatiota: tausta-ajatuksena versiosta riippumatta on se, että servletit tulee kytkeä kuuntelemaan jotain osoitetta.</p> 

               <p>Luodaan seuraavaksi oma web-sovellus askeleittain, ja tutustutaan samalla web-sovellusten rakenteeseen.</p>

               <h3>Hello World!</h3>

               <p>Sovelluksemme tavoite on huikea: haluamme saada "Hello World!"-tekstin käyttäjälle näkyviin. Aloitetaan nollasta, eli projektin luomisesta.</p>

               <h4>Uusi maven-pohjainen web-sovellusprojekti</h4>

               <p>Vaikka voisimme käyttää mavenin archetype-pluginia web-sovellusprojektimme luomiseen, käytämme tässä NetBeansia. Kun NetBeansia käyttää projektien luomiseen, käyttää se käytännössä kuitenkin archetype-pluginia. NetBeansissa uuden projektin luominen aloitetaan valitsemalla File -> New Project.</p>

               <p><strong>Huom!</strong> Käytämme NetBeansin versiota 7.2, joka löytyy polusta <code>/opt/netbeans-7.2/</code>. NetBeansin voi käynnistää komentotulkista sanomalla:</p>

<pre>
$ /opt/netbeans-7.2/bin/netbeans
</pre>

               <p><img src="img/hello-world/new-project.png"/></p>

               <p>Tämä avaa wizard-ikkunan, jossa valitaan projektin tyyppi. Valitse kategoriasta Maven ja projektin tyypiksi Web Application.</p>

<p><img src="img/hello-world/maven-web-application.png"/></p>

               <p>Tämän jälkeen kysytään projektiin liittyviä perustietoja. Projektin nimeksi on asetettu <code>hello-world</code>, ja ryhmätunnukseksi <code>werkko</code>. Muita ei tarvitse vaihtaa. Voit toki päättää itse oman organisaatiosi (ryhmätunnuksesi) ja sovelluksen nimen (projektin nimen).</p>

<p><img src="img/hello-world/name-and-location.png"/></p>

               <p>Tämän jälkeen NetBeans kysyy käytettävää palvelinta ja Java EE-versiota. Laitoksella (pitäisi löytyä) löytyy valmiina GlassFish-palvelin. Voimme käyttää tätä. Valitse Java EE-versioksi 5.</p>

<p><img src="img/hello-world/javaee5-suggested-server.png"/></p>

               <p>Huh! Projekti luotu! Nyt voisimme lähteä luomaan projektiin liittyviä lähdekooditiedostoja.</p>

<p><img src="img/hello-world/project-created.png"/></p>

               <h4>Projektin rakenne</h4>

               <p>Mennään tarkastelemaan projektin rakennetta tarkemmin: komentorivi on tähän mainio työkalu. Projekti on tallennettu aiemmin projektin perustietoja kysyvässä ikkunassa määriteltyyn sijaintiin. Huomaathan että sijainti on projektikohtainen, eli projektisi <em>ei</em> ole kansiossa <code>/home/avihavai/repot/wad</code>. Kun menemme terminaalissa projektin kansioon ja kirjoitamme komennon <code>tree</code>, näemme kutakuinkin seuraavanlaisen listauksen.</p>

<pre>
.../hello-world$ tree
.
+-- pom.xml
+-- src
    +-- main
        +-- java
        ¦   +-- werkko
        ¦       +-- helloworld
        +-- webapp
            +-- index.jsp
            +-- WEB-INF
                +-- glassfish-web.xml
                +-- web.xml
</pre>

               <p>Projektirakenne vaikuttaa hyvin tutulta. Projektin juuressa on mavenin konfiguraatiotiedosto <code>pom.xml</code> ja projektin lähdekooditiedostot ovat <code>src</code>-kansion alla. Projektia luotaessa maven loi automaattisesti <code>src</code>-kansion alle kansion <code>java</code>, jonne tulee projektin lähdekooditiedostot. Projektiin liittyvät testitiedostot tulisi kansion <code>src</code> alle kansioon <code>test</code>. Tätä kansiota ei ole automaattisesti, mutta sen voi lisätä itse.</p>

               <p>Aiemmin tuntematon kansio on <code>src</code>-kansion alla oleva kansio <code>webapp</code>. Kansio <code>webapp</code> tulee sisältämään (lähes) kaikki projektin web-puoleen liittyvät tiedostot. Käydään ne seuraavaksi yksitellen läpi <code>web.xml</code>-tiedostosta lähtien.</p>

               <p><strong>web.xml</strong></p>

               <p>Tiedosto <code>web.xml</code> sijaitsee <code>webapp</code>-kansion sisällä olevassa <code>WEB-INF</code>-kansiossa. Se sisältää projektin konfiguraation palvelinta varten. Evästeitä (joskus tunnetaan myös nimellä keksit) käyttävien istuntojen kesto määritellään <code>session-config</code> -elementin sisällä olevalla <code>session-timeout</code>-elementillä: jos käyttäjä on yli 30 minuuttia käyttämättä sovellusta, istunnot vanhenevat automaattisesti. Sovellukseen selaimella päätyvälle käyttäjälle ensisijaisesti näytettävä sivu taas määritellään <code>welcome-file-list</code>-elementin sisällä määritellyllä <code>welcome-file</code>-elementillä: kun käyttäjä selaa sovelluksen juuripolkuun (esimerkiksi aiemmassa esimerkissä ollut <code>/lets/</code>), käyttäjälle näytetään tiedosto <code>index.jsp</code>.</p>

<pre class="sh_xml">
&lt;?xml version="1.0" encoding="UTF-8"?&gt;
&lt;web-app version="2.5" xmlns="http://java.sun.com/xml/ns/javaee" 
         xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" 
         xsi:schemaLocation="http://java.sun.com/xml/ns/javaee 
                             http://java.sun.com/xml/ns/javaee/web-app_2_5.xsd"&gt;
    &lt;!-- sovelluksen nimi //--&gt;
    &lt;display-name&gt;hello-world&lt;/display-name&gt;

    &lt;!-- istunnon maksimipituus //--&gt;
    &lt;session-config&gt;
        &lt;session-timeout&gt;
            30
        &lt;/session-timeout&gt;
    &lt;/session-config&gt;

    &lt;!-- oletuksena näytettävä sivu //--&gt;
    &lt;welcome-file-list&gt;
        &lt;welcome-file&gt;index.jsp&lt;/welcome-file&gt;
    &lt;/welcome-file-list&gt;
&lt;/web-app&gt;
</pre>


               <p><strong>glassfish.xml</strong></p>

               <p>Tiedosto <code>glassfish.xml</code> ei liity yleisesti web-sovelluksiin, vaan se on NetBeansin luoma lisätiedosto sillä valitsimme aiemmin GlassFish-palvelimen. Tämä tiedosto sisältää GlassFish-palvelimeen liittyviä konfiguraatioita. Omasta näkökulmastamme se ei ole mielenkiintoinen.</p>

               <p><strong>kansio WEB-INF</strong></p>

               <p>Kansiossa <code>WEB-INF</code> oleviin tiedostoihin ei pääse sovelluksen päällä ollessa käsiksi selaimen kautta. Se sisältää projektiin liittyviä konfiguraatiotiedostoja sekä esimerkiksi JSP-sivuja, joita ei haluta näyttää käyttäjälle suoraan.</p>

               <p><strong>index.jsp</strong></p>

               <p>Kansiossa <code>webapp</code> oleva tiedosto <code>index.jsp</code> sisältää käyttäjälle näytettävän sivun. JSP-sivut ovat kuin HTML-sivuja, mutta niihin voi lisätä dynaamista toiminnallisuutta. NetBeans generoi JSP-sivuille valmiin pohjan, joka näyttää seuraavalta:</p>

<pre class="sh_xml">
<%@page contentType="text/html" pageEncoding="UTF-8"%>
&lt;!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN"
   "http://www.w3.org/TR/html4/loose.dtd"&gt;

&lt;html&gt;
    &lt;head&gt;
        &lt;meta http-equiv="Content-Type" content="text/html; charset=UTF-8"&gt;
        &lt;title&gt;JSP Page&lt;/title&gt;
    &lt;/head&gt;
    &lt;body&gt;
        &lt;h1&gt;Hello World!&lt;/h1&gt;
    &lt;/body&gt;
&lt;/html&gt;
</pre>

               <p>Sivulle on määritelty alkuun erillinen JSP-tägi, joka kertoo sivun sisällön olevan tyyppiä text/html, ja merkistön olevan UTF-8 -muotoista. NetBeans luo oletuksena HTML 4.01 -versioisia sivuja, mutta sivun rakennetta voi toki itse myös muuttaa. Selaimessa sivu näyttää otsikon <code>JSP Page</code> ja tekstin <code>Hello World!</code>. Esimerkki palvelimella olevasta sivusta löytyy osoitteesta <a href="http://t-avihavai.users.cs.helsinki.fi/lets/" target="_blank">http://t-avihavai.users.cs.helsinki.fi/lets/</a>. Huomaa että selaimella sivua katsottaessa palvelin on ennen sivun lähettämistä käyttäjälle suorittanut alussa olleet komennot, ja niitä ei näy sivun lähdekoodia selaimesta katsottaessa. </p>


               <h4>HelloServlet</h4>

               <p>Koska <code>index.jsp</code>-sivussa lukee teksti <code>Hello World!</code>, sovelluksemme näyttäisi nyt jo käyttäjälle tekstin <code>Hello World!</code>. Haluamme kuitenkin luoda oman Servletin, joka tulostaa tekstin käyttäjälle. Luodaan HttpServlet-luokan perivä <code>HelloServlet</code>-luokka, joka kuuntelee osoitetta <code>/hello</code>.</p>

               <p>Osoitteet, joita servletit kuuntelevat riippuvat aina osoitteesta, jossa servletin sisältämä sovellus toimii. Jos sovellus on osoitteessa <code>http://www.werkko.com/app/</code> ja sovelluksella on polkua <code>/hello</code> kuunteleva servlet, pääsisi servlettiin osoitteessa <code>http://www.werkko.com/app/hello</code>.</p>

               <p>Koska olemme fiksuhkoja, käytämme ohjelmistokehitysympäristöämme servlet-luokan luomiseen. Valitaan projektin nimi oikealla hiirennäppäimellä ja valitaan New -> Servlet. Jos Servlet-vaihtoehtoa ei ole olemassa, se löytyy Other... -vaihtoehdon avaamalla työkalulla.</p>

<p><img src="img/hello-world/new-servlet.png"/></p>

               <p>Eteen aukeaa New Servlet-työkalu. Täytetään Servlet-luokan nimeksi HelloServlet, ja valitaan Servletille sopiva pakkaus (sovelluksia ei pitäisi tehdä juureen...).</p>

<p><img src="img/hello-world/hello-servlet.png"/></p>

               <p>NetBeans haluaa myös auttaa <code>web.xml</code>-tiedoston konfiguroinnissa ja kysyy mitä osoitetta juuri luotavan Servlet-luokan tulisi kuunnella. Asetetaan poluksi <code>/hello</code>.</p>

<p><img src="img/hello-world/deployment-config.png"/></p>

               <p>Eteesi aukeaa Servlet-luokan lähdekoodi, jota voit lähteä muokkaamaan.</p>

<p><img src="img/hello-world/servlet-created.png"/></p>

               <p>Tarkastellaan vielä tarkemmin juuri tapahtuneita muutoksia projektissa.</p>

               <p><strong>web.xml</strong></p>

               <p>NetBeans lisäsi <code>web.xml</code>-tiedostoon tiedot servletistä ja sen kuuntelemasta polusta. Nyt tiedosto näyttää seuraavalta:</p>

<pre class="sh_xml">
&lt;?xml version="1.0" encoding="UTF-8"?&gt;
&lt;web-app version="2.5" xmlns="http://java.sun.com/xml/ns/javaee" 
                       xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" 
                       xsi:schemaLocation="http://java.sun.com/xml/ns/javaee                               
                                           http://java.sun.com/xml/ns/javaee/web-app_2_5.xsd"&gt;
    &lt;!-- sovelluksen nimi //--&gt;
    &lt;display-name&gt;hello-world&lt;/display-name&gt;

    &lt;!-- esitellään servlet //--&gt;
    &lt;servlet&gt;
        &lt;servlet-name&gt;HelloServlet&lt;/servlet-name&gt;
        &lt;servlet-class&gt;werkko.helloworld.HelloServlet&lt;/servlet-class&gt;
    &lt;/servlet&gt;

    &lt;!-- kerrotaan mihin osoitteeseen tulevat pyynnöt ohjataan servletille //--&gt;
    &lt;servlet-mapping&gt;
        &lt;servlet-name&gt;HelloServlet&lt;/servlet-name&gt;
        &lt;url-pattern&gt;/hello&lt;/url-pattern&gt;
    &lt;/servlet-mapping&gt;

    &lt;!-- istunnon maksimipituus //--&gt;
    &lt;session-config&gt;
        &lt;session-timeout&gt;
            30
        &lt;/session-timeout&gt;
    &lt;/session-config&gt;

    &lt;!-- oletuksena näytettävä sivu //--&gt;
    &lt;welcome-file-list&gt;
        &lt;welcome-file&gt;index.jsp&lt;/welcome-file&gt;
    &lt;/welcome-file-list&gt;
&lt;/web-app&gt;
</pre>

               <p>Uutena on keskellä olevat elementit. Elementissä <code>servlet</code> esitellään Servlet-luokka, ja asetetaan sille nimi johon muualla konfiguraatiossa voidaan viitata. Elementissä <code>servlet-mapping</code> taas asetetaan tietyn nimiselle <em>HelloServlet</em> luokalle osoite, jota se kuuntelee. Juuri luotu servlettimme kuuntelee siis sovelluksen polkua <code>/hello</code>.</p>

               <p><strong>HelloServlet</strong></p>

               <p>Luokka <code>HelloServlet</code> perii Javan valmiin luokan <code>HttpServlet</code> ja sisältää HTTP-pyyntöjen käsittelyn. NetBeansin luoma luokka sisältää apumetodin <code>processRequest</code>, johon POST ja GET-tyyppiset pyynnöt ohjataan. Koko luokan sisältö näyttää seuraavalta (huomattava osa NetBeansin luomista kommenteista poistettu).</p>

<pre class="sh_java">
// pakkaus
package werkko.helloworld;

// tarvittavat importit
import java.io.IOException;
import java.io.PrintWriter;
import javax.servlet.ServletException;
import javax.servlet.http.HttpServlet;
import javax.servlet.http.HttpServletRequest;
import javax.servlet.http.HttpServletResponse;

// peritään luokka HttpServlet
public class HelloServlet extends HttpServlet {
    
    // metodi pyyntöjen käsittelyyn
    // <strong>ei näin sitten oikeasti!</strong>
    protected void processRequest(HttpServletRequest request, HttpServletResponse response)
            throws ServletException, IOException {
        response.setContentType("text/html;charset=UTF-8");
        PrintWriter out = response.getWriter();
        try {
            /* TODO output your page here. You may use following sample code. */
            out.println("&lt;html&gt;");
            out.println("&lt;head&gt;");
            out.println("&lt;title&gt;Servlet HelloServlet&lt;/title&gt;");            
            out.println("&lt;/head&gt;");
            out.println("&lt;body&gt;");
            out.println("&lt;h1&gt;Servlet HelloServlet at " + request.getContextPath() + "&lt;/h1&gt;");
            out.println("&lt;/body&gt;");
            out.println("&lt;/html&gt;");
        } finally {            
            out.close();
        }
    }

    // korvattu metodi doGet, pyyntö ohjataan processRequest-metodille
    @Override
    protected void doGet(HttpServletRequest request, HttpServletResponse response)
            throws ServletException, IOException {
        processRequest(request, response);
    }

    // korvattu metodi doPost, pyyntö ohjataan processRequest-metodille
    @Override
    protected void doPost(HttpServletRequest request, HttpServletResponse response)
            throws ServletException, IOException {
        processRequest(request, response);
    }
}
</pre>


               <p>Oleellista yllä on metodi <code>processRequest</code>, jota sekä metodit <code>doGet</code> ja <code>doPost</code> kutsuvat. Metodia <code>processRequest</code> ei ole tietenkään pakko käyttää: pyynnön prosessoinnin voi hoitaa myös metodeissa <code>doGet</code> ja <code>doPost</code>.</p>

               <p>Metodi <code>processRequest</code> asettaa ensin vastauksen sisällön tyypiksi html:n, ja merkistöksi UTF-8:n.</p>

<pre class="sh_java">
        response.setContentType("text/html;charset=UTF-8");
</pre>

               <p>Tämän jälkeen avataan kirjoitusväylä vastausta varten, ja kirjoitetaan HTML-sisältö vastaukseen. Vaikka tulostamme vielä tällä viikolla HTMLää suoraan Servletistä, älä käytä tätä enää seuraavalla viikolla.</p>

<pre class="sh_java">
        PrintWriter out = response.getWriter();
        try {
            /* TODO output your page here. You may use following sample code. */
            out.println("&lt;html&gt;");
            out.println("&lt;head&gt;");
            out.println("&lt;title&gt;Servlet HelloServlet&lt;/title&gt;");            
            out.println("&lt;/head&gt;");
            out.println("&lt;body&gt;");
            out.println("&lt;h1&gt;Servlet HelloServlet at " + request.getContextPath() + "&lt;/h1&gt;");
            out.println("&lt;/body&gt;");
            out.println("&lt;/html&gt;");
        } finally {            
            out.close();
        }
</pre>

                <h4>Hello World!</h4>

                <p>Muutetaan <code>processRequest</code>-metodia siten, että se tulostaa tekstin <code>Hello World!</code>.</p>

<pre class="sh_java">
    // metodi pyyntöjen käsittelyyn
    protected void processRequest(HttpServletRequest request, HttpServletResponse response)
            throws ServletException, IOException {
        response.setContentType("text/html;charset=UTF-8");
        PrintWriter out = response.getWriter();
        try {
            out.println("&lt;html&gt;");
            out.println("&lt;head&gt;");
            out.println("&lt;title&gt;&lt;/title&gt;");            
            out.println("&lt;/head&gt;");
            out.println("&lt;body&gt;");
            out.println("&lt;h1&gt;Hello World!&lt;/h1&gt;");
            out.println("&lt;/body&gt;");
            out.println("&lt;/html&gt;");
        } finally {            
            out.close();
        }
    }
</pre>
 
                <p>Nyt sovelluksemme <code>/hello</code>-osoitetta kuunteleva Servlet tulostaa käyttäjälle viestin <code>Hello World!</code>.</p>

                <h4>Sovelluksen testaaminen</h4>

                <p>Sovellusta voi testata suoraan NetBeansissa valitsemalla oikealla hiirennäppäimellä projektin nimi ja klikkaamalla Run. Tämä käynnistää aiemmin määritellyn palvelimen (tässä GlassFish), ja lisää sovelluksen palvelimelle. Kun palvelin on päällä, NetBeans käynnistää oletuksena myös selaimen sovelluksen katseluun. Huomaa että selaimessa näytetään sovellus, Servlettiä testataksesi sinun tulee lisätä servletin kuuntelema osoite selaimella haettavaan polkuun.</p>

                <p>Esimerkiksi, jos sovellus aukeaa osoitteessa <code>http://localhost:8080/hello-world/</code>, olisi HelloServlet osoitteessa <code>http://localhost:8080/hello-world/hello</code>.</p>


<div class="extra">
<p>Ylläoleva esimerkki kannattaa tehdä myös itse.</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
</div>

                <h4>Sovelluksen paketointi ja tuotantoon siirtäminen</h4>

                <p>Maven tarjoaa toiminnot tiedoston paketointiin. Kun kirjoitamme komentoriviltä projektikansiossa komennon <code>mvn package</code>, maven luo projektista <code>.war</code>-tiedoston, jonka voi siirtää tuotantopalvelimelle.</p>

<pre>
.../hello-world$ mvn package
...
[INFO] [war:war {execution: default-war}]
[INFO] Packaging webapp
[INFO] Assembling webapp [hello-world] in [....]
...
[INFO] Webapp assembled in [69 msecs]
[INFO] Building war: /.../hello-world/target/hello-world-1.0-SNAPSHOT.war
...
</pre>

                <p>Luodun war-tiedoston voi kopioida esimerkiksi TKTL:n users-palvelimelle, jossa sitä voi ajaa tomcat-palvelimella. Jos sinulla ei ole tunnuksia TKTL:lle älä huoli, tutustumme myöhemmin kurssilla sovellusten siirtämiseen pilvialustoille.</p>

                <p>Kone <code>users.cs.helsinki.fi</code> on TKTL:n opiskelijoille tarkoitettu palvelin, jossa voi ajaa omia ohjelmistoja. Users-koneella on käytössä java web-sovelluksia pyörittävä tomcat-palvelin sekä useita tietokannanhallintajärjestelmiä: MySQL, Oracle ja PostgreSQL. Users-koneelle pääsee kirjautumaan komennolla.</p>

<pre>
ssh users.cs.helsinki.fi -l &lt;omatunnus&gt;
</pre>

                <p>Saamme käyttöömme tomcat-palvelimen komennolla <code>wanna-tomcat</code>. Laitoksella on käytössä tomcatin versio 6.</p>

<pre>
tunnus@users:~$ wanna-tomcat

This script will create a new tomcat environment for you in directory
/home/tunnus/tomcat. Please see http://users.cs.helsinki.fi/tomcat for more
information. Do you want to create a new tomcat installation
in /home/tunnus/tomcat (y/n)? &lt;syötä y&gt;

....

Tomcat environment has been setup for you. Now you can run 'start-tomcat'.
tunnus@users:~$
</pre>

                <p>Käynnistetään palvelin komennolla <code>start-tomcat</code>.</p>
<pre>
tunnus@users:~$ start-tomcat
Using CATALINA_BASE:   /home/tunnus/tomcat
Using CATALINA_HOME:   /usr/share/tomcat6
Using CATALINA_TMPDIR: /home/tunnus/tomcat/temp
Using JRE_HOME:        /usr/lib/jvm/java-6-sun
Using CLASSPATH:       /usr/share/tomcat6/bin/bootstrap.jar
Tomcat has been started. It should be visible through URL
http://t-omatunnus.users.cs.helsinki.fi/

If you have problems, your tomcat log files are
available from /home/tunnus/tomcat/logs

Please, remember to stop (with stop-tomcat) tomcat instances with are
not used.
tunnus@users:~$ 
</pre>

                <p>Kun menet web-selaimella osoitteeseen http://t-omatunnus.users.cs.helsinki.fi/, näet sivun jossa on otsikkona viesti "It works!".</p>

                <p>Tomcat-palvelimen saa suljettua komennolla <code>stop-tomcat</code>.</p>

                <p><strong>Sovelluksen siirto users-koneelle.</strong></p>

                <p>Kopioidaan paketti users-koneelle.</p>
<pre>
tunnus@kone:~$ scp polku-projektiin/target/projektinnimi.war omatunnus@users.cs.helsinki.fi:
</pre>
                <p>Mennään koneelle <code>users.cs.helsinki.fi</code>, ja siirretään pakkaus tomcat-kansiossa olevaan webapps-kansioon.</p>
<pre>
tunnus@kone:~$ ssh omatunnus@users.cs.helsinki.fi
tunnus@users:~$ mv &lt;projektinnimi&gt;.war tomcat/webapps/
tunnus@users:~$
</pre>

                <p>Jos tomcat on päällä, pyrkii se käynnistämään sovelluksen automaattisesti.  Näet tomcatin logeista <code>tomcat/logs/catalina.out</code> ohjelman logiin kirjoittamat viestit. Jos tomcat ei ole päällä, käynnistä se, ja selaa osoitteeseen <code>http://t-omatunnus.users.cs.helsinki.fi/&lt;projektinnimi&gt;/hello</code>.</p> 

                <p>Osoitteessa olevan palvelinohjelmiston pitäisi tulostaa HelloServlet-servletissä määritelty viesti.</p>

                <h3>Servlettien käynnistäminen ja elinkaari</h3>

                <p>Jos tiedostossa <code>web.xml</code> olevassa servletmäärittelyssä on määre <code>load-on-startup</code>, ja sen arvo on suurempi tai yhtäsuuri kuin 0, Servlet-luokasta ladataan ilmentymä palvelimelle heti web-sovelluksen käynnistyessä.</p>

<pre class="sh_xml">
...
    &lt;!-- esitellään servlet //--&gt;
    &lt;servlet&gt;
        &lt;servlet-name&gt;HelloServlet&lt;/servlet-name&gt;
        &lt;servlet-class&gt;werkko.helloworld.HelloServlet&lt;/servlet-class&gt;
        &lt;load-on-startup&gt;1&lt;/load-on-startup&gt;
    &lt;/servlet&gt;
...
</pre>

                <p>Muulloin servlet käynnistyy palvelimesta riippuen, usein esimerkiksi silloin kun Servletille määriteltyyn polkuun tehdään ensimmäinen pyyntö. Määre <code>load-on-startup</code> on hyödyllinen esimerkiksi silloin, jos sovelluksen tulee tehdä käynnistyessään esimerkiksi tietokantaoperaatioita. Käynnistyksen yhteydessä suoritettavien toimintojen määrittely onnistuu <code>HttpServlet</code>-luokasta perittävän <code>init</code>-metodin avulla.</p>

                <p>Jos Servlettejä on useampia, ja niiden käynnistysjärjestyksellä on merkitystä, määrettä <code>load-on-startup</code> voi käyttää suoritusjärjestyksen määrittelyyn. Servletit käynnistetään <code>load-on-startup</code>-elementin arvojen määräämässä suoritusjärjestyksessä pienimmästä suurimpaan.</p>

                <p>Jokaisesta Servlet-luokasta tehdään vain yksi ilmentymä. Samaa ilmentymää käytetään jokaisen Servletille tehdyn pyynnön käsittelyyn. Servlet-luokan oliomuuttujat ovat siis käytettävissä jokaisen pyynnön yhteydessä.</p>

<div class="extra">
  <p>Jos NetBeansissa ei ole oletuspalvelinta sovelluksen testaamiseen, voit valita käyttöön esimerkiksi GlassFish -palvelimen. Huomaamme myöhemmin miten web-sovellukset voi käynnistää myös komentoriviltä esimerkiksi <code>jetty</code>-palvelimen avulla.</p>

  <p>Kun käynnistät sovelluksen NetBeansissa, se avaa sovelluksen oletusselaimessa. Oletusselaimen voi vaihtaa NetBeansin asetuksista: Tools -&gt; Options -&gt; General -&gt; Web browser</p>
</div>

<div class="tehtavat">
<h3>PageViewCounter</h3>

<p>Luo pakkaukseen <code>wad.pageviews.servlet</code> luokka PageViewCounterServlet, joka perii luokan HttpServlet. Luokan PageViewCounterServlet tulee pitää kirjaa tehdyistä GET-tyyppisistä pyynnöistä, ja tulostaa tehtyjen pyyntöjen määrä käyttäjälle. Aseta Servlet kuuntelemaan sovelluksen polkua <code>/count</code>.</p>

<p>Käyttäjälle näytettävä tulostus voi olla esimerkiksi seuraavanlainen. Alla pyyntöjä on tehty yhteensä 3.</p>

<div class="naytto">
  <p>Pyyntöjä: 3</p>
</div>

<p>Kun olet saanut tehtävän valmiiksi, suorita siihen liittyvät testit ja lähetä se TMCn tarkastettavaksi.</p> 

</div>



                <h3>Erota käyttöliittymä ja sovelluslogiikka!</h3>

                <p>Yksi klassisimmista neuvoista ohjelmia rakentaessa on <em>"erota sovelluslogiikka ja käyttöliittymä"</em>. Aiemmassa Hello World!- esimerkissämme näin ei ole tehty, vaan käyttöliittymä on osa sovelluslogiikkaa. <strong>Ei näin!</strong></p>

                <p>Sovelluslogiikan ja käyttöliittymän erottaminen on hyvin tärkeää ohjelmistotuotannon kannalta: isompia sovelluksia rakennettaessa useamman ihmisen tulee pystyä muokkaamaan sen eri osia samanaikaisesti. Jos kaikki on samassa tiedostossa, tiedoston luettavuus kärsii huomattavasti ja muokkaukset aiheuttavat lähes taatusti versionhallintakonflikteja. Sovelluksen eri osien testaaminen vaikeutuu myös huomattavasti, jos sovelluksen eri osia ei ole erotettu.</p>

                <p>Paljon käytetty tapa käyttöliittymäkoodin ja sovelluskoodin erottamiseksi on luoda jokaiselle näkymälle oma sivu, johon Servlet-luokka pyynnön lopulta ohjaa. JSP-sivut luodaan <code>WEB-INF</code>-kansion sisälle omaan kansioon, jotta sivuihin ei pääse käsiksi suoraan selaimella. Tällä kurssilla jsp-sivut sisältävän kansion nimi on <code>jsp</code>.</p>

                <p>Jatketaan Hello World! -esimerkin muokkaamista ja luodaan kansioon <code>WEB-INF</code> kansio <code>jsp</code>. Tämä onnistuu NetBeansissa klikkaamalla kansiota WEB-INF oikealla hiirennäppäimellä, ja valitsemalla New -> Other -> Other -> Folder. Kansioon <code>jsp</code> lisätään <code>hello.jsp</code>-niminen jsp-sivu, jonka sisältö on seuraava:</p>

<pre class="sh_xml">
&lt;%@page contentType="text/html" pageEncoding="UTF-8"%&gt;
&lt;!DOCTYPE html&gt;
&lt;html&gt;
    &lt;head&gt;
        &lt;meta http-equiv="Content-Type" content="text/html; charset=UTF-8"&gt;
        &lt;title&gt;Hello World!&lt;/title&gt;
    &lt;/head&gt;
    &lt;body&gt;
        &lt;h1&gt;Hello World!&lt;/h1&gt;
    &lt;/body&gt;
&lt;/html&gt;
</pre>

                <p>Kun projektin rakennetta katsoo komentoriviltä <code>tree</code>-komennolla, näyttää se nyt seuraavalta.</p>

<pre>
... /hello-world$ tree
.
+-- pom.xml
+-- src
    +-- main
        +-- java
        ¦   +-- werkko
        ¦       +-- helloworld
        ¦           +-- HelloServlet.java
        +-- webapp
            +-- index.jsp
            +-- WEB-INF
                +-- glassfish-web.xml
                +-- jsp
                ¦   +-- hello.jsp
                +-- web.xml
</pre>

                <p><strong>Pyynnön ohjaaminen JSP-sivulle</strong></p>

                <p>Pyynnön ohjaaminen JSP-sivulle tapahtuu HttpServletRequest-rajapinnan tarjoaman RequestDispatcher-olion metodilla <code>forward</code>. Kun <code>HttpServletRequest</code>-rajapinnan toteuttavalta oliolta pyydetään RequestDispatcher-oliota metodilla <code>getRequestDispatcher</code>, sille annetaan käytettävän jsp-sivun sijainti. Lopullisessa war-tiedostossa, eli tiedostossa, joka sisältää web-sovelluksen, WEB-INF-kansio on juuressa. Käytämme siis <code>hello.jsp</code>:tä varten polkua <code>/WEB-INF/jsp/hello.jsp</code>.</p>

<pre class="sh_java">
        RequestDispatcher dispatcher = request.getRequestDispatcher("/WEB-INF/jsp/hello.jsp");
        dispatcher.forward(request, response);
    
        // tai request.getRequestDispatcher("/WEB-INF/jsp/hello.jsp").forward(request, response);
</pre>
                

                <p>Muokkaa Servlet-luokkaasi siten, että metodi <code>processRequest</code> näyttää seuraavalta</p>

<pre class="sh_java">
    protected void processRequest(HttpServletRequest request, HttpServletResponse response)
            throws ServletException, IOException {
        response.setContentType("text/html;charset=UTF-8");
        
        request.getRequestDispatcher("/WEB-INF/jsp/hello.jsp").forward(request, response);
    }
</pre>

                <p>Nyt Servletin kuuntelemaan osoitteeseen tuleva pyyntö ohjautuu lopulta kansiossa <code>/WEB-INF/jsp/</code> olevaan tiedostoon <code>hello.jsp</code>.</p>

                <p>Käytännössä siis pyyntö tapahtuu seuraavasti:</p>


<pre>

1. Käyttäjä tekee palvelimelle pyynnön

  käyttäjän selaimella tekemä pyyntö
     ----------------------->            palvelin


2. Palvelin päättelee pyynnön perusteella oikean servletin
   
  palvelin: pyynnön polku?
     ----------------->                   servlet

3. Servletin koodi suoritetaan

4. Vaihtoehtoinen tilanne: 

4a) Jos requestdispatcher-olion avulla ei määritellä seuraavaa 
    kohdetta, vastaus palautetaan käyttäjälle

4b) Muuten, pyyntö ohjataan määritellyyn osoitteeseen, esimerkiksi
    toiselle servletille. Servletin tai JSPn sisältämät komennot prosessoidaan
     palvelimella. Lopulta vastaus lähetetään takaisin käyttäjälle

</pre>

                <h3>Ensiaskeleet dynaamisen tiedon lisäämiseen</h3>

                <p>Tällä hetkellä sovelluksemme on hieman kankea: sovellus ei näytä mitään palvelinpuolella luotua tietoa.</p>

                <p>Selaimelta tulevaa pyyntöä edustavaan <code>HttpServletRequest</code>-olioon voi lisätä attribuutteja, jotka ovat pyynnössä mukana siihen asti kunnes palautettava sivu lähetetään takaisin selaimelle. Kun ohjaamme Servlet-luokassa pyynnön eteenpäin, on kaikki pyyntöön Servlet-luokassa lisätyt attribuutit olemassa vielä JSP-sivua näytettäessä.</p>
                
                <p>JSP-sivu on tarkoitettu dynaamisen tiedon näyttämiseen. JSP:n versioon 2.0 otetun EL-kielen avulla sivulla voidaan käyttää käytännössä kaikkia <code>HttpServletRequest</code> oliolle attribuutiksi lisättyjä olioita. Lisätään seuraavaksi pyyntöön attribuutti "message", jonka sisältö on "ok, ehkä tässä on ideaa".</p>

<pre class="sh_java">
    protected void processRequest(HttpServletRequest request, HttpServletResponse response)
            throws ServletException, IOException {
        response.setContentType("text/html;charset=UTF-8");

        request.setAttribute("message", "ok, ehkä tässä on ideaa");
        
        request.getRequestDispatcher("/WEB-INF/jsp/hello.jsp").forward(request, response);
    }
</pre>

                <p>Nyt jsp-sivua renderöitäessä käytössä on attribuutti nimeltä message, jolla on arvo. EL-kielen avulla pyyntöön lisätyn attribuutin arvon voi näyttää sivulla seuraavasti:</p>

<pre class="sh_xml">
&lt;%@page contentType="text/html" pageEncoding="UTF-8"%&gt;
&lt;!DOCTYPE html&gt;
&lt;html&gt;
    &lt;head&gt;
        &lt;meta http-equiv="Content-Type" content="text/html; charset=UTF-8"&gt;
        &lt;title&gt;Hello World!&lt;/title&gt;
    &lt;/head&gt;
    &lt;body&gt;
        &lt;h1&gt;Hello World!&lt;/h1&gt;

        &lt;p&gt;Viesti: ${message}&lt;/p&gt;
    &lt;/body&gt;
&lt;/html&gt;
</pre>

                <p>Kun ylläolevaa JSP-sivua renderöidään käyttäjälle, sivun renderöijä etsii <code>message</code>-nimisen attribuutin ja asettaa sen sisällön sivulle. Attribuutti aloitetaan JSP-sivulla dollarilla ja aukeavalla aaltosululla <code>${</code>, ja lopetetaan sulkevalla aaltosululla <code>}</code>.

                <p>Servletin osoitteeseen tehtävä pyyntöön luotava vastaus näyttää selaimessa seuraavalta:</p>

<div class="naytto">
        <h1>Hello World!</h1>
        
        <p>Viesti: ok, ehkä tässä on ideaa</p>
</div>

                <h3>Sovelluksen sijainti</h3>

                <p>Sovelluksemme sijainti palvelimella riippuu palvelimesta ja sovellukselle määritellystä konfiguraatiosta. Sovellukset ovat harvemmin palvelimen juuriosoitteessa, esim. <code>http://palvelin.net/</code>. Yleensä niille on oma aliosoite, esimerkiksi <code>http://palvelin.net/sovellus</code>. Tämä johtaa tilanteeseen, jossa sivulla käytettävien linkkien tulee olla dynaamisia. Esimerkiksi lomakkeiden lähettämisen tulee tapahtua sovellukselle.</p>

                <p>Jos HTML-lomakkeen action-kenttä sisältää osoitteen <code>/process</code>, lomake lähetetään käytettävän palvelimen juuriosoitteeseen. Esimerkiksi jos lomake on palvelimella <code>http://palvelin.net/</code>, lähetettäisiin <code>/process</code>-osoitteeseen ohjautuva lomake käytännössä osoitteeseen <code>http://palvelin.net/process</code> -- riippumatta siitä, missä sovellus oikeasti on.</p>

                <p>Tämän takia EL-kielessä pääsee käsiksi myös pyynnön tietoihin. Käyttämällä komentoa <code>${pageContext.request.contextPath}</code> jsp-sivulla, sovelluksen osoitteen saa käyttöön. Käytännössä jos lomakkeen action-kentälle antaa arvon <code>${pageContext.request.contextPath}/process</code>, lomake lähetetään sovelluksen sisältämään process-osoitteeseen, riippumatta siitä missä osoitteessa lomake oikeasti on.</p>

                <h3>Erillistä sovelluslogiikkaa</h3>

                <p>Jos sovelluksemme olisi hieman isompi ja jos koodi olisi Servlet-luokassa, tulisi Servlet-luokasta helposti hyvin raskas. Toteutetaan erillinen viestejä tuottava viestipalvelu. Viestipalvelun rajapinta on seuraavanlainen:</p>

<pre class="sh_java">
package werkko.helloworld;

public interface MessageService {
    public String getMessage();
}
</pre>

                <p>Ainoa rajapinnan MessageService määrittelemä toiminnallisuus on viestin antaminen. Luodaan rajapinnalle konkreettinen toteutus. Luokka <code>TimoSoiniMessageService</code> toteuttaa rajapinnan MessageService ja tarjoaa poliittisia epähelmiä.</p>

<pre class="sh_java">
package werkko.helloworld;

import java.util.Random;

public class TimoSoiniMessageService implements MessageService {

    private Random random = new Random();
    private String[] messages = {
        "Tuli iso jytky!",
        "Tänään on tilipäivä!",
        "Missä EU, siellä ongelma.",
        "Se on rikkaiden Neuvostoliitto tämä EU.",
        "Kukkahattu ja gebardihattu kuuluvat samaan ravintoketjuun. "
            + "Molemmilla on käsi sinun taskussasi.",
        "Yleisen asevelvollisuuden säilyttäminen on Suomelle huomattavasti "
            + "tärkeämpi asia kuin demokratian puolustaminen jossain sellaisessa "
            + "maassa, missä ei edes ole demokratiaa.",
        "Jos ei muuta, niin ainakin nuoret oppivat armeijassa kuria. Elämässä "
            + "ei vaan selviä niin, että tekee kaiken aina vaan oman pään "
            + "mukaan. Viimeistään sen huomaa siinä vaiheessa, kun menee "
            + "naimisiin.",
        "Sitäkään ei saa unohtaa, että meitä pidetään virallisesta "
            + "puolueettomuudesta huolimatta länsiblokin osana. Se saattaa "
            + "johtaa vielä jossain vaiheessa vaikeuksiin.",
        "Keksin itse jytkyn. Tuli iso jytky, kun pitikin.",
        "Hallitusvastuu on populistin sudenkuoppa."
    };

    public String getMessage() {
        return messages[random.nextInt(messages.length)];
    }
}
</pre>

                <p>Lisätään viestipalvelu Servlet-luokkaan ja käytetään sitä processRequest-metodissa.</p>

<pre class="sh_java">
// importit jne
public class HelloServlet extends HttpServlet {

    private MessageService messageService = new TimoSoiniMessageService();
    
    protected void processRequest(HttpServletRequest request, HttpServletResponse response)
            throws ServletException, IOException {
        response.setContentType("text/html;charset=UTF-8");
        
        request.setAttribute("message", messageService.getMessage());
        
        request.getRequestDispatcher("/WEB-INF/jsp/hello.jsp").forward(request, response);
    }

    // doGet ja doPost
}
</pre>

                <p>Nyt servletin kuuntelemaan osoitteeseen tehtävä pyyntö tuottaa esimerkiksi seuraavanlaisen vastauksen:</p>

<div class="naytto">
        <h1>Hello World!</h1>
        
        <p>Viesti: Hallitusvastuu on populistin sudenkuoppa.</p>
</div>

                <p>Juuri toteutettu poliittisia letkautuksia heittelevä Hei Maailma-sovellus on ylläpidettävyydeltään jo siedettävää luokkaa. Periaatteessa sovelluslogiikan vaihtaminen sellaiseksi, joka hakee viimeisimmän uutisen Helsingin sanomien etusivulta vaatisi vain uuden MessageService-rajapinnan toteuttavan luokan tekemistä ja sen vaihtamista HelloServlettiin.</p>


                <h4>Pyynnössä olevien parametrien käyttäminen</h4>

                <p>Pyynnön mukana voi lähettää parametreja palvelimelle. GET-tyyppisissä pyynnöissä parametrit ovat osana osoitetta. Esimerkiksi pyyntö osoitteeseen <code>http://palvelin.net/sovellus?parametri1=arvo1&amp;parametri2=arvo2</code> tekee käytännössä kyselyn osoitteessa <code>http://palvelin.net/sovellus</code> olevaan sovellukseen, ja antaa sovellukselle kaksi parametria. Parametrin <code>parametri1</code> arvo on <code>arvo1</code> ja <code>parametri2</code>-parametrin arvo on <code>arvo2</code>.</p>

                <p>Servlettien avulla pyynnössä oleviin parametreihin pääsee käsiksi <code>HttpServletRequest</code>-rajapinnan tarjoaman <code>getParameter</code>-metodin avulla. Metodi <code>getParameter</code> palauttaa sekä GET- että POST-tyyppisissä pyynnöissä lähetetyt parametrit. Esimerkiksi seuraavaa Servlet-luokka ottaa pyynnöstä parametrin <code>name</code> ja käyttää sitä osana tervehdysviestiä.</p>


<pre class="sh_java">
// importit jne
public class HelloServlet extends HttpServlet {

    protected void processRequest(HttpServletRequest request, HttpServletResponse response)
            throws ServletException, IOException {
        response.setContentType("text/html;charset=UTF-8");
        
        String name = request.getParameter("name");
        request.setAttribute("message", "Hello " + name);
        
        request.getRequestDispatcher("/WEB-INF/jsp/hello.jsp").forward(request, response);
    }

    // doGet ja doPost
}
</pre>

                <p>Jos ylläolevan Servlet-luokan kuuntelemaan osoitteeseen tehtäisiin pyyntö, jossa parametrin <code>name</code> arvona on <code>Mikke</code>, olisi processRequest-metodin suorituksen jälkeen attribuutin <code>message</code> arvo <code>Hello Mikke</code>.</p>


<div class="tehtavat">
          <h3>LoveMeter</h3>

          <p>Vuosien tutkimuksen ja miljoonien polttamisen jälkeen Kumpulan kampuksella on viimeinkin saatu aikaan algoritmi kahden henkilön yhteensopivuuden mittaamiseen. Algoritmin perusrakenne on seuraava:</p>

<pre class="sh_java">
        int minLength = Math.min(name1.length(), name2.length());
        
        int result = 0;
        for(int i = 0 ; i < minLength; i++) {
            result += (name1.charAt(i) * name2.charAt(i));
        }
        
        result += 42;
        
        return result % 100;
</pre>

          <p>Tehtävänäsi on luoda algoritmin käyttöön web-sovellus. Tehtävän tekeminen ohjeistetaan askeleittain.</p>

          <h4>KumpulaLoveMeter</h4>

          <p>Toteuta pakkaukseen <code>wad.lovemeter.service</code> luokka <code>KumpulaLoveMeter</code>, joka toteuttaa rajapinnan <code>LoveMeterService</code>. Käytä yllä olevaa algoritmia soveltuvuuden laskemiseen. Testaa luokkaasi.</p>

<pre class="sh_java">
        LoveMeterService loveMeter = new KumpulaLoveMeter();
        int match = loveMeter.match("mikke", "kasper");

        System.out.println("mikke and kasper match " + match + "%");
</pre>

<pre>
mikke and kasper match 80%
</pre>

          <h4>LoveServlet</h4>

          <p>Toteuta pakkaukseen <code>wad.lovemeter.servlet</code> luokka <code>LoveServlet</code>, joka perii luokan <code>HttpServlet</code>. Luokan <code>LoveServlet</code> tulee kuunnella polkua <code>/love</code>.</p>

          <p>Toteuta luokan LoveServlet metodi <code>doGet</code> siten, että se ottaa pyynnöstä parametrit <code>name1</code> ja <code>name2</code>, ja laskee edellisessä tehtävässä toteutetun luokan avulla parametrina annettujen nimien yhteensopivuuden. Tämän jälkeen yhteensopivuus asetetaan nimien kanssa pyynnön attribuuteiksi, ja pyyntö ohjataan eteenpäin.</p>
          
          <p>Ohjaa pyyntö tehtäväpohjassa valmiina tarjottuun polusta <code>/WEB-INF/jsp/love.jsp</code> löytyvään jsp-sivuun.</p>

          <p>Huom! Käytä edellisessä kohdassa toteutettua luokkaa <code>KumpulaLoveMeter</code> <strong>oliomuuttujana</strong>, mutta tietenkin siten, että ohjelmoit rajapintaa käyttäen luokassa <code>LoveServlet</code>.</p>

          <h4>Lomake tietojen lähettämiseen</h4>

          <p>Toteuta vielä kansiossa <code>Web Pages</code> olevalle sivulle <code>index.jsp</code> lomake tietojen lähettämiseen. Sivu <code>index.jsp</code> näytetään kun käyttäjä selaa sovelluksen juuriosoitteeseen. Lomakkeessa tulee olla kentät nimillä <code>name1</code> ja <code>name2</code>. Määrittele kentille myös id:t (name1 ja name2 vastaavasti). Lomake tulee lähettää <code>LoveServlet</code>-servletin kuuntelemaan polkuun.</p>

          <p>Lomake voi näyttää esimerkiksi seuraavalta:</p>

<div>
<img src="img/teht-6-kuva.png" border=1/>
</div>
          <p>Testaa vielä sovellustasi kokonaisuudessaan.</p>


          <p>Kun olet saanut tehtävän valmiiksi, lähetä se TMCn tarkastettavaksi.</p>
</div>


<div class="pohdi">
<p><strong>MVC</strong></p>

<p>MVC (model-view-controller) on ohjelmistoarkkitehtuurityyli, jonka tavoitteena on käyttöliittymän erottaminen sovelluslogiikasta. Model on yleensä näytettävä data, view on itse näkymä, ja controller vastaanottaa käyttäjän tekemät käskyt ja muokkaa niiden pohjalta sekä dataa että näytettävää näkymää.</p>

<p>Miten edellä esitetty Hello Web! -esimerkki liittyy MVC-arkkitehtuuriin? Mikä rooli on jsp-sivuilla, servleteillä, ja pyynnön sisältämällä attribuuteilla?</p>
</div>




<!--

nyt vk2:

 * JSTL
   * foreach, listan näyttäminen sivulla
   * esimerkki: chat, jossa ei front-controlleria

        <!-- tyypillinen feelu on kirjoittaa itemsiin pelkkä stringi -->
        <!-- tai unohtaa attribuutin nimi (täällä ${messages} on sama kuin mitä 
        tänne ohjaavassa servletissä on asetettu

        c:forEach var="message" items="${messages}"
            p>${message}</p
       /c:forEach

<!--
 * front controller pattern
   * esimerkki: laskin, jokaiselle funktiolle oma kontrolleri, fibolle for-each
             sum ? op1=5&op2=7  => result.jsp
             subtract => result.jsp
             multiply => result.jsp
             fibonacci => fib.jsp, jossa jstl

   tehtävä: W2E01: Chat front-controllerilla (arto)
        FrontControllerServlet valmiina?
 
        interface Controller
             String processRequest
    
                  login -> LoginController (sessio) -> redirect
                  messages -> ListMessagesController -> jos ei nimeä, redirect loginiin
                  add-message -> AddMessageController -> redirect

                  sessio otettu veke, muuten tulee turhaa tähän ja fokus ei oo front controllerissa (lopussa kuiteski tietoturvaa)

   ja tietoturvan alkeet:
     html encode
     nih: commons lang -> string escape utils
     
     * info tän jälkeen: encode ei oo tarpeeks, esim charsettiä vaihtamalla tai unicodea käyttämällä voi aiheuttaa probleemeja
       esim http://wonko.com/post/html-escaping
-->



<h2>Dynaamiset JSP-sivut: JSTL ja EL</h2>

                <p>JSP-sivut ovat dynaamista tietoa sisältäviä HTML-sivuja, jotka prosessoidaan palvelimella käyttäjälle näyttämistä. Palvelimella tapahtuvan prosessoinnin yhteydessä JSP-sivu muunnetaan servletiksi, servletti käännetään, ja lopulta servletin tuottama tulostus näytetään käyttäjälle. Tämä mahdollistaa asiakkaan pyyntöön liittyvien tietojen käsittelyn JSP-sivuilla: JSP-sivut ovat servlettejä ja pääsevät täsmälleen samoihin tietoihin käsiksi kuin servletit. JSP-sivuille on myös mahdollista tuottaa sisältöä suoraan Javalla:</p>

<pre class="sh_xml">
&lt;%@page contentType="text/html" pageEncoding="UTF-8"%&gt;
&lt;!DOCTYPE html&gt;
&lt;html&gt;
    &lt;head&gt;
        &lt;meta http-equiv="Content-Type" content="text/html; charset=UTF-8"&gt;
        &lt;title&gt;Hello World!&lt;/title&gt;
    &lt;/head&gt;
    &lt;body&gt;
        &lt;%
        System.out.println("Poor man's logging to server logs!");
        out.append("&lt;p&gt;Message to the page&lt;/p&gt;");
        %&gt;
    &lt;/body&gt;
&lt;/html&gt;
</pre>
                <p>Yllä oleva JSP-sivu tuottaa seuraavanlaisen näkymän, sekä viestin <code>Poor man's logging to server logs!</code> palvelimen logeihin.</p>

<div class="naytto">
        <p>Message to the page</p>
</div>

                <p><em>That being said, don't do it.</em>: Java-koodin käyttäminen JSP-sivuilla on indikaattori erittäin huonosta suunnittelusta ja johtaa hyvin vaikeasti ylläpidettäviin näkymiin. Erityisesti JSP-sivulla olevassa koodissa sijaitsevan virheen etsiminen on yhtä tuskaa: virheiden stack tracet liittyvät luonnollisesti JSP-sivusta käännetyn servletin koodiin.</p>

                <p>On oleellista kuitenkin ymmärtää, että kaikki sivuilla näytettävä tieto luodaan palvelimella.</p>

                <p>Java-koodin käyttäminen JSP-sivuilla on kielletty. Tarvitsemme dynaamisuutta sivuillemme: esimerkiksi listojen tulostaminen ei onnistu ilman ohjelmakoodia. Näimme aiemmin esimerkin EL-kielestä, jonka avulla sivulla voi käyttää ja näyttää pyynnössä olevia attribuutteja. EL-kieli oli alunperin osa JSTL-kieltä, joka on kokoelma tägikirjastoja JSP-sivuilla näytettävän datan prosessointiin.</p>


                <h3>EL</h3>


                <p>EL eli <em>Expression Language</em> on kieli, jolla pääsee käsiksi mm. pyynnössä oleviin attribuutteihin. EL-kielen lauseet ilmaistaan <code>${ }</code>-merkinnällä, jonka sisällä on lauseke. Näimme aiemmin yksinkertaisen EL:n käyttöesimerkin jossa pyyntöön lisätään servletissä attribuutti, esim. <code>request.setAttribute("viesti", "attribuutin arvo");</code>, joka näytetään JSP-sivulla, esim. <code>&lt;p&gt;${viesti}&lt;/p&gt;</code>.</p>


                <h4>Olioiden käsittely</h4>

                <p>EL-kielen piste-operaattorin <code>.</code> avulla pääsee käsiksi attribuutteina olevien olioiden get-metodeihin. Esimerkiksi lause <code>${auto.hinta}</code> tekee <code>auto</code>-nimellä lisättyyn attribuuttiin metodikutsun <code>getHinta()</code>. Tutkitaan tätä hieman tarkemmin. Oletetaan että käytössämme on seuraava luokka Item.</p>

<pre class="sh_java">
public class Item {
    private String name;
    private int price;

    public Item(String name, int price) {
        this.name = name;
        this.price = price;
    }

    public String getName() {
        return this.name;
    }

    public int getPrice() {
        return this.price;
    }
}
</pre>

      
                <p>Jos Item-luokan ilmentymä lisätään pyynnön attribuutiksi, voi ilmentymän get-alkuista metodia kutsua pisteoperaattorin avulla JSP-sivulta.</p>

<pre class="sh_java">
    ...
    Item tmc = new Item("TMC", 330);
    request.setAttribute("item", tmc);
    ...
</pre>

                <p>Kun olio on lisätty pyynnön attribuutiksi nimellä <code>item</code>, voidaan siihen liittyviin get-metodeihin viitata muodossa <code>${item.<em>ominaisuus</em>}</code>. Tämä tekisi metodikutsun <code>getOminaisuus()</code>. Metodia <code>getName()</code> voi kutsua seuraavasti:</p>

<pre class="sh_xml">
    ...
    &lt;body&gt;
        &lt;p&gt;Ja seuraavana vuorossa on: ${item.name}&lt;/p&gt;
    &lt;/body&gt;
    ...
</pre>

                <p>Yllä oleva esimerkki luo seuraavanlaisen tulostuksen.</p>

<pre class="naytto">
Ja seuraavana vuorossa on: TMC
</pre>

                <p>Vastaavasti <code>Item</code>-olion metodia <code>getPrice()</code> voisi kutsua EL-kielen avulla lauseella ${item.price}</p>.


                <h4>Collection-tyyppisten ilmentymien käsittely</h4>


                <p>EL-kielellä on notaatio <code>[]</code> <code>Collection</code>-tyyppisten olioiden (esim. listat, mapit, taulukot) käsittelyyn. Esimerkiksi, jos attribuutiksi on asetettu <code>map</code>-niminen hajautustaulu:</p>

<pre class="sh_java">
    ...
    Map&lt;String, String&gt; map = new HashMap&lt;String, String&gt;();
    map.put("text", "tada!");

    request.setAttribute("map", map);
    ...
</pre>

                <p>Päästään siihen käsiksi <code>map</code>-attribuutin kautta. Tämä oli toki tuttua. Hajautustaulun sisällä oleviin arvoihin taas päästään käsiksi attribuutin kautta, esimerkiksi <code>map</code>-attribuutista voidaan hakea <code>text</code>-avaimella olevaa arvoa komennolla <code>${map['text']}</code>.</p>


<pre class="sh_xml">
    ...
    &lt;body&gt;
        &lt;p&gt;Collection-ilmentymiin pääsee käsiksi: ${map['text']}&lt;/p&gt;
    &lt;/body&gt;
    ...
</pre>

                <p>Yllä olevan sivun tulostus olisi seuraavanlainen:</p>

<pre class="naytto">
Collection-ilmentymiin pääsee käsiksi: tada!
</pre>



                <h4>Totuusarvolausekkeet ja laskuoperaatiot</h4>


                <p>EL-lauseiden sisään voi asettaa myös erilaisia vertailuja ja laskuoperaatioita. Esimerkiksi kahden tuotteen hinnan laskeminen on melko yksinkertaista:</p>


<pre class="sh_java">
    ...
    Item one = new Item("Milk", 173);
    Item another = new Item("Porridge", 222);

    request.setAttribute("item1", one);
    request.setAttribute("item2", another);
    ...
</pre>

                <p>Laskuoperaation voi toteuttaa EL-lauseen sisällä. Esimerkiksi lause <code>${item1.price + item2.price}</code> kutsuu ensin attribuutin <code>item1</code> <code>getPrice()</code>-metodia, ja lisää sen palauttaman arvon attribuutin <code>item2</code> <code>getPrice()</code>-metodin palauttamaan arvoon.</p>

<pre class="sh_xml">
    ...
    &lt;body&gt;
        &lt;p&gt;${item1.name} and ${item2.name} cost together ${item1.price + item2.price}.&lt;/p&gt;
    &lt;/body&gt;
    ...
</pre>

                <p>Yllä oleva esimerkki luo seuraavanlaisen tulostuksen.</p>


<pre class="naytto">
Milk and Porridge cost together 395.
</pre>


                <p>Katso lisätietoa erilaisista EL-kielen mahdollisuuksista sivuilta <a href="http://docs.oracle.com/javaee/1.4/tutorial/doc/JSPIntro7.html#wp77083" target="_blank">oraclen sivuilta</a>.</p>
                

                <p>Todellisuudessa, kukaan ei toivottavasti ohjelmoi kauppalistaa siten, että jokainen tuote lisätään erillisenä attribuuttina. Tutustutaan seuraavaksi JSTL-kieleen, jonka avulla sivuille saadaan toiminnallisuutta mm. listojen läpikäyntiin.</p>


                <h3>JSTL</h3>


                <p>JSTL eli <em>JSP Standard Tag Library</em> on kokoelma XML-tägikirjastoja, joiden avulla JSP-sivuille voidaan lisätä dynaamista toiminnallisuutta. Ensimmäinen JSTL-spesifikaatio (vuodelta 2002) määrittelee JSTL:n tavoitteeksi JSP-sivuja toteuttavien ihmisten elämän helpottamisen: osalla käyttöliittymäsuunnittelijoista ei ole ohjelmointitaustaa. Koska JSTL-tägit ovat XML:ää, ei niiden käyttö haittaa käyttöliittymäsuunnittelussa. JSTL:ää ja HTML:ää sisältäviä JSP-sivuja voi tarkastella myös suoraan selaimella.</p>

                <p>Servlet-APIn versiota <code>2.5</code> käytettäessä käytämme JSTL:n versiota <code>1.2</code>. JSTLn saa käyttöön lisäämällä projektin <code>pom.xml</code>-tiedostoon seuraavan riippuvuuden:</p>

<pre class="sh_xml">
    &lt;dependency&gt;
        &lt;groupId&gt;jstl&lt;/groupId&gt;
        &lt;artifactId&gt;jstl&lt;/artifactId&gt;
        &lt;version&gt;1.2&lt;/version&gt;
    &lt;/dependency&gt;
</pre>


                <p>Kun JSTL-riippuvuus on lisätty projektiin, voi JSTL-tägikirjastoja käyttää osana JSP-sivua. Käytettävä tägikirjasto tulee aina esitellä JSP-sivun alussa. Esimerkiksi seuraava määrittely tuo JSTLn ydinkirjaston käyttöön.</p>


<pre class="sh_java">
&lt;%@taglib prefix="c" uri="http://java.sun.com/jsp/jstl/core" %&gt;
</pre>

                <p>Tägikirjastoja käytetään niille määriteltyjen etuliitteiden avulla. Yllä olevassa määrittelyssä ydinkirjastolle määritellään etuliite <code>c</code>, jolloin siihen liittyviin elementteihin pääsee käsiksi <code>&lt;c:</code>-etuliitteen avulla.</p>


                <p>JSTL sisältää tägit mm. perusohjelmoinnissa käytettävien kontrollirakenteiden käyttöön, erilaisten tulostusten formatointiin, ja esimerkiksi erilaisten RSS/XML-syötteiden käsittelyyn. Tällä kurssilla hyödynnämme lähinnä kontrollirakenteita.</p>

                <h4>Toistolauseet: forEach</h4>


                <p>Meille oleellisin komento on <code>forEach</code>, jota käytetään Collection-rajapinnan toteuttavien kokoelmien läpikäyntiin. Sille määritellään attribuutti <code>items</code>, jonka arvona on EL-kielellä merkattu läpikäytävä joukko. Toinen attribuutti, <code>var</code>, määrittelee muuttujan nimen, johon kokoelmasta otettava alkio kullakin iteraatiolla tallennetaan. Perussyntaksiltaan <code>forEach</code> on seuraavanlainen.</p>

<pre class="sh_xml">
    ...
    &lt;pre&gt;
        &lt;c:forEach var="alkio" items="${joukko}"&gt;
            ${alkio}
        &lt;/c:forEach&gt;
    &lt;/pre&gt;
    ...
</pre>

                <p>Yllä käytämme attribuuttia nimeltä <code>joukko</code>, ja tulostamme yksitellen sen sisältämät alkiot.</p>

                <p><em>Huom! Klassisin virhe on määritellä iteroitava joukko merkkijonona <code>items="joukko"</code>. Tämä ei luonnollisesti toimi.</em></p>


                <p>Iteroitavan joukon alkioiden ominaisuuksiin pääsee käsiksi EL-kielellä. Tutkitaan seuraavaa esimerkkiä, jossa listaan lisätään kaksi esinettä, lista lisätään pyyntöön, ja lopulta näytetään JSP-sivulla.</p>


<pre class="sh_java">
    ...
    Item one = new Item("Milk", 173);
    Item another = new Item("Porridge", 222);

    List&lt;Item&gt; list = new ArrayList&lt;Item&gt;();
    list.add(one);
    list.add(another);

    request.setAttribute("list", list);
    ...
</pre>

<pre class="sh_xml">
    ...
    &lt;p&gt;And the menu is:&lt;/p&gt;
    &lt;ol&gt;
        &lt;c:forEach var="item" items="${list}"&gt;
            &lt;li&gt;${item.name}&lt;/li&gt;
        &lt;/c:forEach&gt;
    &lt;/ol&gt;
    ...
</pre>

                <p>Lopullinen tulostus näyttää seuraavalta.</p>

<div class="naytto">
    <p>And the menu is:</p>
    <ol>
        <li>Milk</li>
        <li>Porridge</li>
    </ol>
</div>

                <p>Lisää JSTL-kirjastoon liittyvää tietoa löytyy mm. osoitteista <a href="http://docs.oracle.com/javaee/5/tutorial/doc/bnakc.html" target="_blank">http://docs.oracle.com/javaee/5/tutorial/doc/bnakc.html</a> ja <a href="http://www.jsptutorial.net/jsp-standard-tag-library-jstl.aspx" target="_blank">http://www.jsptutorial.net/jsp-standard-tag-library-jstl.aspx</a>.</p>

<div class="tehtavat">
  <NEXTWEEK></NEXTWEEK>
  <h3>My Albums</h3>

  <p>Harjoitellaan hieman JSTL:n ja EL:n käyttöä. Tässä tehtävässä toteutetaan pyyntöön lisättyjen albumeiden listaus JSP-sivulla. Kannattaa tutustua luokkiin <code>Album</code> ja <code>ListServlet</code> ennen aloittamista. JSTL-riippuvuus on lisätty valmiiksi projektin pom.xml-tiedostoon.</p> 

  <h4>Albumien nimien listaaminen</h4>

  <p>Muokkaa kansiossa <code>WEB-INF/jsp</code> olevaa sivua <code>list.jsp</code> siten, että se tulostaa attribuuttina olevien albumien nimet. Albumit on säilötty listaan, joka on pyynnössä attribuuttina <code>albums</code>.</p>

  <h4>Albumien kappaleiden lisääminen</h4>

  <p>Lisää <code>list.jsp</code> sivulle toiminnallisuus albumien sisältämien kappaleiden listaamiseen. Vinkki: Kun käyt edellisessä osassa albumeita läpi, jokainen yksittäinen albumi on olio, johon EL-kielen avulla voi viitata.</p>
  
  
</div>

<!--


 * nykyaikainen softakehitys: DI, IoC (spring), OlioContainerin idea -- on tavaraa jemmassa mitä tuodaan tarvittaessa näkyville

   * mikä on beani, setterit ja getterit

   * bean injektio
       xml-esimerkki, käytännössä sama kuin sanoisi a = new A() ja settaisi sen


       tehtävä W2E03: HelloDependencyInjection (arto)
                     softa lataa xml:stä konffin ja lataa olion

                     HelloDependencyInjectionWithMessage
                     softa lataa xml:stä konffin, konffissa parametri joka tungetaan setteriin

                     
       pohja: testing/hello_spring
-->


                <h2>Web-sovellukset, hyvät ohjelmointikäytänteet ja peruskäsitteistöä</h2>


                <p>Tutustutaan seuraavaksi web-sovellusten ohjelmoinnissa käytettäviin perusohjelmointikäytänteisiin. Pohjustamme myös siirtymistä Spring-sovelluskehyksen käyttöön.</p>
                

                <h3>POST-pyyntötyypin käyttäminen</h3>


                <p>Erilaisiin pyyntötyyppeihin tulee reagoida eri tavalla. GET-pyynnöt ovat suoria pyyntöjä, joilla käyttäjät pyytävät palvelimella olevia resursseja. POST-pyynnöt taas ovat pyyntöjä datan muokkaamiseen. Esimerkiksi lomakkeet, joilla muokataan palvelimella olevaa dataa, tulee lähettää POST-tyyppisenä pyyntönä.</p>


                <p>Ehkäpä tärkein syy tämän säännön noudattamiselle liittyy webissä oleviin hakukoneisiin. Hakukoneet käyvät verkon sivustoja jatkuvasti läpi uuden tiedon hakemiseen. Ne seuraavat sivuilla olevia linkkejä, mutta rajoittavat yleensä pyyntönsä GET-tyyppisiin pyyntöihin. Jos sivuilla olevat normaalit linkit mahdollistavat tiedon poistamisen, sivujen läpikäynti hakukoneiden toimesta voi poistaa sivulla olevan datan.</p>


                <p>Jos käyttäjän tekemällä POST-tyyppisellä pyynnöllä muokataan sivulla olevaa dataa (esim. datan lisääminen lomakkeen avulla), tulee käyttäjä ohjata tekemään uusi GET-tyyppinen pyyntö pyynnön prosessoinnin jälkeen. Tällä pyritään poistamaan mahdollisuus POST-tyyppisten pyyntöjen uudelleentekemiseen esimerkiksi F5-näppäintä painettaessa, ja se helpottaa huomattavasti sovelluksen sisäisen rakenteen suunnittelua. Jokaisella servletillä on täsmälleen yksi vastuu: yksi on tiedon lisäämiseen, toinen listaamiseen jne..</p>

                <p>Käytännössä käyttäjän ohjaaminen uuden pyynnön tekemiseen tapahtuu palauttamalla POST-pyyntöön HTTP-statuskoodi 303 (tai 302) ja osoite uuteen sijaintiin. Kun selain saa "sivu muuttanut" -viestin, hakee se automaattisesti uudessa osoitteessa olevan sivun.</p>


                <h3>SOLID</h3>

                <p>Termi <strong>SOLID</strong> lanseerattiin Robert "Uncle Bob" Martinin toimesta 2000 luvun alussa. Termi sisältää hyviä olio-ohjelmoinnissa käytettäviä käytänteitä. SOLID on akronyymi seuraaville käsitteille: <strong>S</strong>ingle responsibility principle, <strong>O</strong>pen/closed principle, <strong>L</strong>iskov substitution principle</strong>, <strong>I</strong>nterface segregation principle, ja <strong>D</strong>ependency inversion principle.</p>
                
                <p>
                  <ul>
                    <li>Single responsibility principle: Oliolla tulee olla vain yksi selkeä vastuu.</li><br/>

                    <li>Open/closed principle: Komponenttien tulee olla avoimia laajennukselle, mutta suljettuja muokkaukselle. Käytännössä komponentille tehtävien muutosten ei tule aiheuttaa muutoksia komponenttia jo laajentaville ja käyttäville komponenteille.</li><br/>

                    <li>Liskov substitution principle: Jos komponentti vaihdetaan sitä laajentavaan komponenttiin, komponenttia käyttävien sovellusten ohjelmien toiminnallisuuden ei tule muuttua.</li><br/>

                    <li>Interface segregation principle: Erottele rajapinnat toiminnallisuuksien perusteella. Monta asiakas/tapauskohtaista rajapintaa on parempi kuin yksi yleinen rajapinta.</li><br/>

                    <li>Dependency inversion principle: Käytä abstraktioita, älä ole riippuvainen konkreettisista toteutuksista.</li><br/>
                  </ul>
                </p>
                
                <p>Käytännössä SOLID on lista oliosuunnittelun periaatteita, joita seuratessa järjestelmän ylläpidettävyys ja kehitettävyys on huomattavasti helpompaa. Haluamme että omat web-sovelluksemme seuraavat yllälistattuja periaatteita. </p>

                
                <h3>Front Controller pattern</h3>


                <p><em>Front Controller</em> on suunnittelumalli, jossa kaikille pyynnöille tarjotaan keskitetty käsittelypaikka. Käytännössä kaikki web-sovellukseen liittyvät pyynnöt ohjataan aluksi yhdelle kontrollipalvelulle, esimerkiksi servletille, joka ohjaa ne eteenpäin riippuen pyynnöstä ja pyynnössä haluttavasta resurssista.</p>


                <p>Tyypillinen esimerkki Front Controllerin käytöstä on käyttäjän oikeuksien varmistaminen. Koska kaikki pyynnöt ohjataan ensin tietylle servletille, voidaan servletissä tarkistaa mm. käyttöoikeuksien olemassaolo, sekä mahdollisesti hakea käyttäjäkohtaisia tietoja. Toinen esimerkki on <a href="http://en.wikipedia.org/wiki/Wizard_(software)" target="_blank">Wizard</a>-tyyppiset sovellukset, joissa sivujen näyttöjärjestys on erittäin tärkeä. Tässä Front Controller voi helposti kontrolloida sivujen näyttöjärjestystä.</p>


                <p>Front Controller-suunnittelumallia käytetään web-sovellusten toteuttamiseen liittyvän "bulk"-koodin piilottamiseen. Pyyntöjen prosessoinnit, ohjaukset, ym. tulee ohjelmointikielestä riippumatta aina toteuttaa. Sovelluskehykset tarjoavat valmiit rungot, joita käyttämällä ohjelmoija voi keskittyä web-sovelluksen oleellisempiin asioihin. Huomattava osa aktiivisessa käytössä olevista sovelluskehyksistä käyttää Front Controller-suunnittelumallia, mm. <a href="http://www.zend.com/" target="_blank">Zend</a>, <a href="http://www.symfony-project.org/" target="_blank">Symfony</a>, <a href="http://rubyonrails.org/" target="_blank">Ruby on Rails</a>, <a href="http://www.asp.net/mvc" target="_blank">ASP .NET MVC</a> ja <a href="http://www.springsource.org/" target="_blank">Spring</a>.</p>


                <h4>Oma Front Controller</h4>


                <p>Toteutetaan oma Front Controller-luokka. Ajatuksena on se, että kaikki pyynnöt ohjataan ensin tietylle Servlet-luokalle, jonka tehtävänä on: (1) ohjata pyynnöt niiden käsittelyyn erikoistuneille luokille, (2) hoitaa pyyntöihin liittyvät perustoiminnallisuudet. Kaikkien pyyntöjen ohjaaminen tietylle Servlet-luokalle onnistuu lisäämällä <code>web.xml</code>-dokumentissa oleviin kuunneltaviin osoitteisiin <code>*</code>. Esimerkiksi seuraava konfiguraatio ohjaisi kaikki polkuun <code>/app/</code> ja sen alle tulevat pyynnöt servletille <code>FrontControllerServlet</code>.</p>

<pre class="sh_xml">
    &lt;servlet&gt;
        &lt;servlet-name&gt;FrontControllerServlet&lt;/servlet-name&gt;
        &lt;servlet-class&gt;wad.chat.core.FrontControllerServlet&lt;/servlet-class&gt;
    &lt;/servlet&gt;    
    &lt;servlet-mapping&gt;
        &lt;servlet-name&gt;FrontControllerServlet&lt;/servlet-name&gt;
        &lt;url-pattern&gt;/app/*&lt;/url-pattern&gt;
    &lt;/servlet-mapping&gt;
</pre>

                <p>Tyypillisiä yhteisiä tehtäviä, joita aiemmat Servlet-luokkamme ovat tähän mennessä toteuttaneet, on vastauksen merkistön asettaminen pyynnön käsittelyn alussa (<code>response.setContentType("text/html;charset=UTF-8")</code>), ja pyynnön ohjaaminen JSP-sivulle pyynnön lopussa (<code>request.getRequestDispatcher(".../sivu.jsp").forward(request, response)</code>). Näiden lisäksi jokaisella Servlet-luokalla on ollut oma spesifi toiminnallisuus.</p>

                <p>Luodaan aluksi runko omalle FrontController-toteutuksellemme.</p>

<pre class="sh_java">
// importit ym
public class FrontControllerServlet extends HttpServlet {

    protected void processRequest(HttpServletRequest request, HttpServletResponse response)
            throws ServletException, IOException {
        response.setContentType("text/html;charset=UTF-8");

        // pyynnön ohjaaminen oikealle käsittelijälle

        request.getRequestDispatcher(".../sivu.jsp").forward(request, response);
    }

    // doGet ja doPost kutsuvat processRequest-metodia
}
</pre>

                <p>Toteutetaan pyynnön käsittelijää varten rajapinta, joka määrittelee kaksi metodia. Toinen metodi prosessoi pyynnön ja palauttaa sivun johon pyyntö ohjataan, toinen määrittelee käsittelijän kuunteleman polun. Kutsutaan rajapintaa nimellä <code>Controller</code>.</p> 

<pre class="sh_java">
public interface Controller {
    String getListenedPath();

    String processRequest(HttpServletRequest request,
            HttpServletResponse response)
            throws Exception;
}
</pre>


                <p>Luodaan ensimmäinen konkreettinen kontrolleritoteutus <code>ListController</code>. Toteutus kuuntelee sovelluksen polkua <code>list</code>, lisää pyyntöön listan merkkijonoja, ja palauttaa JSP-sivuun osoittavan osoitteen.</p>


<pre class="sh_java">
// importit
public class ListController implements Controller {

    @Override
    public String getListenedPath() {
        return "list";
    }

    @Override
    public String processRequest(HttpServletRequest request,
            HttpServletResponse response) throws Exception {
        List&lt;String&gt; strings = Arrays.asList("hello", "world");
        request.setAttribute("list", messageService.list());

        return "/WEB-INF/jsp/list.jsp";
    }
}
</pre>

                <p>Muutetaan luokkaa <code>FrontControllerServlet</code> siten, että se tuntee Controller-rajapinnan toteuttamat luokat. Lisäämme kontrollerit <code>init</code>-metodissa, jota palvelin kutsuu Servlet-luokan luonnin yhteydessä. Tämän voisi toteuttaa myös esimerkiksi Javan reflektion avulla, jolloin luokan FrontControllerServlet ei tarvitsisi tietää Controller-rajapinnan toteuttamista luokista. Pitäydymme kuitenkin kevyemmässä esimerkissä.</p>


<pre class="sh_java">
// importit ym
public class FrontControllerServlet extends HttpServlet {

    private Map&lt;String, Controller&gt; pathToControllerMap;

    @Override
    public void init() {
        pathToControllerMap = new TreeMap&lt;String, Controller&gt;();

        Controller listController = new ListController();
        pathToControllerMap.put(listController.getListenedPath(), listController);
    }

    protected void processRequest(HttpServletRequest request, HttpServletResponse response)
            throws ServletException, IOException {
        response.setContentType("text/html;charset=UTF-8");
     
        // haetaan sopiva kontrolleri
        Controller controller = getController(request.getRequestURI());
        if (controller == null) {
            // jos kontrolleria ei löydy, palautetaan statusviesti 404
            response.setStatus(HttpServletResponse.SC_NOT_FOUND);
            response.getWriter().println("404: " + request.getRequestURI());
            return;
        }

        // muuten, ohjataan prosessointi kontrollerille
        String page = controller.processRequest(request, response);

        // ja pyyntö lopuksi oikealle JSP-sivulle
        request.getRequestDispatcher(page).forward(request, response);
    }

    // metodi oikean kontrollerin valitsemiseen löytämiseen
    private Controller getController(String uri) {
        if (!uri.contains("/")) {
            return pathToControllerMap.get(uri);
        }

        uri = uri.substring(uri.lastIndexOf("/") + 1);
        return pathToControllerMap.get(uri);
    }

    // doGet ja doPost kutsuvat processRequest-metodia
}
</pre>


                <p>Luodaan seuraavaksi kontrolleri tiedon lisäämiseen. Luokka <code>AddController</code> saa pyynnön mukana dataa, jota sen pitää tallentaa myöhempää käyttöä varten. Jätämme itse tiedon tallentamisen harjoitustehtäväksi.</p>


<pre class="sh_java">
// importit
public class AddController implements Controller {

    @Override
    public String getListenedPath() {
        return "add";
    }

    @Override
    public String processRequest(HttpServletRequest request,
            HttpServletResponse response) throws Exception {
        String information = request.getParameter("information");
        // tallennetaan tieto

        return "/WEB-INF/jsp/add.jsp"; // ???
    }
}
</pre>


                <p>Huomaamme palautettavan sivun osoitetta tarkastellessamme, että rikomme aiemmin mainittua sääntöä tiedon tallentamiseen liittyen. Jos pyynnössä tallennetaan tietoa, tulee se ohjata uudelleen tuplatallennusten estämiseksi (kts. kappale 6.1). Joudumme siis toteuttamaan mekanismin pyyntöjen uudelleen ohjaamiselle.</p>

                
                <p>Koska pyyntöjen eteenpäin ohjaaminen on luokan FrontControllerServlet-vastuulla, ei uudelleenohjausta voi määritellä <code>Controller</code>-rajapinnan toteuttamissa luokissa.</p>


                <p>Ratkaistaan ongelma määrittelemällä sääntö. Jos metodin <code>processRequest</code> palauttama merkkijono sisältää alkuosan <code>redirect:</code>, tulee pyyntö ohjata uudestaan <code>redirect:</code>-osaa seuraavaan osoitteeseen. Muutetaan luokkaa <code>AddController</code> siten, että siihen saapuvat pyynnöt ohjataan lopulta <code>list</code>-osoitetta kuuntelevalle kontrollerille.</p>


<pre class="sh_java">
// importit
public class AddController implements Controller {

    // mm. tiedon tallennuspaikka

    @Override
    public String getListenedPath() {
        return "add";
    }

    @Override
    public String processRequest(HttpServletRequest request,
            HttpServletResponse response) throws Exception {
        String information = request.getParameter("information");
        // tallennetaan tieto

        return "redirect:list"; // :)
    }
}
</pre>

                <p>Muokataan luokkaa <code>FrontControllerServlet</code> siten, että se ottaa huomioon <code>Controller</code>-tyyppisten olioiden erilaiset palautukset. Jos metodin <code>processRequest</code> palauttamassa merkkijonossa on alkuosa <code>redirect:</code>, pyydetään käyttäjää tekemään uudelleenohjaus. Muulloin pyyntö ohjataan määritellylle JSP-sivulle. Luokkaa myös refaktoroidaan hieman.</p>


<pre class="sh_java">
// importit ym
public class FrontControllerServlet extends HttpServlet {

    private static final String REDIRECT_PREFIX = "redirect:";
    private Map&lt;String, Controller&gt; pathToControllerMap;

    // init-metodi, jossa kontrollerit luodaan ja lisätään pathToControllerMap-olioon

    protected void processRequest(HttpServletRequest request, HttpServletResponse response)
            throws ServletException, IOException {
        response.setContentType("text/html;charset=UTF-8");

        // haetaan sopiva kontrolleri
        Controller controller = getController(request.getRequestURI());
        if (controller == null) {
            // jos kontrolleria ei löydy, palautetaan statusviesti 404
            response.setStatus(HttpServletResponse.SC_NOT_FOUND);
            response.getWriter().println("404: " + request.getRequestURI());
            return;
        }

        // suoritetaan pyyntö löydetyllä kontrollerilla
        executeControllerAndResolveView(controller, request, response);
    }

    // suoritetaan pyyntö ja ohjataan pyynnön vastaus näkymän
    // päättelevälle metodille
    private void executeControllerAndResolveView(Controller controller,
            HttpServletRequest request, HttpServletResponse response)
            throws IOException, ServletException {
        String resultPath = null;
        try {
            resultPath = controller.processRequest(request, response);
        } catch (Exception ex) {
            throw new ServletException(ex);
        }

        resolveView(resultPath, request, response);
    }

    // pyyntöön liittyvän näkymän etsiminen
    private void resolveView(String resultPath,
            HttpServletRequest request, HttpServletResponse response)
            throws IOException, ServletException {

        // jos vastaus alkaa etuliitteellä "redirect:", käyttäjälle
        // tulee palauttaa pyyntö uudelleenohjaukseen
        if (resultPath.startsWith(REDIRECT_PREFIX)) {
            String redirectTo = resultPath.substring(REDIRECT_PREFIX.length());

            // metodi sendRedirect lähettää käyttäjälle tiedon sivun muualla
            // sijaitsemisesta. Käytännössä selain tekee uuden kyselyn vastauksessa
            // tulevaan osoitteeseen.
            response.sendRedirect(redirectTo);

        } else {
            request.getRequestDispatcher(resultPath).forward(request, response);
        }
    }

    // ...
</pre>

                <p>Yllä oleva Front Controller rikkoo oliosuunnittelun hyviä periaatteita. Luokalla on monta vastuuta: se ohjaa pyynnöt kontrollerille <em>ja</em> päättelee kontrollerin vastauksen perusteella palautettavan sivun. Palautettavan sivun päättelyyn kannattaisi tehdä erillinen luokka. Jätämme sen kuitenkin tässä tekemättä.</p>


<div class="tehtavat">
          <h3>Chat</h3>


          <p>Tässä tehtäväsarjassa luodaan chat-palvelun perustoiminnallisuutta. Sovelluksessa on valmiina äsken nähty Front Controller patternia seuraava FrontControllerServlet, jota käytät hyödyksesi uusia komponentteja tehdessäsi.</p>


          <p>FrontControllerServlet käyttää hyödyksi Controller-rajapinnan toteuttavia luokkia. Controller-rajapinta on seuraavanlainen:</p>


<pre class="sh_java">
import javax.servlet.http.HttpServletRequest;
import javax.servlet.http.HttpServletResponse;

public interface Controller {
    String getListenedPath();

    String processRequest(HttpServletRequest request,
            HttpServletResponse response)
            throws Exception;
}
</pre>


          <p>Metodin <code>getListenedPath</code> tulee palauttaa polku, johon tulleet pyynnöt ohjataan rajapinnan toteuttavalle kontrolleriluokalle. Metodi processRequest hoitaa pyynnön. Metodissa processRequest <em>ei</em> esimerkiksi ohjata pyyntöä eteenpäin, vaan pyynnön ohjaamisen vastuu jätetään FrontControllerServlet-luokalle.</p>


          <p>Metodi <code>processRequest</code> palauttaa merkkijonon. Jos merkkijono on jsp-sivun sijainti, esimerkiksi <code>/WEB-INF/jsp/list.jsp</code>, näytetään käyttäjälle haluttu JSP-sivu. Jos taas merkkijonossa on <code>redirect:</code>-etuliite, selainta pyydetään tekemään uudelleenohjaus <code>redirect:</code> -merkkijonoa seuraavaan osoitteeseen. Esimerkiksi, jos metodi <code>processRequest</code> palauttaa merkkijonon <code>redirect:view</code>, käyttäjä ohjattaisiin osoitteeseen <code>http://palvelu.net/sovellus/view</code>.</p>


          <p>Sovelluksen lopullinen ulkoasu voi olla esimerkiksi seuraavanlainen:</p>


          <p><img src="img/w2e01/more-messages.png" border=1/></p>

          <p>Huom! Projektissa käytettävä Front Controller kuuntelee osoitteen /app/ alle tulevia pyyntöjä. Toteuta sovelluksesi siten, että otat tämän huomioon.</p>


          <h4>Viestien listaaminen</h4>


          <p>Luodaan ensin kontrolleri viestien listaamiselle. Kun tämä osio on valmis, luotu kontrolleri vastaanottaa <code>list</code>-osoitteeseen tulevat pyynnöt, lisää viestit pyynnön attribuutiksi, ja palauttaa FrontControllerServlet-luokalle näytettävän JSP-sivun jossa viestit listataan.</p>


          <p>Toteuta pakkaukseen <code>wad.chat.controller</code> luokka <code>ListMessagesController</code>, joka toteuttaa pakkauksessa <code>wad.chat.controller</code> olevan rajapinnan <code>Controller</code>. ListMessagesController-luokalla on konstruktori, joka saa parametrinaan pakkauksessa <code>wad.chat.service</code> olevan rajapinnan <code>MessageService</code>. Metodin <code>getListenedPath</code> tulee kuunnella polkua <code>list</code>.</p>


          <p>Toteuta metodi <code>processRequest</code> siten, että pyyntöön lisätään attribuutiksi <code>messages</code>, joka sisältää rajapinnan <code>MessageService</code> tarjoaman metodin <code>list</code> avulla saatavat viestit. Palauta lopulta osoite kansiossa <code>WEB-INF/jsp</code> sijaitsevaan <code>list.jsp</code>-sivuun.</p>


          <p>Lisää tämän jälkeen sivulle <code>list.jsp</code> viestien tulostus JSTL:n forEach-toimintoa käyttäen.</p>


          <p>Lisää lopulta juuri luotu kontrolleri <code>FrontControllerServlet</code>-luokan init-metodissa olevaan <code>pathToControllerMap</code>-olioon. Käytä valmista InMemoryMessageService-oliota viestipalveluna.</p>


          <div class="extra">
            <p>
              <ul>
                <li>Vaikka sovelluksessasi ei ole vielä toiminnallisuutta viestien lisäämiseen, voit testata viestien listaustoiminnallisuutta muokkaamalla luokan InMemoryMessageService toteutusta siten, että se sisältää viestejä jo suorituksen alussa.</li>
                <li>Jos et pysty testaamaan sovellustasi koska testit eivät mene läpi, voit silti käynnistää palvelimen. Tähän löytyy tarkempi kuvaus juuri ennen kappaletta 4. Voit myös käynnistää tehtävissä mukana olevan Jetty-palvelimen komentoriviltä komennolla <code>mvn jetty:start</code></li>
              </ul>
            </p>
          </div>
          

          <h4>Viestien lisääminen</h4>


          <p>Toteutetaan seuraavaksi kontrolleri viestien lisäämiselle. Kun tämä osio on valmis, luotu kontrolleri vastaanottaa <code>add-message</code>-osoitteeseen tulevat pyynnöt, lisää viestit MessageService-olioon, ja uudelleenohjaa pyynnön ListMessagesController-luokan kuuntelemaan osoitteeseen.</p>

          <p>Toteuta pakkaukseen <code>wad.chat.controller</code> luokka <code>AddMessageController</code>, joka toteuttaa pakkauksessa <code>wad.chat.controller</code> olevan rajapinnan <code>Controller</code>. AddMessageController-luokalla on konstruktori, joka saa parametrinaan pakkauksessa <code>wad.chat.service</code> olevan rajapinnan <code>MessageService</code>. Metodin <code>getListenedPath</code> tulee kuunnella polkua <code>add-message</code>. Lisää kontrolleri myös Front Controller-servletissä olevaan <code>pathToControllerMap</code>-olioon.</p>

          <p>Toteuta metodi <code>processRequest</code> siten, että pyynnössä lähetettävä parametri <code>message</code> lisätään osaksi MessageService-olion viestejä. Palauta tämän jälkeen merkkijono "redirect:list", jolloin FrontControllerServlet osaa tehdä uudelleenohjauksen osoitteeseen <code>list</code>.</p>

          <p>Lisää tämän jälkeen sivulle <code>list.jsp</code> lomake viestien lähettämiseen add-message -osoitetta kuuntelevaan kontrolleriin. Käytä tekstikentän nimenä <em>ja</em> id:nä merkkijonoa <code>message</code>.</p>

          <p>Testaa lopuksi että sovelluksesi näyttää lähetetyt viestit.</p>


          <h4>Tietoturvan alkeet</h4>


          <p>Nykyinen Chat-sovelluksemme mahdollistaa erilaisia cross-site-scripting -hyökkäyksiä. Esimerkiksi Chat-palvelun hallinnoimaan osoitteeseen liittyvät evästeet ovat ilkeämielisen käyttäjän saatavilla. Testaa chattia lähettämällä sille viestiksi <code>&lt;SCRIPT SRC=http://www.cs.helsinki.fi/u/avihavai/trololo.js&gt;&lt;/SCRIPT&gt;</code>.</p>


          <p>Huomaat että täysin muualla sijainnut lähdekooditiedosto suoritettiin sivullasi.</p>


          <p>Tehdään pieni muutos, jonka avulla saadaan ainakin jonkintasoinen mielenrauha Chat-sovelluksemme tietoturvaan liittyen (myöhemmin huomaamme että mielirauha oli virheellinen...).</p>


          <p>Klassinen ratkaisu on HTML-elementtejä aloittavien ja lopettavien merkkien muuttaminen niitä kuvaaviksi merkkijonoiksi. Esimerkiksi &lt; -merkin näyttämiseksi HTML-koodissa tulee olla merkkijono &amp;lt;</p>


          <p>Koska pyörän uudelleen keksiminen on tässä epäoleellista, käytetään <a href="http://commons.apache.org/lang/" target="_blank">Apache Commons lang</a> -kirjaston <code><a href="http://commons.apache.org/lang/api-3.1/org/apache/commons/lang3/StringEscapeUtils.html" target="_blank">StringEscapeUtils</a></code>-luokan tarjoamaa <code><a href="http://commons.apache.org/lang/api-3.1/org/apache/commons/lang3/StringEscapeUtils.html#escapeHtml4(java.lang.String)" target="_blank">escapeHtml4</a></code>-metodia mahdollisen HTML-koodin muuttamiseksi. Lisää pom.xml -tiedostoon Apache Commons lang -kirjastoriippuvuus:</p>

          <p>Huom! varmista että käytät StringEscapeUtils-luokkaa pakkauksesta <strong>org.apache.commons.lang3</strong> .</p>

<pre class="sh_xml">
  &lt;groupId&gt;org.apache.commons&lt;/groupId&gt;
  &lt;artifactId&gt;commons-lang3&lt;/artifactId&gt;
  &lt;version&gt;3.1&lt;/version&gt;
</pre>


          <p>Lisää lopuksi <code>AddMessageController</code>-luokan processRequest-metodiin toiminnallisuus, jolla muutat HTML-merkit niitä kuvaaviksi merkkijonoiksi.</p>


          <p>Suorita lopuksi testit, ja lähetä sovellus TMC:lle testattavaksi.</p>

</div>

<div class="extra">

  <p>Pelkkä HTML-merkkien muuntaminen niitä kuvaaviksi merkkijonoiksi ei aina riitä sivuston turvaamiseksi. Merkistön muuntamisen voi kiertää helposti esimerkiksi lähettämällä viesti palvelimelle jollain toisella merkistökoodauksella. Vaikka palvelimelle tulevia viestejä ei muunnettaisikaan ennen tallennusta, tyypillisesti palvelimelta käyttäjälle lähetettävät viestit muunnetaan esimerkiksi käyttäjän selaimen toimesta. Tällöin yllä esitetty "tietoturvaratkaisu" ei ratkaise mitään.</p>

  <p>Esimerkiksi HTML-koodi <code>&lt;marquee&gt;web-palvelinohjelmointi&lt;/marquee&gt;</code> näyttää UTF-7 muodossa seuraavalta:</p>

<pre>
+ADw-marquee+AD4-web-palvelinohjelmointi+ADw-/marquee+AD4-
</pre>

</div>


                <h3>Dependency Injection</h3>


                <p>Dependency injection (riippuvuuksien injektointi) on suunnittelumalli, jonka avulla ohjelmiston käyttämät luokat voidaan päättää ajonaikaisesti. Oletetaan, että käytössämme on luokka <code>HelloWorld</code>, jonka ainut metodi on merkkijonon palauttava <code>getMessage</code>.</p>


<pre class="sh_java">
public class HelloWorld {
    public String getMessage() {
        return "Hello World!";
    }
}
</pre>


                <p>Perinteisesti käytetyt oliot luodaan aina ohjelmoijan toimesta <code>new</code>-komennolla:</p>


<pre class="sh_java">
        // ...
        HelloWorld helloWorld = new HelloWorld();
        System.out.println(helloWorld.getMessage());
        // ...
</pre>


                <p>Toinen lähestymistapa on määritellä käytössä olevat luokat erillisessä konfiguraatiotiedostossa. Sovellusta käynnistettäessä konfiguraatiotiedosto luetaan, ja sen perusteella luodaan oliot varastoon, eli <code>oliokontekstiin</code>, josta niitä voi tarvittaessa hakea. Esimerkiksi luokan <code>HelloWorld</code> voisi määritellä erilliseen konfiguraatiotiedostoon siten, että sille määritellään oma tunnus, jonka kautta siihen pääsee käsiksi:</p>


<pre class="sh_xml">
    // ...
    &lt;bean id="helloWorld" class="werkko.HelloWorld" /&gt;
    // ...
</pre>


                <p>Sovellusta käynnistettäessä konfiguraatiotiedoston lataaja luo oliot oliokontekstiin, josta niihin pääsee käsiksi.</p>


<pre class="sh_java">
        // ...
        // luodaan context-olio, joka luo konfiguraatiotiedostossa (beans.xml)
        // määritellyt oliot oliokontekstiin
        ApplicationContext context = new ClassPathXmlApplicationContext("beans.xml");
        
        // nyt oliota ei luoda itse, vaan sitä käytetään oliokontekstin kautta
        HelloWorld helloWorld = (HelloWorld) context.getBean("helloWorld");
        System.out.println(helloWorld.getMessage());
        // ...
</pre>


                <p><em>Ok, mutta eikö tämä tee vaan kaikesta paljon vaikeampaa?</em></p>


                <p>Ensisilmäyksellä koodi vaikuttaa hyvin paljon monimutkaisemmalta. Pohditaan kuitenkin tämän lähestymistavan hyötyjä.</p>

                <p>
                  <ol>

                    <li>Rajapintojen käyttäminen ja toteutusten vaihtaminen. Jos sovellus käyttää rajapintoja, voidaan todellinen toteutus piilottaa konfiguraation taakse. Tällöin komponentin toteuttajan ei tarvitse millään tavalla tietää rajapinnan toteuttavan luokan todellisesta toteutuksesta.</li>

                    <li>Sovellusten testaaminen. Sovelluksia testatessa halutaan usein käyttää ns. mock-olioita, joiden avulla voidaan tarkistaa että metodit ja luokat toimivat oikein. Käytettävien olioiden vaihtaminen onnistuu konfiguraatiotiedostoa vaihtamalla.</li>

                    <li>Olioiden parametrien injektointi. Koska olioiden luominen onnistuu konfiguraatiotiedoston avulla, voidaan olioiden parametrit myös määritellä konfiguraatiotiedostossa. Esimerkiksi tietokantaa käyttävien sovellusten testaamisessa kantana ei kannata käyttää tuotantokantaa. Tietokannan vaihtaminen onnistuu konfiguraatiotiedoston tai -parametrin vaihdolla.</li>

                  </ol>
                </p>


<div class="extra mr-bean">
  <p><strong>Mikä ihmeen Bean?</strong></p>

  <p>Bean on uudelleenkäytettävä komponentti, jota käytetään tiedon käsittelyyn. Beanit ovat käytännössä tavallisia Java-luokkia, joilla on ennaltamääritelty nimeämiskäytäntö: tietoa asettavat metodit ovat muotoa <code><em>set</em>Arvo(...)</code>, ja tietoa pyytävät metodit ovat muotoa <code><em>get</em>Arvo()</code>.</p>

  <p>Bean-luokilla on kolme kriteeriä:</p>

  <p>
    <ol>

      <li>Luokalla tulee olla parametriton konstruktori. Tämän avulla sovelluskehykset pystyvät luomaan olioista ilmentymiä helposti.</li>

      <li>Luokan attribuutteihin tulee päästä käsiksi <code>get</code>- ja <code>set</code>-tyyppisillä metodeilla. Totuusarvon palauttavissa metodeissa käytetään <code>get</code>-etuliitteen sijaan <code>is</code>-etuliitettä. Tämän nimeämiskäytännön takia sovelluskehykset pääsevät olion attribuutteihin käsiksi ja voivat asettaa attribuutteja.</li>
      
      <li>Bean-tyyppisten luokkien tulee toteuttaa <code>Serializable</code>-rajapinta, jonka avulla olion tila voidaan tallentaa tarvittaessa.</li>

    </ol>
  </p>


  <p>Näiden nimeämiskäytäntöjen takia esimerkiksi EL-kieli toimii. Luistamme usein kolmannesta vaatimuksesta tällä kurssilla.</p>

</div>


                <h4>Dependency Injection ja Spring</h4>


                <p>Spring on sovelluskehys, jossa on valmiudet riippuvuuksien injektointiin. Springin oliokontekstitoiminnallisuuden saa projektin käyttöön lisäämällä seuraavan riippuvuuden pom.xml-tiedostoon:</p>


<pre class="sh_xml">
        &lt;dependency&gt;
            &lt;groupId&gt;org.springframework&lt;/groupId&gt;
            &lt;artifactId&gt;spring-context&lt;/artifactId&gt;
            &lt;version&gt;3.1.2.RELEASE&lt;/version&gt;
        &lt;/dependency&gt;
</pre>


                <p>Olioiden kontekstiin lataamiseen käytettävä konfiguraatiotiedosto näyttää seuraavanlaiselta. Tiedostossa määritellään käytettävät nimiavaruudet sekä käyttöön ladattavat <em>beanit</em>. Alla lataamme pakkauksessa <code>werkko</code> olevan <code>HelloWorld</code>-olion oliokontekstiin, josta siihen pääsee käsiksi tunnuksella <code>helloWorld</code>.</p> 


<pre class="sh_xml">
&lt;?xml version="1.0" encoding="UTF-8"?&gt; 
&lt;beans xmlns="http://www.springframework.org/schema/beans" 
       xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" 
       xsi:schemaLocation="http://www.springframework.org/schema/beans 
                           http://www.springframework.org/schema/beans/spring-beans-3.0.xsd"&gt; 

    &lt;bean id="helloWorld" class="werkko.HelloWorld" /&gt;
&lt;/beans&gt;
</pre>

                <p>Konfiguraatiotiedosto tulee tallentaa sijaintiin, josta Spring löytää sen. Mavenia käytettäessä kansion <code>src/main/resources</code> (NetBeansissa kansio "Other sources") tiedostot ovat projektin käytössä. Konfiguraation saa ladattua esimerkiksi Springin <code><a href="http://static.springsource.org/spring/docs/current/javadoc-api/org/springframework/context/support/ClassPathXmlApplicationContext.html" target="_blank">ClassPathXmlApplicationContext</a></code>-luokan avulla seuraavasti.</p>


<pre class="sh_java">
import org.springframework.context.ApplicationContext;
import org.springframework.context.support.ClassPathXmlApplicationContext;

        // ...
        // luodaan context-olio, joka luo konfiguraatiotiedostossa (beans.xml)
        // määritellyt oliot oliokontekstiin
        ApplicationContext context = new ClassPathXmlApplicationContext("beans.xml");
        
        // helloWorld-olio on nyt löydettävissä oliokontekstista
        HelloWorld helloWorld = (HelloWorld) context.getBean("helloWorld");
        System.out.println(helloWorld.getMessage());
        // ...
</pre>


                <p>Myös olion attribuuttien asetus onnistuu konfiguraatiotiedoston avulla. Muutetaan luokkaa Hello World siten, että sillä on myös metodi <code>setMessage</code>.</p>


<pre class="sh_java">
public class HelloWorld {
    private String message;

    public String getMessage() {
        return this.message;
    }

    public void setMessage(String message) {
        this.message = message;
    }
}
</pre>


                <p>Ominaisuuksien asettaminen tapahtuu <code>property</code>-elementin avulla. Alla määritellään oliokontekstia varten olio <code>helloWorld</code>, jonka metodia <code>setMessage</code> kutsutaan arvolla <code>Hullo!</code> kun olio on luotu.</p>


<pre class="sh_xml">
    &lt;bean id="helloWorld" class="werkko.HelloWorld"&gt; 
        &lt;property name="message" value="Hullo!"/&gt; 
    &lt;/bean&gt;
</pre>


                <p>Olioille voi luonnin yhteydessä myös antaa viitteitä toisiin olioihin. Luodaan luokka <code>HelloWorldContainer</code>, joka sisältää <code>HelloWorld</code>-olion.</p>


<pre class="sh_java">
// ...
public class HelloWorldContainer {
    private HelloWorld helloWorld;

    // muut metodit ym
    public void setHelloWorld(HelloWorld helloWorld) {
        this.helloWorld = helloWorld;
    }
}
</pre>


                <p>HelloWorld-olion voi injektoida HelloWorldContainer-oliolle seuraavasti:</p>


<pre class="sh_xml">
    &lt;bean id="helloWorld" class="werkko.HelloWorld"&gt; 
        &lt;property name="message" value="Hullo!"/&gt; 
    &lt;/bean&gt;

    &lt;bean id="helloWorldContainer" class="werkko.HelloWorldContainer"&gt; 
        &lt;property name="helloWorld" ref="helloWorld"/&gt; 
    &lt;/bean&gt;
</pre>

                <p>Käytännössä yllä luodaan oliokontekstiin kaksi oliota: <code>HelloWorld</code> tunnuksella <code>helloWorld</code> ja <code>HelloWorldContainer</code> tunnuksella <code>helloWorldContainer</code>. Kun olio <code>helloWorldContainer</code> on luotu, sen <code>setHelloWorld</code>-metodia kutsutaan siten, että se saa parametrina viitteen aiemmin luotuun <code>helloWorld</code>-olioon.</p>


<div class="tehtavat">
  <h3>Application Context</h3>

  <hr/>
  <p><strong>Huom!</strong> Kun aloitat tehtävän tekemisen lataa heti tarvittavat kirjastot valitsemalla oikealla hiirennäppäimellä projektin "Dependencies"-kansion ja vaihtoehdon "Download Declared Dependencies". Tämän pitäisi ladata tarvittavat kirjastot käyttöösi.</p>

  <p>Kirjastojen lataaminen estää tilanteita, joissa NetBeans saattaa ehdottaa riippuvuuksia, joita ei löydy käytössä olevista dependency-palvelimista. Esimerkiksi Springin versio <code>3.2.0.BUILD-SNAPSHOT</code> ei ole käytössämme vaikka NetBeans sitä ehdottaakin.</p>

  <hr/>

  <p>Lisätään tässä tehtävässä muutama olio sovelluksen oliokontekstiin. Sovellus ei ole web-sovellus, sillä haluamme lähteä liikkeelle pienistä asioista.</p>


  <p>Tehtävässä tulee valmiina luokat <code>HelloApplicationContext</code> ja <code>HelloInjectingProperties</code>. Projektiin on konfiguroitu valmiiksi riippuvuus Springin oliokontekstiin.</p>


  <h4>Hello Application Context</h4>


  <p>Lisää kansiossa <code>src/main/resources</code> (NetBeansissa kansio "Other sources") olevaan <code>beans.xml</code>-tiedostoon uusi bean-elementti, jonka tunnus on <code>helloApplicationContext</code> ja jonka luokka on <code>wad.applicationcontext.HelloApplicationContext</code>.</p>


  <p>Lisää myös lähdekooditiedostoissa olevaan <code>App</code>-lähdekooditiedostoon <code>HelloApplicationContext</code>-olion noutaminen oliokontekstista. Tulosta tämän jälkeen olion sisältämä viesti standarditulostusvirtaan (System.out...).</p>


  <h4>Hello Property Setting</h4>


  <p>Lisää <code>beans.xml</code>-tiedostoon bean, jonka tunnus on <code>helloInjectingProperties</code> ja luokka on <code>HelloInjectingProperties</code>. Anna luokalle parametri (property) nimeltä <code>message</code>, jonka arvo on <code>My Cool Property</code>.</p>


  <p>Lisää tämän jälkeen <code>App</code>-lähdekooditiedostoon <code>HelloInjectingProperties</code>-olion noutaminen oliokontekstista. Tulosta tämän jälkeen olion sisältämä viesti standarditulostusvirtaan (System.out...).</p>


  <p>Sovelluksen tulostuksen pitäisi olla seuraavanlainen:</p>


<pre>
Hello Application Context!
My Cool Property
</pre>


  <p>Kun testit menevät läpi, lähetä sovellus TMC:lle testattavaksi.</p>

</div>



<!--

automaattine

   * annotaatioiden käyttö konfiguraatioissa

   * bean injektio automaattisesti

       tehtävä W2E04: autowired konffaus, ihan perussofta, ei webissä  (arto)
       pohja: testing/hello_spring_annotations

http://static.springsource.org/spring/docs/3.0.x/spring-framework-reference/html/beans.html#beans-annotation-config

http://static.springsource.org/spring/docs/3.0.x/spring-framework-reference/html/beans.html#beans-classpath-scanning
-->


                <h3>Inversion of Control ja automaattinen riippuvuuksien haku</h3>


                <p>Käytännössä riippuvuuksien injektoinnissa on kyse kontrollin antamisesta sovelluskehykselle (Inversion of Control). Sen sijaan, että käyttäjä loisi itse ohjelman tarvitsemat oliot, olioiden luominen ja parametrien asettaminen tapahtuu sovelluskehyksen toimesta (käyttäjän määrittelemän konfiguraation pohjalta). Inversion of Controlin ja Dependency Injectionin hyödyt ovat mm.:</p>

                <p>
                  <ol>
                    <li>Ohjelman komponentteja voi testata helposti yksitellen: testatessa käytettäviä ominaisuuksia voi injektoida tarvittaessa.</li>

                    <li>Ohjelman kompleksisuus vähenee: eri komponentit voivat tuntea toiset komponentit vain rajapintojen kautta. Konkreettisia toteutuksia ei tarvitse nähdä, ja <code>new</code>-kutsuja ei juurikaan tarvitse tehdä.</li>

                    <li>Ohjelman käyttämien komponenttien vaihtaminen on helppoa.</li>

                  </ol>
                </p>

<div class="pohdi">
  <p>Tutustu Martin Fowlerin artikkeliin <em><a href="http://www.martinfowler.com/articles/injection.html" target="_blank">Inversion of Control Containers and the Dependency Injection pattern</a>.</em></p>

  <p>Miten käsitteet "Inversion of Control", "Dependency Injection" ja "Service Locator" liittyvät toisiinsa artikkelin perusteella?</p>

  <p>&nbsp;</p>
</div>


                <p>Joissain sovelluskehyksissä riippuvuuksia ei tarvitse juurikaan konfiguroida, vaan sovelluskehys osaa päätellä ne ajonaikaisesti esimerkiksi annotaatioiden tai luokkahierarkian perusteella.</p>


                <h4>Case: Spring</h4>


                <p>Spring tarjoaa toiminnallisuuden beanien automaattiseen lataamiseen ja konfigurointiin. Käyttämällä automaattista komponenttien hakua (<code>component-scan</code>), sovellus osaa etsiä käytössä olevat komponentit, ja injektoida niitä tarvittaessa.</p>
                

                <p>Jotta Spring ymmärtää, että luokka tulee ladata kontekstiin, tulee luokalle lisätä <code>@Component</code>-annotaatio. Esimerkiksi luokan <code>HelloWorld</code> saa ladattua automaattisesti oliokontekstiin, jos sillä on annotaatio <code>@Component</code>.</p>


<pre class="sh_java">
@Component
public class HelloWorld {

    public String getMessage() {
        return "Hello World!";
    }
}
</pre>


                <p>Luokkien automaattisen lataamisen saa kytkettyä päälle asettamalla <code>beans.xml</code>-dokumenttiin <code>component-scan</code>-elementti, jolle annetaan parametrina pakkaus, josta olioita etsitään. Etsintä tapahtuu myös alipakkauksista.</p>


<pre class="sh_xml">
&lt;?xml version="1.0" encoding="UTF-8"?&gt; 
&lt;beans xmlns="http://www.springframework.org/schema/beans" 
       xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" 
       xmlns:context="http://www.springframework.org/schema/context"
       xsi:schemaLocation="http://www.springframework.org/schema/beans 
           http://www.springframework.org/schema/beans/spring-beans-3.0.xsd
           http://www.springframework.org/schema/context 
           http://www.springframework.org/schema/context/spring-context-3.0.xsd"&gt; 

    &lt;context:component-scan base-package="werkko"/&gt;
&lt;/beans&gt;
</pre>


                <p>Nyt kaikki pakkauksen <code>werkko</code> ja sen alipakkauksissa olevat <em>annotoidut</em> luokat ladataan valmiiksi oliokontekstiin. Huomaa, että konfiguraatiotiedostossa on otettu käyttöön nimiavaruus <code>context</code>, joka sisältää kontekstin käsittelyyn liittyviä konfiguraatioelementtejä.</p>


                <p>Myös viitteiden asettaminen onnistuu automaattista konfiguraatiota käytettäessä. Annotaatiolla <code>@Autowired</code> voidaan määritellään attribuutti, joka tulee asettaa automaattisesti. Muokataan aiemmin nähtyä luokkaa <code>HelloWorldContainer</code> siten, että se ladataan automaattisesti oliokontekstiin, ja että sen attribuutti <code>HelloWorld</code> asetetaan automaattisesti.</p>


<pre class="sh_java">
// ...
@Component
public class HelloWorldContainer {
    @Autowired
    private HelloWorld helloWorld;

    // muut metodit ym
}
</pre>

                <p>Annotaation <code>@Autowired</code> voi asettaa myös osaksi set-metodia.</p>

<pre class="sh_java">
// ...
@Component
public class HelloWorldContainer {
    private HelloWorld helloWorld;

    // muut metodit ym

    @Autowired
    public void setHelloWorld(HelloWorld helloWorld) {
        this.helloWorld = helloWorld;
    }
}
</pre>


                <p>Oliokontekstissa olevien olioiden tunnukset määritellään oletuksena automaattisesti luokan tai sen perintähierarkiassa olevien luokkien nimen perusteella. Yllä käytössämme olisi oliot <code>helloWorld</code> (luotu luokasta <code>HelloWorld</code>) ja <code>helloWorldContainer</code> (luotu luokasta <code>HelloWorldContainer</code>). Käytännössä oliokontekstiin luotavan olion oletusnimi on sama kuin luokan nimi, mutta ensimmäinen kirjain pienellä.</p>

                <p>Olioiden tunnukset voidaan myös määritellä käsin. Annotaatiolle <code>@Component</code> voi antaa parametrina merkkijonon, joka määrittelee olion nimen, esim. <code>@Component("hello")</code>. Jos <code>@Autowired</code>-annotaatiolle haluaa käyttöön tietyn luokan ilmentymän, tulee sen kaveriksi määritellä erillinen annotaatio <code>@Qualifier</code>, joka saa parametrina käytettävän olion tunnuksen:</p>

<pre class="sh_java">
    // ...
    @Autowired
    @Qualifier("hello")
    public void setHelloWorld(HelloWorld helloWorld) {
        this.helloWorld = helloWorld;
    }
    // ...
</pre>


                <p>Ylläolevassa esimerkissä metodia <code>setHelloWorld</code> yritettäisiin kutsua antamalla sille parametrina oliokontekstista tunnuksella <code>hello</code> löytyvä olio.</p>


<div class="tehtavat">
  <h3>Autowiring Dependencies</h3>

  <p>Harjoitellaan seuraavaksi omien automaattisesti oliokontekstiin ladattavien luokkien luomista.</p>


  <h4>MessagingApplication</h4>


  <p>Luo pakkaukseen <code>wad.autowiring</code> luokka <code>MessagingApplication</code>. Luokalla tulee olla metodi <code>public void printMessage()</code>, joka tulostaa viestin <code>"Hello there"</code> standarditulostusvirtaan. Kun olet luonut luokan, lisää sille vielä annotaatio <code>@Component</code> pakkauksesta <code>org.springframework.stereotype</code>.</p>


  <p>Konfiguroi tämän jälkeen tiedostoon <code>beans.xml</code> automaattinen olioiden oliokontekstiin lataaminen pakkauksesta <code>wad</code> ja sen alipakkauksista.</p>


  <p>Kun konfiguraatio on kunnossa, muokkaa luokkaa <code>App</code> siten, että haet luokan <code>MessagingApplication</code> ilmentymän oliokontekstista. Kutsu lopulta MessagingApplication-olion metodia <code>printMessage</code>.</p>


  <h4>MessageContainer</h4>


  <p>Luo pakkaukseen <code>wad.autowiring</code> luokka <code>InMemoryMessageContainer</code>, joka toteuttaa rajapinnan <code>MessageContainer</code>. Metodin <code>public String getMessage()</code> tulee palauttaa merkkijonon <code>"Hello there"</code>. Kun olet luonut luokan, lisää sille vielä annotaatio <code>@Component</code> pakkauksesta <code>org.springframework.stereotype</code>.</p>


  <p>Koska beans.xml on konfiguroitu lataamaan oliot automaattisesti oliokontekstiin, on myös annotaatiolla @Component merkitystä InMemoryMessageContainer-oliosta ilmentymä. Lisätään se osaksi <code>MessagingApplication</code>-luokkaa.</p>


  <p>Lisää luokalle <code>MessagingApplication</code> oliomuuttuja <code>MessageContainer</code>, sekä sen asettava metodi <code>setMessageContainer</code>. Lisää metodille <code>setMessageContainer</code> annotaatio <code>@Autowired</code>. Tämä tarkoittaa että sovelluskehys yrittää automaattisesti lisätä siihen sopivan olion.</p>


  <p>Muokkaa MessagingApplication-luokkaa vielä siten, että metodissa <code>printMessage</code> tulostetaan metodilla <code>setMessageContainer</code> asetetun <code>messageContainer</code>-olion <code>getMessage</code>-metodin palauttama viesti.</p>


  <p>Testaa vielä lopulta sovelluksen toimintaa, ja lähetä se TMCn tarkastettavaksi.</p>

</div>



                <h2>Spring ja Web</h2>


                <p>Spring on sovelluskehys, joka tarjoaa hyödyllisiä apuvälineitä Java (ja .NET)-sovellusten toteuttamisen ja testaamisen helpottamiseksi. Se perustuu Dependency Injection -suunnittelumalliin, joka mahdollistaa sovelluksen komponenttien toisistaan riippumattoman suunnittelun ja toteutuksen. Spring on komponenttipohjainen ja tarjoaa tukea mm. tietokanta-, web-, ja mobiilisovellusten toteuttamiseen.</p>


                <p>Tutustutaan seuraavaksi yksinkertaisen web-sovelluksen toteuttamiseen Springin avulla: käytämme materiaalissa Springin versiota <code>3.1.2.RELEASE</code>.</p>


                <h3>Hello Spring Web</h3>


                <p>Springin web-toiminnallisuuden peruskivi on Front Controller-suunnittelumalli sekä Dependency Injection. Spring-sovelluskehyksen web-toiminnallisuuden saa käyttöön lisäämällä projektin pom-tiedostoon seuraavan riippuvuuden.</p>

<pre class="sh_xml">
    &lt;dependency&gt;
        &lt;groupId&gt;org.springframework&lt;/groupId&gt;
        &lt;artifactId&gt;spring-webmvc&lt;/artifactId&gt;
        &lt;version&gt;3.1.2.RELEASE&lt;/version&gt;
    &lt;/dependency&gt;
</pre>


                <p>Oletamme että käytössä on jo <code>spring-context</code>-riippuvuus.</p>


                <p>Spring tarjoaa oman Front Controller-toteutuksen nimeltä <code><a href="http://static.springsource.org/spring/docs/current/javadoc-api/org/springframework/web/servlet/DispatcherServlet.html" target="_blank">DispatcherServlet</a></code>, jonka tehtävänä on ottaa sovellukseen tulevat pyynnöt kiinni, ja ohjata ne sovelluksen omille kontrollereille. Kun yllä mainitut riippuvuudet on lisätty, voi <code>DispatcherServlet</code>-luokan määritellä projektiin liittyvään <code>web.xml</code>-tiedostoon.</p>


<pre class="sh_xml">
    &lt;servlet&gt;
        &lt;servlet-name&gt;front-controller&lt;/servlet-name&gt;
        &lt;servlet-class&gt;org.springframework.web.servlet.DispatcherServlet&lt;/servlet-class&gt;
        &lt;load-on-startup&gt;1&lt;/load-on-startup&gt;
    &lt;/servlet&gt;
    
    &lt;servlet-mapping&gt;
        &lt;servlet-name&gt;front-controller&lt;/servlet-name&gt;
        &lt;url-pattern&gt;/app/*&lt;/url-pattern&gt;
    &lt;/servlet-mapping&gt;
</pre>

                <p>Servletin <code>front-controller</code> määrittelyssä oleva elementti <code>load-on-startup</code> kertoo, että servlet tulee ladata käyttöön heti sovellusta käynnistettäessä. Kaikki sovelluksen polkuun <code>/app/</code> ja sen alle tulevat pyynnöt ohjautuvat <code>front-controller</code>-nimiselle servletille.</p>


                <p>Tämän lisäksi haluamme konfiguroida Springin lataamaan riippuvuuksia automaattisesti. Springin DispatcherServletin lataamisen laukaisema prosessi etsii oletuksena konfiguraatiotiedostoa, jonka nimi on <code>${servletin-nimi}-servlet.xml</code>. Yllä servlettimme nimi on <code>front-controller</code>, joten tiedoston nimi tulee olla <code>front-controller-servlet.xml</code>. Tiedosto sijaitsee samassa paikassa <code>web.xml</code>-tiedoston kanssa (<code>WEB-INF</code> -kansiossa).</p>


                <p>Luodaan <code>WEB-INF</code> -kansioon tiedosto <code>front-controller-servlet.xml</code>, jossa sanotaan että sovellukseen liittyviä komponentteja tulee etsiä pakkauksesta <code>werkko</code> ja sen alipakkauksista. Alla oleva konfiguraatio lienee tutun näköinen.</p>


<pre class="sh_xml">
&lt;?xml version="1.0" encoding="UTF-8"?&gt;
&lt;beans xmlns="http://www.springframework.org/schema/beans"
       xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
       xmlns:context="http://www.springframework.org/schema/context"
       xsi:schemaLocation="http://www.springframework.org/schema/beans
           http://www.springframework.org/schema/beans/spring-beans-3.0.xsd
           http://www.springframework.org/schema/context
           http://www.springframework.org/schema/context/spring-context-3.0.xsd"&gt;

    &lt;context:component-scan base-package="werkko" /&gt;
&lt;/beans&gt;
</pre>


                <p>Spring tunnistaa kontrolleriluokat annotaation <code>@Controller</code> perusteella. Annotaatio <code>@Controller</code> on web-sovelluksen kontrollereita varten luotu erikoistapaus annotaatiosta <code>@Component</code>. Luodaan pakkaukseen <code>werkko</code> luokka <code>HelloController</code>:</p>


<pre class="sh_java">
package werkko;

import org.springframework.stereotype.Controller;

@Controller
public class HelloController {

}
</pre>


                <p>Web-sovellusta käynnistettäessä huomaamme palvelimen logeista että Spring lataa yllä olevan luokan käyttöönsä (bean <code>helloController</code>):</p>


<pre>
INFO: Pre-instantiating singletons in ....DefaultListableBeanFactory..: defining beans [helloController, ..
</pre>


                <p>Yllä olevasta kontrollerista ei kuitenkaan ole juurikaan hyötyä. Siinä ei esimerkiksi käsitellä yhtäkään pyyntöä. Lisätään seuraavaksi toiminnallisuutta pyynnön käsittelyyn.</p>


                <p>Käyttäjän tekemät pyynnöt voidaan ohjata kontrolleriluokissa oleviin metodeihin annotaatioiden perusteella. Annotaatio <code>@RequestMapping</code> asetetaan pyynnön prosessoivalle metodille. Se saa parametrinaan polun, johon tulevat pyynnöt ohjataan kyseiselle metodille. Lisätään luokkaan <code>HelloController</code> metodi <code>processRequest</code>, joka saa parametrinaan <code>HttpServletRequest</code> ja <code>HttpServletResponse</code>-oliot. Metodilla <code>processRequest</code> on annotaatio <code>@RequestMapping("hello")</code> -- käytännössä siis kaikki sovelluksen <code>/app/hello</code> -polkuun tulevat pyynnöt ohjataan tälle metodille. Alkuosa <code>/app/</code> johtuu siitä, että DispatcherServlet kuuntelee pyyntöjä osoitteeseen <code>/app/*</code>.</p>


<pre class="sh_java">
package werkko;

import java.io.IOException;
import javax.servlet.http.HttpServletRequest;
import javax.servlet.http.HttpServletResponse;
import org.springframework.stereotype.Controller;
import org.springframework.web.bind.annotation.RequestMapping;

@Controller
public class HelloController {

    @RequestMapping("hello")
    public void processRequest(HttpServletRequest request, HttpServletResponse response) {
        try {
            response.getWriter().write("Hello World!");
        } catch (IOException ex) {
            System.out.println("Ei onnistunut!");
        }
    }
}
</pre>

                <p>Nyt kun sovelluksen polkuun <code>/app/hello</code> tekee pyynnön, näemme seuraavanlaisen näkymän:</p>


<div class="naytto">
Hello World!
</div>


                <h4>Näkymän lisääminen</h4>

                
                <p>Puhuimme jo aiemmin siitä, että näkymän pitäisi olla JSP-sivuilla. Yllä olevaa sovellusta voi muokata siten, että se ohjaa pyynnön JSP-sivulle RequestDispatcher-oliota käyttäen. Esimerkiksi, jos käytössämme on kansiossa <code>/WEB-INF/jsp/</code> oleva <code>hello.jsp</code>-tiedosto, voi pyynnön ohjata sivulle kuten aiemminkin:</p>


<pre class="sh_java">
    // ...
    @RequestMapping("hello")
    public void processRequest(HttpServletRequest request, HttpServletResponse response) {
        request.getRequestDispatcher("/WEB-INF/jsp/hello.jsp").forward(request, response); 
    }
    // ...
</pre>


                <p>Springillä on myös oma mekanismi näkymien hallintaan. Luokka <code><a href="http://static.springsource.org/spring/docs/current/javadoc-api/org/springframework/web/servlet/view/InternalResourceViewResolver.html" target="_blank">InternalResourceViewResolver</a></code> tarjoaa toiminnallisuuden näytettävän sivun päättelyyn, mm. pyyntöjen uudelleenohjaamisen ja JSP-sivujen näyttämisen. InternalResourceViewResolver konfiguroidaan springin konfiguraatiotiedostossa, eli meidän tapauksessa tiedostossa <code>front-controller-servlet.xml</code>.</p>

<pre class="sh_xml">
    &lt;bean class="org.springframework.web.servlet.view.InternalResourceViewResolver" /&gt; 
</pre>

                <p>Nyt pyyntöjä prosessoivat metodit voivat palauttaa merkkijonon, joka kertoo näytettävän sivun sijainnin. Esimerkiksi edellinen <code>processRequest</code>-metodi voidaan muuttaa seuraavaan muotoon.</p>


<pre class="sh_java">
    // ...
    @RequestMapping("hello")
    public String processRequest(HttpServletRequest request, HttpServletResponse response) {
        return "/WEB-INF/jsp/hello.jsp";
    }
    // ...
</pre>


                <p>Koska sivujen sijainnit ovat yleensä hyvin samankaltaiset, voi <code>InternalResourceViewResolver</code>-luokalle määritellä haettavan tiedoston sijainnin tarkemmin. Määrittelemällä parametrit <code>prefix</code> ja <code>suffix</code>, olio käyttää niitä osana näytettävän sivun hakemista. Muunnetaan <code>front-controller-servlet.xml</code> -tiedostossa oleva konfiguraatio seuraavanlaiseksi:</p>


<pre class="sh_xml">
    &lt;bean class="org.springframework.web.servlet.view.InternalResourceViewResolver"&gt; 
        &lt;property name="prefix" value="/WEB-INF/jsp/" /&gt; 
        &lt;property name="suffix" value=".jsp" /&gt; 
    &lt;/bean&gt;
</pre>


                <p>Nyt metodin <code>processRequest</code> voi muuttaa seuraavanlaiseksi.</p>


<pre class="sh_java">
    // ...
    @RequestMapping("hello")
    public String processRequest(HttpServletRequest request, HttpServletResponse response) {
        return "hello";
    }
    // ...
</pre>
                <p>Palautettava sivu päätellään lisäämällä konfiguraatiotiedoston prefix-osa metodin palauttaman merkkijonon alkuun, ja suffix osa merkkijonon loppuun. Käytännössä merkkijonosta <code>hello</code> tulee merkkijono <code>/WEB-INF/jsp/hello.jsp</code></p>


<div class="tehtavat">

  <h3>Spring Web Hello World</h3>

  <p>Tässä tehtävässä rakennetaan Spring WebMVC-kehyksen avulla toimiva dynaaminen verkkosivu. Tehtävä koostuu controller-luokasta sekä JSP-sivusta.</p>

  <h4>HelloWorldController</h4>

  <p>Tehtäväpohjassa on valmiina Maven-riippuvuus Springin ydintoiminnallisuudelle (<code>spring-context</code>), jota käytettiin jo aiemmissa tehtävissä. Jotta Springin WebMVC-ominaisuuksia voisi käyttää, täytyy sitä varten lisätä muutama lisämoduuli riippuvuuksiin. Kaikkien Spring-kehyksen riippuvuuksien <code>groupId</code>-tunniste on <code>org.springframework</code>. Spring WebMVC-riippuvuuden <code>artifactId</code>-tunniste on:
    <ul>
      <li><code>spring-webmvc</code></li>
    </ul>
  </p>

  <p>Lisää riippuvuus <code>pom.xml</code>-tiedostoon. Huom! Käytä Springin versiota <code>3.1.2.RELEASE</code>.</p>

  <p>Luo pakkaukseen <code>wad.spring.web.helloworld</code> luokka <code>HelloWorldController</code>. Springille täytyy kertoa, että kyseessä on controller-luokka, joten lisää sille vielä annotaatio <code>@Controller</code> pakkauksesta <code>org.springframework.stereotype</code>.</p>


  <p>Luokalla <code>HelloWorldController</code> tulee olla metodi <code>public String processRequest(HttpServletRequest request, HttpServletResponse response)</code>, joka käsittelee sovellukselle tulevia HTTP-pyyntöjä. Lisäksi Springille täytyy kertoa mitä URL-polkua tai -polkuja metodi käsittelee. Määrittele metodille annotaatio <code>@RequestMapping</code>, jolla on parametrina <code>"*"</code>. Metodi siis käsittelee kaikkia DispatcherServlet-olion saamia pyyntöjä. Huomaa että DispatcherServlet kuuntelee taas <code>/app/</code>-polkua ja sen alle tulleita pyyntöjä.</p>


  <p><em>Käytännössä metodi ja sen annotaatio vastaavat yhdessä Chat-tehtävää varten tehtyä yksittäistä <code>Controller</code>-rajapinnan toteuttavaa luokkaa.</em></p>


  <p>Metodin <code>processRequest</code> tulee asettaa <code>HttpServletRequest</code>-oliolle attribuutti <code>message</code>, jonka arvo on <code>"Great Scott!"</code>. Metodin tulee lisäksi palauttaa merkkijono, <code>/WEB-INF/jsp/hello.jsp</code> (sivua ei vielä ole).</p>


  <p>Konfiguroi lopuksi tiedostoon <code>front-controller-servlet.xml</code> olioiden automaattinen lataaminen oliokontekstiin pakkauksesta <code>wad</code> ja sen alipakkauksista.</p>


  <h4>View: hello.jsp</h4>


  <p>Jotta Spring pystyisi tulkitsemaan Controller-luokkien metodien palauttamat merkkijonot oikealla tavalla näkymien JSP-sivujen nimiksi, täytyy Springin konfiguraatioon lisätä sopiva <code>ViewResolver</code>. JSP-sivut paketoidaan yleensä lähdekoodin kääntämisen yhteydessä samaan JAR- tai WAR-paketista Java-luokkien tavukoodin kanssa. JSP-sivujen hakeminen pakettien sisältä onnistuu <code>ViewResolver</code>-luokan <code>org.springframework.web.servlet.view.InternalResourceViewResolver</code> avulla.</p>


  <p>Konfiguroi tiedostoon <code>front-controller-servlet.xml</code> uusi <em>bean</em> luokasta <code>org.springframework.web.servlet.view.InternalResourceViewResolver</code>, ja aseta sille kentän <code>prefix</code> arvoksi <code>/WEB-INF/jsp/</code> ja kentän <code>suffix</code> arvoksi <code>.jsp</code>.</p>


  <p>Luo hakemistoon <code>/WEB-INF/jsp</code> JSP-sivu <code>hello.jsp</code>. Hakemisto löytyy NetBeansin projektinäkymästä Web Pages-kansion alta. JSP-sivulla tulee olla teksti <code>Hello World!</code> ja EL-kielellä tehty viittaus <code>processRequest</code>-metodin asettamaan attribuuttiin <code>message</code>, jotta viesti näytetään sivulla.</p>


  <p>Muuta lopuksi luokan <code>HelloWorldController</code> palauttamaa merkkijonoa siten, että juuri konfiguroitu InternalResourceViewResolver oikeasti löytää JSP-sivun.</p>


</div>


                <h3>Pyyntöjä käsittelevät metodit</h3>


                <p>Kontrolleriluokissamme on käytetty metodia <code>processRequest(HttpServletRequest request, HttpServletResponse response)</code> pyyntöjen käsittelyyn. Nimi <code>processRequest</code> on tuttu jo tehtävistä ennen Springiä. Mutta. Pyyntöä käsittelevän metodin nimen ei ole pakko olla <code>processRequest</code>, eikä sen tarvitse saada parametreinaan <code>HttpServletRequest</code> ja <code>HttpServletResponse</code>-olioita.</p>


                <p>Spring päättelee annotaation <code><a href="http://static.springsource.org/spring/docs/current/javadoc-api/org/springframework/web/bind/annotation/RequestMapping.html" target="_blank">@RequestMapping</a></code> perusteella metodin, johon pyyntö ohjataan. Metodille määriteltävät parametrit ovat oikeastaan melko vapaat: parametriksi voi määritellä esimerkiksi <code>Writer</code>-olion, johon kirjoitettu teksti palautetaan käyttäjälle. <code>HttpServletRequest</code>- tai <code>HttpServletRequest</code>-olioita käytetään hyvin harvoin parametreina --  pyyntöä käsittelevä metodi voi myös olla parametriton. Seuraava metodi tuottaa käytännössä saman lopputuloksen kuin aiemmin näkemämme pyynnön JSP-sivulla ohjaava <code>processRequest</code>-metodi.</p> 


<pre class="sh_java">
    // ...
    @RequestMapping("hello")
    public String hello() {
        return "hello";
    }
    // ...
</pre>


                <h4>Parametri Model</h4>


                <p>Ehkäpä oleellisin ja eniten käytetty parametri on <code><a href="http://static.springsource.org/spring/docs/current/javadoc-api/org/springframework/ui/Model.html" target="_blank">Model</a></code>, jota käytetään pyynnön attribuuttien tallentamiseen. Model on rajapinta, johon Spring asettaa sopivan toteutuksen. Attribuutin lisääminen <code>Model</code>-oliolle sen metodin <code>addAttribute</code> avulla tarkoittaa käytännössä samaa kuin attribuutin lisääminen <code>HttpServletRequest</code>-oliolle metodilla <code>setAttribute</code>.</p>


                <p>Spring syöttää <code>@RequestMapping</code>-annotaation omaavalle metodille parametrit sitä kutsuttaessa. Esimerkiksi edellisessä tehtävässä toteutettiin kontrolleriluokan metodi, joka näytti seuraavalta:</p>


<pre class="sh_java">
    // ...
    public String processRequest(HttpServletRequest request, HttpServletResponse response) {
        request.setAttribute("message", "Great Scott!");
        return "hello";
    }
    // ...
</pre>


                <p>Saman metodin voi toteuttaa myös seuraavanlaisena.</p>


<pre class="sh_java">
    // ...
    public String viewHelloPage(Model model) {
        model.addAttribute("message", "Great Scott!");
        return "hello";
    }
    // ...
</pre>

                <p>Lopputulos on käytännössä täysin sama.</p>


                <p>Luokka <code>Model</code> sisältää siis vastaavan toiminnallisuuden kuin <code>HttpServletRequest</code>-luokan attribuutit, mutta toiminnallisuus on erotettu siististi erilliseksi olioksi.</p>



<div class="tehtavat">

  <h3>Password Generator</h3>


  <p>Tehtävässä rakennetaan salasanageneraattori, jolta saa uuden salasanan aina kun generaattorin verkkosivu ladataan.</p>


  <h4>PasswordGeneratorController</h4>


  <p>Luo pakkaukseen <code>wad.passwordgenerator</code> luokka <code>PasswordGeneratorController</code> ja lisää sille kontrolleriluokkien tarvitsema annotaatio.</p>


  <p>Toteuta luokkaan <code>PasswordGeneratorController</code> metodi <code>public String generatePassword()</code>, joka palauttaa uuden salasanan merkkijonona. Käytä salasanan generointiin <code><a href="http://docs.oracle.com/javase/6/docs/api/java/util/UUID.html" target="_blank">UUID</a></code>-luokan staattista metodia <code><a href="http://docs.oracle.com/javase/6/docs/api/java/util/UUID.html#randomUUID()" target="_blank">randomUUID()</a></code>. Voit muuttaa UUID-luokan ilmentymän merkkijonoksi kaikille olioille yhteisellä <code>toString</code>-metodilla.</p>


  <p>Toteuta seuraavaksi luokkaan <code>PasswordGeneratorController</code> metodi <code>public String newPassword(Model model)</code>, joka vastaa polkuun <code>new-password</code> tuleviin pyyntöihin. Metodin <code>newPassword</code> tulee generoida uusi salasana <code>generatePassword</code>-metodia käyttäen, sekä asettaa luotu salasana <code>Model</code>-olion attribuutiksi avaimella <code>password</code>. Tämän jälkeen metodi <code>newPassword</code> palauttaa näkymän nimen, joka johtaa seuraavassa kohdassa tehtävälle JSP-sivulle <code>password.jsp</code>.</p>


  <p>Huomaathan että DispatcherServlet kuuntelee vain polkua <code>/app/</code> ja sen alle tulevia pyyntöjä.</p>


  <h4>View: password.jsp</h4>


  <p>Konfiguroi Spring lisäämällä tiedostoon <code>front-controller-servlet.xml</code> edellistä tehtävää vastaava konfiguraatio:
    <ul>
      <li>olioiden automaattinen lataaminen oliokontekstiin</li>
      <li><code>InternalResourceViewResolver</code>, joka etsii JSP-tiedostoja polusta <code>/WEB-INF/jsp/</code></li>
    </ul>
  </p>


  <p>Luo lopuksi hakemistoon <code>/WEB-INF/jsp</code> JSP-sivu <code>password.jsp</code>. JSP-sivulla tulee olla teksti <code>Password Generator</code> ja viittaus Controller-metodin asettamaan attribuuttiin <code>password</code>, jotta generoitu salasana näytetään sivulla.</p>

</div>


                <h3>POST-tyyppiset pyynnöt ja uudelleenohjaukset</h3>


                <p>Aiemmin totesimme että tietoa muokkaavat tai lisäävät pyynnöt tulee tehdä POST-tyyppisinä. Edellä määrittelemämme metodit eivät kuitenkaan ainakaan tuo ilmi sitä, miten ne käsittelevät POST-tyyppisiä pyyntöjä. Annotaatiolle <code>@RequestMapping</code> voi määritellä pyyntötyypin parametrilla <code>method</code>. Jos annotaatiolla <code>@RequestMapping</code> on useampia parametreja, tulee jokainen niistä määritellä erikseen.</p>

                <p>Esimerkiksi annotaatiolla <code>@RequestMapping(value = "add", method = RequestMethod.POST)</code> esitellään <code>add</code>-osoitteeseen tulevia POST-pyyntöjä kuunteleva metodi.</p>

<pre class="sh_java">
    // ...
    @RequestMapping(value = "add", method = RequestMethod.POST)
    public String add() {
        // ...
        return "page"; // ???
    } 
    // ...
</pre>

                <p>POST-tyyppisten pyyntöjen suorituksen jälkeen käyttäjä tulee ohjata aina tekemään uutta pyyntöä. Omassa Front Controller-luokassamme uudelleenohjauksen tarve pääteltiin <code>redirect:</code>-etuliitteestä. Itseasiassa, Springin <code>InternalResourceViewResolver</code> tarjoaa täsmälleen saman toiminnallisuuden.</p>


                <p>Jos metodi palauttaa merkkijonon, joka alkaa merkkijonolla <code>redirect:</code>, pyyntö ohjataan merkkijonoa <code>redirect:</code> seuraavaan osoitteeseen.</p> 


<pre class="sh_java">
    // ...
    @RequestMapping(value = "add", method = RequestMethod.POST)
    public String add() {
        return "redirect:page"; // :)
    } 
    // ...
</pre>


                <p>Osoite, jonne pyyntö ohjataan, on riippuvainen nykyisestä osoitteesta. Esimerkiksi, jos metodi <code>add</code> kuuntelee osoitetta <code>http://palvelin.net/sovellus/add</code>, tekee käyttäjän selain ylläolevan metodin suorituksen pyynnön osoitteeseen <code>http://palvelin.net/sovellus/list</code>.</p>


                <h3>Pyynnössä olevien parametrien käsittely</h3>


                <p>Edellisessä osassa ollut esimerkki oli hieman torso: pyynnöissä ei ollut parametreja, joita olisi tallennettu. Aiemmin pyynnön parametrit on saatu <code>HttpServletRequest</code>-oliosta metodin <code>getParameter</code> avulla.</p>


                <p>Pyynnössä olevat parametrit voidaan asettaa Springin toimesta <code>@RequestParam</code>-annotaatioilla merkittyihin muuttujiin. Annotaatiolla <code>@RequestParam</code> määritellään parametrin nimi, sekä parametrin pakollisuus. Esimerkiksi seuraavalla määrittelyllä pyynnössä on pakko olla parametri nimeltä <code>item</code>. Parametri asetetaan muuttujaan <code>String item</code>, josta sitä voi käyttää metodin sisällä.</p>

<pre class="sh_java">
    // ...
    @RequestMapping(value = "add", method = RequestMethod.POST)
    public String add(@RequestParam(value="item", required=true) String item) {
        // ...
    } 
    // ...
</pre>


                <h3>Pyynnöt ja evästeet</h3>

                
                <p>HTTP tarvitsee tilattomuutensa takia tavan käyttäjien seuraamiseen. HTTP/1.1-standardissa tilalliset verkkosovellukset toteutetaan yleensä evästeiden avulla. Javan Servlet-apissa on valmiina luokka <code><a href="http://docs.oracle.com/javaee/6/api/javax/servlet/http/HttpSession.html" target="_blank">HttpSession</a></code>, jota käytetään evästeiden asettamiseen.</p>


                <p>Luokkaan <code>HttpSession</code> pääsee käsiksi luokan <code>HttpServletRequest</code> metodilla <code>getSession</code>. Spring osaa asettaa HttpSession-olion myös suoraan osaksi pyyntöä käsittelevän metodin parametreja. Esimerkiksi seuraava metodi kuuntelee POST-tyyppisiä pyyntöjä osoitteeseen login ja odottaa että pyynnössä on parametrit <code>username</code> ja <code>password</code>. Spring asettaa <code>HttpSession</code>-olion <code>HttpServletRequest</code>-oliosta automaattisesti metodin käyttöön.</p>


<pre class="sh_java">
    // ...
    @RequestMapping(value = "login", method = RequestMethod.POST)
    public String login(
            @RequestParam(value = "username", required = true) String username,
            @RequestParam(value = "password", required = true) String password,
            HttpSession session) {
        if(!("mikael".equals(username) && "rendezvouspark".equals(password))) {
            return "redirect:login";        
        }

        return "awesomeness";
    }
    // ...
</pre>



<div class="tehtavat">


  <h3>Very First Authentication</h3>


  <p>Tässä tehtävässä toteutetaan salasanasuojaus salaiselle sivulle. Tehtäväpohjassa on valmiina kaksi JSP-sivua <code>login.jsp</code> ja <code>secret.jsp</code>, joista ensimmäisen tehtävänä on kerätä käyttäjätunnus ja salasana sisäänkirjautumista varten. Jälkimmäinen sivu on salainen sivu, jonne pääsee vain, jos tietää oikean salasanan.</p>

  <p>Tehtäväpohjassa olevassa <code>web.xml</code>-tiedostossa on määritelty omituinen <em>filtteri</em>. Palaamme niihin seuraavalla viikolla.</p>


  <p>Pelkän käyttäjätunnuksen ja salasanan tarkistamisen lisäksi tehtävässä ne tallennetaan <em>sessioon</em> käyttämällä <code><a href="http://docs.oracle.com/javaee/6/api/javax/servlet/http/HttpSession.html" target="_blank">HttpSession</a></code>-rajapintaa. Tietojen tallettaminen sessioon mahdollistaa sen, että sovellus muistaa käyttäjän tiedot myös sisäänkirjautumisen jälkeen tapahtuvilla HTTP-pyynnöillä. Kirjautumisen jälkeen avautuvan salaisen sivun voi siis ladata uudelleen lähettämättä käyttäjätunnusta ja salasanaa uudelleen niin pitkään kuin selaimessa oleva eväste on voimassa. Sessio voidaan myös tarvittaessa tuhota, jolloin palvelin ja selain "unohtavat" sisäänkirjautumisen. Tätä varten tehtäväpohjan salaisella sivulla (secret.jsp) on linkki uloskirjautumiseen.</p>


  <h4>AuthenticationController</h4>


  <p>Luo pakkaukseen <code>wad.veryfirstauthentication.controller</code> luokka <code>AuthenticationController</code>, joka toteuttaa tehtäväpohjan mukana annetun rajapinnan <code>AuthenticationControllerInterface</code>. Rajapinta määrittelee toteutettavan Controller-luokan metodit ja toimii apuna tehtävän automaattisille testeille.  Rajapinnassa määriteltyjen metodien tulee toimia seuraavalla tavalla:
    <ul>
      <li><code>String viewLoginPage()</code> vastaa GET-pyyntöihin osoitteessa <code>login</code> ja palauttaa näkymän <code>login.jsp</code></li>
      <li><code>String login(String username, String password, HttpSession session)</code> vastaa POST-pyyntöihin osoitteessa <code>login</code>, sekä:
        <ol>
          <li>lukee käyttäjätunnuksen ja salasanan pyynnön parametreista <code>username</code> ja <code>password</code> käyttämällä <code>@RequestParam</code>-annotaatiota</li>
          <li>jos käyttäjältä saatu salasana ei ole <code>secret</code>, metodi tekee uudelleenohjauksen osoitteeseen <code>login</code> &mdash; annetulla käyttäjätunnuksella ei ole väliä</li>
          <li>asettaa käyttäjätunnuksen ja salasanan HTTP-session attribuutteihin <code>username</code> ja <code>password</code></li>
          <li>tekee uudelleenohjauksen osoitteeseen <code>secret</code></li>
        </ol></li>
      <li><code>String viewSecretPage(Model model, HttpSession session)</code> vastaa GET-pyyntöihin osoitteessa <code>secret</code>, sekä:
        <ol>
          <li>tarkistaa sessiosta käyttäjän salasanan: jos salasana ei ole <code>secret</code>, metodi tekee uudelleenohjauksen osoitteeseen <code>login</code> &mdash; annetulla käyttäjätunnuksella ei ole väliä. Huom! HttpSession-olion getAttribute-metodin palauttama arvo voi olla myös <em>null</em>. Ohjaa tällöin myös käyttäjä osoitteeseen login.</li>
          <li>asettaa käyttäjätunnuksen <code>Model</code>-attribuuttiin <code>username</code>, jotta se voidaan näyttää salaisella sivulla</li>
          <li>palauttaa näkymän <code>secret.jsp</code></li>
        </ol></li>
      <li><code>String logout(HttpSession session)</code> vastaa GET-pyyntöihin osoitteessa <code>logout</code>, tuhoaa (eli invalidoi) HTTP-session ja tekee uudelleenohjauksen osoitteeseen <code>login</code></li>
    </ul>
  </p>

  <p>Ohjelmaa rakentaessa sitä kannattaa testata itse selaimessa, sillä siten sen toiminta selviää parhaiten!</p>
</div>



                <h3>Sovelluslogiikan erottaminen kontrollereista: palvelut</h3>


                <p>Aiemmissa esimerkeissä ohjelmiin liittyvää sovelluslogiikkaa on laitettu milloin minnekin.  Esimerkiksi salasanageneraattori-tehtävässä sovelluslogiikka, joskin vähäinen sellainen, oli osana Controller-luokkaa, metodissa <code>generatePassword</code>. Tämä ei ole hyvän ohjelmointityylin mukaista, sillä tarkoituksena on pitää Controller-luokkien koodimäärä mahdollisimman vähäisenä. Tavoitteena on erottaa sovelluslogiikka, eli ohjelman varsinainen "pihvi", omiin luokkiinsa, joita kutsutaan <em>palveluiksi</em> (Service). Jokainen palveluluokka tarvitsee oman rajapintansa, jotta luokkien väliset riippuvuudet eivät kohdistuisi toteutuksiin, vaan rajapintoihin. Tällöin palvelujen toteutuksia voidaan vaihtaa esimerkiksi testattaessa sovellusta.</p>

                <p>Spring tarjoaa toiminnallisuuden palveluiden automaattiseen lisäämiseen <code>@Autowired</code>-annotaation avulla. Palvelut tunnistetaan <code>@Service</code>-annotaation avulla. Muokataan kappalessa 4.7 nähtyä Timo Soinin viestipalvelua siten, että se on oliokontekstiin ladattava palvelu.</p>

<pre class="sh_java">
// importit jne

@Service
public class TimoSoiniMessageService implements MessageService {
    // sama toteutus kuin ennenkin
}
</pre>

                <p>Nyt kontrolleriluokkaan voi ladata <code>MessageService</code>-rajapinnan toteuttavan luokan automaattisesti <code>@Autowired</code>-annotaatiota käyttämällä. Luodaan vielä erillinen MessageController-luokka viestien näyttämiselle.</p>


<pre class="sh_java">
// importit jne..

@Controller
public class MessageController {

    @Autowired
    private MessageService messageService;

    public String handleRequest(Model model) {
        model.addAttribute("truth", messageService.getMessage());
        return "view";
    }
}
</pre>


                <p>Koska luokka <code>TimoSoiniMessageService</code> toteuttaa rajapinnan <code>MessageService</code>, ja se on merkattu annotaatiolla <code>@Service</code>, voi Spring injektoida <code>TimoSoiniMessageService</code>-luokan ilmentymän automaattisesti <code>MessageService</code>-tyyppiseen olioon.</p>


<div class="tehtavat">

  <h3>Chatting with Anna</h3>

  <p>Huom! Jos testit kertovat että mock-objektit ovat null-arvoisia (Argument should be a mock, but is null!), päivitä TMC-pluginisi. TMC-pluginin saa päivitettyä valitsemalla Help -> Check for Updates. Voit myös lähettää tehtävän TMC:lle ilman testien läpimenoa -- palvelimella on ajantasainen versio TMC:stä.</p>


  <p>Tässä tehtävässä toteutetaan alkuviikon Chat-sovelluksesta kehittyneempi versio Springiä apuna käyttäen. Lisäksi chatissa on mukana botti nimeltä Anna, joka vastailee esitettyihin kysymyksiin.</p>


  <p>Tehtäväpohjassa on valmiina kaksi palvelua ja niitä vastaavat rajapinnat pakkauksessa <code>wad.chattingwithanna.service</code>.</p>


  <h4>ChatControllerInterface-rajapinnan toteuttaminen</h4>


  <p>Luo pakkaukseen <code>wad.chattingwithanna.controller</code> luokka <code>ChatController</code>, joka toteuttaa tehtäväpohjassa annetun rajapinnan <code>ChatControllerInterface</code>. Rajapinta määrittelee toteutettavan Controller-luokan metodit ja toimii apuna tehtävän automaattisille testeille. Metodin <code>addMessage</code> tulee vastata POST-pyyntöihin polussa <code>add-message</code> ja <em>uudelleenohjata</em> pyyntö polkuun <code>list</code>. Metodin <code>list</code> tulee vastata GET-pyyntöihin polussa <code>list</code> ja näyttää tehtäväpohjan mukana annettu näkymä <code>list.jsp</code>. Metodien logiikka toteutetaan tehtävän seuraavassa kohdassa.</p>

  <p>Metodin käyttämän HTTP-metodin (GET/POST/...) voi määrittää <code>@RequestMapping</code>-annotaation parametrilla <code>method</code> esimerkiksi näin:</p>

<pre class="sh_java">
@RequestMapping(value = "path", method = RequestMethod.POST)
</pre>

  <p><strong>Huom!</strong> Kun <code>@RequestMapping</code> annotaatiolle annetaan useampi parametri, täytyy ensimmäinenkin (polun määrittävä) parametri asettaa nimellä <code>value</code>.</p>

  <h4>ChatController-luokan metodien toteuttaminen</h4>

  <p>Metodi <code>addMessage</code> saa parametrikseen käyttäjän lähettämän viestin merkkijonona. Spring voi hakea viestin automaattisesti metodille tulleesta HTTP-pyynnöstä parametrille määritettävän <code>@RequestParam</code>-annotaation avulla. Annotaation parametreista <code>value</code> on haettavan parametrin nimi ja <code>required</code> määrittelee hyväksytäänkö pyyntö, jossa parametria ei ole määritelty. Annotaatio määritellään metodin parametrille esimerkiksi näin:</p>

<pre class="sh_java">
public String operation(@RequestParam(value = "parameter-name", required = false) String parameter) {
    ...
}
</pre>

  <p>Lisää metodin <code>addMessage</code> parametrille <code>String message</code> <code>@RequestParam</code>-annotaatio HTTP-parametrin nimellä <code>message</code>. HTTP-parametri <code>message</code> ei ole pakollinen, joten pyynnöt ilman sitä täytyy hyväksyä.</p>

  <p>Jos parametrina oleva viesti on tyhjä tai <code>null</code>-viite, metodin tulee ohjata pyyntö suoraan listasivulle.</p>

  <p>Metodissa tarvitaan tehtäväpohjan mukana annettuja palveluita <code>MessageService</code> ja <code>ChatBot</code>. Injektoi nämä riippuvuudet <code>@Autowired</code>-annotaation avulla <code>ChatController</code>-luokan oliomuuttujiksi.</p>

  <p><code>addMessage</code> metodin tulee aiemman chat-tehtävän mukaisesti muuttaa käyttäjän antamasta viestistä HTML-koodi tekstiksi käyttäen <code><a href="http://commons.apache.org/lang/api-3.1/org/apache/commons/lang3/StringEscapeUtils.html#escapeHtml4(java.lang.String)" target="_blank">StringEscapeUtils.escapeHtml4</a></code>-metodia ja tallettaa muutettu viesti <code>MessageService</code>-palvelulla. Lisää viestin alkuun merkkijono <code>"You:"</code>, jotta lähetettyjen viestien osapuolet on helppo tunnistaa.</p>

  <p>Seuraavaksi tulee kysyä viestiin vastausta botilta. Vastauksen kysyminen tapahtuu <code>ChatBot</code>-palvelun <code>getAnswerForQuestion</code>-metodilla. Talleta lopuksi botin antama vastaus <code>MessageService</code>-palvelulla (<strong>Huom!</strong> botille tehtävästä kysymyksestä ja sen lähettämästä vastauksesta HTML-koodia ei tule muuttaa!). Lisää viestin alkuun merkkijono botin nimi ja kaksoispiste <code>":"</code>, jotta lähetettyjen viestien osapuolet on helppo tunnistaa. Botin nimen saa kysyttyä <code>ChatBot</code>-rajapinnan metodilla <code>getName()</code>.</p>

  <p><strong>Huom!</strong> Metodi <code>getAnswerForQuestion</code> voi heittää poikkeuksen, jos verkkoyhteys ei toimi, joten käsittele metodin heittämät poikkeukset siten, että käytät poikkeuksen viestiä botin vastauksena. Tällöin voit testata ohjelmaa, vaikka verkkoyhteyttä ei olisi.</p>

  <p>Toteuta lopuksi metodi <code>list</code>, jonka tulee lisätä <code>MessageService</code>-palvelusta haettu lista viestejä <code>Model</code>-instanssiin avaimella <code>messages</code>.</p>

  <p>Keskustelun tulisi näyttää esimerkiksi tältä (käyttäjän esittämät kysymykset on merkitty punaisella):</p>

<pre>
You: <font color="red">Who are you?</font>
Anna: I am Anna, the .... Online Assistant.
You: <font color="red">How old are you?</font>
Anna: I prefer not to discuss my age; let's talk about ....
You: <font color="red">When?</font>
Anna: I'm sorry, but I don't know the answer to that just yet.
You: <font color="red">What's the time?</font>
Anna: So the current East Coast time is 5:12 and the West Coast time is 3:12.
You: <font color="red">Are you fat?</font>
Anna: Sorry, but I don't really have the expertise to comment on health matters...
</pre>

</div>

<div class="extra">

<p>MVC (model-view-controller) on (vieläkin :)) ohjelmistoarkkitehtuurityyli, jonka tavoitteena on käyttöliittymän erottaminen sovelluslogiikasta. Model on yleensä näytettävä data, view on itse näkymä, ja controller vastaanottaa käyttäjän tekemät käskyt ja muokkaa niiden pohjalta sekä dataa että näytettävää näkymää.</p>

<p>Miten toteuttamamme Spring Web-sovellukset liittyvät MVC-arkkitehtuuriin? Mikä rooli on jsp-sivuilla ja kontrollereilla? Entä mikä osa on Model? </p>

<p>Mihin osaan MVC:tä sovelluksen sovelluslogiikka kuuluu?</p>

</div>

<!--

VK3:

* filtterit, pari sanaa tietoturvasta



  * tallennuslogiikka, ihan perus JDBC

    * DAO pattern tää vois olla jees paikka tän esittelylle

       * tapa vaihtaa tallennustyyliä "on the fly"

          * ohjan tiedostodao -> dbdao?


    * Jdbc:n käyttö

       * eka softa, jossa ei springejä tai mitään
          * kysely yhteen tauluun

       * sit injektoidaan datasource springissä
          * kysely taas yhteen tauluun

       * tiedon tallentaminen
          * yhteen tauluun tallennus -> ok
          * viitteiden ylläpito, perseestä

       * nykyään kuitenkin melko standardoitunutta

    * Springin JDBC-templaten käyttö, ei tartte koko DAO:a toteuttaa, vaan täytä metodi xx
      
  

* Domain Driven Design ja ORM

  * softa koostuu käsitteistä, perkele

  * kantakonffin injektointi

  * SQL-injektiot ja niiden esto
  
  * JPA



* kerrosarkkitehtuuri

  * sovelluslogiikasta lisää
  
  * tyypillinen web-sovellus jakaantuu "presentation tier - logic tier - database tier"

    * missä tässä MVC?


//-->


<h2>MerkistÃ¶ongelmat</h2>

        <p>Selainten ja palvelinten välisessä matalan tason kommunikoinnissa kaikki viestit siirretään binäärimuodossa joukkona nollia ja ykkösiä. Binäärimuotoinen data käännetään tekstiksi sovitun merkistökoodauksen avulla. Merkistökoodauksia on useita erilaisia, joista perinteisin lienee ASCII (<code>American Standard Code for Information Interchange</code>). ASCII-merkistössä jokainen merkki kuvataan 8 bitin avulla, josta 7 bittiä on merkeille (viimeinen on esim. pariteettibitti, jota voidaan käyttää merkin oikeellisuuden tarkistamiseen).</p>

        <p>ASCII-merkistö ei juurikaan tue erikoismerkkejä. Esimerkiksi suomessa käytetyille ääkkösille ei ole kuvausta ASCII-merkistössä. Erikoismerkkien tarpeen vuoksi on kehitetty lukuisia standardeja, mm. ISO-8859-<em>versio</em>. Merkistö ISO-8859-1 sisältää tuen mm. lähes kaikille suomen kielessä käytettäville merkeille, ja sitä käytetään paljon selainten ja palvelinten välisessä kommunikoinnissa.</p>

        <p>Nykyisin web-sivuilla eniten käytetty merkistö on UTF-8, joka kuvaa merkit 8-32 bitin avulla.</p>

        <p>Koska erilaisia merkistöjä on satoja ja käyttöjärjestelmävalmistajilla on usein hieman standardeista poikkeava oma merkistö, tulee palvelimella ja selaimella olla yhteisymmärrys käytettävästä merkistöstä. Yhteisymmärrys luodaan sisällyttämällä pyynnön ja vastauksen otsakkeisiin tieto käytetystä merkistöstä.</p>

        <p>Esimerkiksi pyyntöön voi lisätä otsakkeen <code>Accept-Charset</code>, jolla kerrotaan toivottu merkistö.</p>

<pre>
Accept-Charset: utf-8
</pre>

        <p>Vastauksessa käytetään otsaketta <code>Content-Type</code> vastauksen sisällön tyypin ja käytetyn merkistön ilmaisemiseen.</p>

<pre>
Content-Type: text/html; charset=utf-8
</pre>

        <p>HTML-sivuilla usein käytetään vielä lisäksi erillistä otsakekenttää, jolla pyritään valmistamaan käytetyn merkistön oikeellisuus. Esimerkiksi alla olevalla otsakkeella kuvataan sivun sisällöksi <code>text/html</code> ja merkistöksi <code>utf-8</code>.</p>

<pre class="sh_xml">
  &lt;meta http-equiv="Content-Type" content="text/html; charset=utf-8" /&gt;
</pre>

        <p>Merkistön sopiminen tapahtuu usein automaattisesti, mutta käytännössä ohjelmoijien tulee varautua merkistöongelmiin. Esimerkiksi servlettejä tehdessämme laitoimme servlet-koodin alkuun aina komennon <code>response.setContentType("text/html;charset=UTF-8")</code>, joka lisää <code>Content-Type</code>-otsakkeen vastaukseen.</p>

<pre class="sh_java">
        response.setContentType("text/html;charset=UTF-8");
</pre>

        <p>Mielenkiintoisia ongelmia tarjoavat tilanteet, joissa otsaketiedoissa kerrotaan sisällön olevan tiettyä tyyppiä, mutta sisältö onkin erilaista. Jos merkistö on asetettu ASCII-muotoiseksi, mutta sisältö sisältää ASCII-aakkostossa määrittelemättömiä merkkejä, on sisällön tulkinta sovelluksen vastuulla. Merkistöongelmat voivat johtua myös palvelimen käyttämistä kolmannen osapuolen komponenteista. Esimerkiksi tietokannat tallentavat dataa yleensä tietyllä merkistöllä: jos ISO-8859-1 -merkistöä käyttävään tietokantaan tallennetaan UTF-8-muotoista dataa, tulee ainakin osa tallennetusta datasta olemaan korruptoitunutta.</p>


        <h3>Checklist</h3>

        <p>Jos sovelluksessasi on merkistöongelma, aloita seuraavista tarkistuksista:</p>

        <p>
          <ol>
            <li>Varmista että pyynnöt ja vastaukset sisältävät otsakkeen merkistön asettamiseen.</li>
            <li>Varmista että JSP-sivujen alussa on alla oleva komento, jolla varmistetaan merkistön asetus.<br/>
<pre class="sh_xml">
&lt;%@page pageEncoding="UTF-8" contentType="text/html; charset=UTF-8"%&gt;
</pre>
            </li>
            <li>Varmista että HTML-sivuilla on pyynnöt ja vastaukset sisältävät otsakkeen merkistön asettamiseen.<br/>
<pre class="sh_xml">
&lt;meta http-equiv="Content-Type" content="text/html; charset=utf-8" /&gt;
</pre>
            </li>
            <li>Varmista että tietokanta on konfiguroitu käyttämään haluttua merkistöä.</li>
            <li>Varmista että palvelin on konfiguroitu käyttämään haluttua merkistöä.</li>
          </ol>
        </p>


        <h3>Filtterit</h3>

        <p>Javan Servlet API sisältää servlettien lisäksi myös filttereitä. Filtterit ovat pyynnön ja vastauksen prosessoijia, joilla voidaan käsitellä pyyntöä ja vastausta ennen niiden servletille saapumista, sekä sen jälkeen kun servlet-koodi on suoritettu. Hyvin yleinen käyttötapa filtterille on merkistön asetus: yksittäistä filtteriä voidaan käyttää otsakkeiden asettamiseen pyyntöön ja vastaukseen.</p>

        <p>Omia filttereitä toteutettaessa ohjelmoijan tulee periä rajapinta <code>javax.servlet.Filter</code>, sekä toteuttaa sen vaatimat metodit. Esimerkiksi alla on filtteri, joka tulostaa viestin ennen ja jälkeen seuraavan kohteen käsittelyä. Metodissa <code>doFilter</code> tehtävä komento <code>chain.doFilter</code> ohjaa pyynnön seuraavalle kohteelle, esimerkiksi servletille.</p>

<pre class="sh_java">
package wad.filter;

import java.io.IOException;
import javax.servlet.Filter;
import javax.servlet.FilterChain;
import javax.servlet.FilterConfig;
import javax.servlet.ServletException;
import javax.servlet.ServletRequest;
import javax.servlet.ServletResponse;

public class SimpleFilter implements Filter {

    private void preprocess(ServletRequest request, ServletResponse response)
            throws IOException, ServletException {
        System.out.println("Before handling servlet code.");
    }

    private void postprocess(ServletRequest request, ServletResponse response)
            throws IOException, ServletException {
        System.out.println("After handling servlet code.");
    }

    public void doFilter(ServletRequest request, ServletResponse response,
            FilterChain chain)
            throws IOException, ServletException {
        preprocess(request, response);

        chain.doFilter(request, response);

        postprocess(request, response);
    }

    public void init(FilterConfig fc) throws ServletException {
    }

    public void destroy() {
    }
}
</pre>


        <p>Filtterit konfiguroidaan <code>web.xml</code>-tiedostoon lähes samoin kuin servletit. Poikkeuksena on se, että <code>servlet</code>-nimen sijaan käytetään elementtiä nimeltä <code>filter</code>. Alla on konfiguroitu yllä luotu <code>SimpleFilter</code> kuuntelemaan kaikkia web-sovellukseen tulevia pyyntöjä.</p>


<pre class="sh_xml">
    &lt;filter&gt;
        &lt;filter-name&gt;CharSetFilter&lt;/filter-name&gt;
        &lt;filter-class&gt;wad.filter.SimpleFilter&lt;/filter-class&gt;
    &lt;/filter&gt;
    &lt;filter-mapping&gt;
        &lt;filter-name&gt;CharSetFilter&lt;/filter-name&gt;
        &lt;url-pattern&gt;/*&lt;/url-pattern&gt;
    &lt;/filter-mapping&gt;
</pre>

        <p>Spring-sovelluskehyksellä on valmis filtteri, joka muuttaa kaikki pyynnöt ja vastaukset (esimerkiksi) UTF-8 merkistöä käyttäväksi: <a href="http://static.springsource.org/spring/docs/current/javadoc-api/org/springframework/web/filter/CharacterEncodingFilter.html" target="_blank">CharacterEncodingFilter</a>. Filtterin saa käyttöön lisäämälle sen <code>web.xml</code>-tiedostoon.</p>

<pre class="sh_xml">
    &lt;!-- Filtteri: Kaikki pyynnöt utf-8:ksi --&gt;
    &lt;filter&gt;
        &lt;filter-name&gt;encoding-filter&lt;/filter-name&gt;
        &lt;filter-class&gt;
            org.springframework.web.filter.CharacterEncodingFilter
        &lt;/filter-class&gt;
        &lt;init-param&gt;
            &lt;param-name&gt;encoding&lt;/param-name&gt;
            &lt;param-value&gt;UTF-8&lt;/param-value&gt;
        &lt;/init-param&gt;
        &lt;init-param&gt;
            &lt;param-name&gt;forceEncoding&lt;/param-name&gt;
            &lt;param-value&gt;true&lt;/param-value&gt;
        &lt;/init-param&gt;
    &lt;/filter&gt;
    &lt;filter-mapping&gt;
        &lt;filter-name&gt;encoding-filter&lt;/filter-name&gt;
        &lt;url-pattern&gt;/*&lt;/url-pattern&gt;
    &lt;/filter-mapping&gt;
</pre> 

        <p>Jatkossa käytämme ylläolevaa filtteriä osana Spring-sovelluksiamme.</p>


<div class="extra">
  <p>Lue tietokone-lehden UTF-merkistöä käsittelevä artikkeli vuodelta 2001: <a href="http://www.tietokone.fi/lehti/tietokone_12_2001/unicode_ratkaisee_merkistoongelmat_4507">Unicode ratkaisee merkistöongelmat</a>.</p>

  <p>Artikkeli on kirjoitettu yli 10 vuotta sitten. Mitä artikkeli kuvaa merkistöongelmina, ja miten Unicode toimii niihin ratkaisuna?</p>
  <p>&nbsp;</p>
</div>



<h2>Tietokannat</h2>


        <p><em>Tietokanta on tietotekniikassa käytetty termi tietovarastolle. Se on kokoelma tietoja, joilla on yhteys toisiinsa. ... Tietokanta saattaa edustaa jotain selvästi rajattua kohdetta reaalimaailmasta. Tällainen kohde voi olla esimerkiksi yrityksen keräämät tiedot asiakkaistaan.</em> - Wikipedia</p>

        <p><em>Tietokanta on lähes aina webisoftan oleellisin osa, ilman sitä ei ole mitään näytettävää.</em> - Mikael</p>

        <p>Tähänastiset sovelluksemme ovat hukanneet käyttämänsä tiedot sovelluksen sammuessa. Tämä johtuu siitä että tietoa ei ole varastoitu mihinkään, vaan se on ollut vain sovelluksen muistissa. Tiedon säilymisen varmistamiseksi tieto tulee tallentaa pysyväismuistiin. Tietoa kuvataan usein taulumuotoisena, esimerkkinä seuraava taulu <code>Henkilo</code>:</p>

        <p>
          <table border=1>
            <tr><th colspan="3">Henkilo</th></tr>
            <tr><th>id</th><th>nimi</th><th>huone</th></tr>

            <tr><td>1</td><td>Arto</td><td>B215</td></tr>
            <tr><td>2</td><td>Matti</td><td>D232</td></tr>
            <tr><td>3</td><td>Mikael</td><td>B215</td></tr>

          </table>
        </p>

        <p>Tietokantoja käytetään tiedon pysyväismuistiin (esim kovalevylle) tallentamiseen. Termiä tietokanta käytetään puhekielessä usein termin <em>tietokannanhallintajärjestelmä</em> korvaajana. Tietokannanhallintajärjestelmät (<em>DBMS, Database Management System</em>) ovat sovelluksia, jotka tarjoavat tukitoiminnallisuuksia tietokannan sydämen, eli tietokantamoottorin päälle. Tietokantamoottori tarjoaa toiminnallisuuden tiedon luomiseen, lukemiseen, päivittämiseen ja poistamiseen. Tätä toiminnallisuutta kutsutaan usein termillä <code>CRUD</code> (create, read, update and delete).</p>

        <p>Esimerkiksi <a href="http://www.mysql.com/" target="_blank">MySQL</a>-tietokannanhallintajärjestelmää käytettäessä käyttäjä voi valita useamman tietokantamoottorin välillä, nykyään yleisin (ja oletus-) vaihtoehto on <a href="http://dev.mysql.com/doc/refman/5.5/en/innodb-storage-engine.html" target="_blank">InnoDB</a>-moottori.</p>

        <p>Huomattava osa tietokannanhallintajärjestelmistä toteuttaa <a href="http://en.wikipedia.org/wiki/ACID" target="_blank">ACID</a>-ominaisuudet (Atomicity, Concistency, Isolation, Durability), joilla pyritään turvaamaan järjestelmän luotettavuutta. Käytännössä ACID-ehtoja seuraamalla tallennettavat tiedot ovat eheitä myös virhetilanteissa. ACID koostuu seuraavista osista:</p>

        <p>
          <ul>
            <li>Atomisuus (<code>Atomicity</code>): tietokantaan tehtävä kyselysarja suoritetaan kokonaan, tai sitä ei suoriteta lainkaan. Tähän liittyy käsite <em>transaktio</em>. Tietokantatransaktioiden avulla voidaan suorittaa joukko tietokantakyselyitä siten, että jos yksikin kysely epäonnistuu, yhtäkään ei suoriteta (palataan aiempaan tilaan). Esimerkiksi tilisiirtoja suorittaessa tehdään useampia käskyjä: "Ota rahaa tililtä 1, laita rahaa tilille 2" -- jos vain toinen onnistuu, rahat katoavat.<br/><br/></li>
            <li>Johdonmukaisuus (<code>Consistency</code>): tietokannan tulee olla jokaisen transaktion jälkeen eheässä ja johdonmukaisessa tilassa. Esim. tietokantaan tehtävien muutosten tulee näkyä muille tietokantaa käyttäville ohjelmille aina samalla tavalla, <em>johdonmukaisesti</em>.<br/><br/></li>
            <li>Eristyneisyys (<code>Isolation</code>): Tietokantaan tehtävät transaktiot eivät saa vaikuttaa toisiinsa, ja kesken oleva transaktio ei saa näkyä muille transaktioille.<br/><br/></li>
            <li>Pysyvyys (<code>Durability</code>): Kun transaktio on suoritettu loppuun, tehdyt muutokset eivät saa kadota järjestelmästä. </li>
          </ul>
        </p>


        <p>Tietokannanhallintajärjestelmät ovat erillisiä järjestelmiä, joihin tulee ottaa yhteys tietokantakyselyjä tehdessä. Käytännössä tietokannanhallintajärjestelmä kuuntelee jotain tiettyä porttia, johon yhteys otetaan. Useampi web-sovellus voi käyttää samaa tietokantapalvelinta. Tämä tuo haasteita skaalautuvuuden kanssa: jos tietokanta noudattaa ACID-periaatteita, ja tietokantaan tehtävien kyselyiden määrä on huomattava, voi tietokannan tehokkuus rajoittaa järjestelmän tehokkuutta. Eräs ratkaisu on tietokantapalvelimien monistaminen, mutta siinäkin on haasteena päivitysten synkronisointi palvelinten kesken.</p>

        <p><img src="img/tietokannat-skaalautuvuus.png"/></p> 


        <p>Käsittelemme tässä kappaleessa relaatiotietokantojen käyttöä osana Javapohjaisia web-palvelinohjelmistoja. Esimerkeissä (ja tehtävissä) on käytössä Javalla kirjoitettu <a href="http://www.h2database.com/" target="_blank">H2-tietokanta</a> (v. 1.3.168), jonka saa käyttöön lisäämällä seuraavan riippuvuuden <code>pom.xml</code>-tiedostoon.</p>

<pre class="sh_xml">
        &lt;dependency&gt;
            &lt;groupId&gt;com.h2database&lt;/groupId&gt;
            &lt;artifactId&gt;h2&lt;/artifactId&gt;
            &lt;version&gt;1.3.168&lt;/version&gt;
        &lt;/dependency&gt;
</pre>


        <h3>JDBC...</h3>

        <p>JDBC (<em>Java Database Connectivity</em>) on Javalle on määritelty standarditapa tietokantayhteyden luomiseen sekä tietoa muokkaavien ja hakevien kyselyjen suorittamiseen. Tausta-ajatuksena JDBCn kehitykselle on ollut yhteisen rajapinnan määrittely tietokannoille -- käytettävään tietokantaan täytyy voida ottaa yhteys, ja jokaiseen tietokantaan tulee pystyä tekemään kyselyitä. Kehitykseen on vaikuttanut <a href="http://en.wikipedia.org/wiki/ODBC" target="_blank">ODBC</a>, joka on vastaava projekti C-kielelle. JDBC tarjoaa suoran kytköksen valmiisiin ODBC-toteutuksiin. </p>
        
        <p>Jotta JDBCn avulla voidaan ottaa yhteys tietokantaan, tulee käytössä olla tietokantakohtainen JDBC-ajuri. Käytännössä jokainen tietokannanhallintajärjestelmä tarjoaa JDBC-ajurin. JDBC-ajurin vastuulla on tietokantayhteyden luomiseen liittyvät yksityiskohdat sekä kyselytulosten muuntaminen JDBC-standardin mukaiseen muotoon.</p>

        <p>Oletetaan että käytössämme on seuraavanlainen tietokantataulu:</p>

        <p>
          <table border=1>
            <tr><th colspan="3">Henkilo</th></tr>
            <tr><th>id</th><th>nimi</th><th>huone</th></tr>

            <tr><td>1</td><td>Arto</td><td>B215</td></tr>
            <tr><td>2</td><td>Matti</td><td>D232</td></tr>
            <tr><td>3</td><td>Mikael</td><td>B215</td></tr>

          </table>
        </p>

        <p>JDBCn avulla kyselyn tekeminen tietokantatauluun tapahtuu seuraavasti:</p>

<pre class="sh_java">
package wad.db;

import java.sql.Connection;
import java.sql.DriverManager;
import java.sql.ResultSet;
import java.sql.Statement;

public class Main {
    public static void main(String[] args) throws Exception {
        Class.forName("org.h2.Driver");
        String jdbcUrl = "&lt;jdbc-osoite tietokantaan&gt;";
        String username = "SA";
        String password = "";
        
        Connection connection = DriverManager.getConnection(jdbcUrl, username, password);
        
        Statement statement = connection.createStatement();
        ResultSet resultSet = statement.executeQuery("SELECT * FROM Henkilo");
        
        while(resultSet.next()) {
            int id = resultSet.getInt("id");
            String nimi = resultSet.getString("nimi"); 
            String huone = resultSet.getString("huone");
            
            System.out.println(id + "\t" + nimi + "\t" + huone);
        }
        
        connection.close();
    }   
}
</pre>

<pre>
1    Arto    B215
2    Matti   D232
3    Mikael  B215
</pre>


        <p>Tutkitaan koodia hieman tarkemmin. Alussa rekisteröidään tietokantakohtainen JDBC-ajuri käyttöön (kutsun <code>Class.forName</code> tarvitsee vain ennen Javan versiota 6). Tämän jälkeen määritellään yhteys tietokantaan. Alla ei ole määritelty tietokantaosoitetta, mutta se voisi olla esimerkiksi <code>"jdbc:h2:~/test"</code>, jos halutaan käyttää tiedostossa <code>test</code> sijaitsevaa tietokantaa. Jos palvelin on käynnissä portissa <code>9101</code>, ja tietokannan nimi on <code>test</code>, osoite on <code>"jdbc:h2:tcp://localhost:9101/~/test"</code>. H2-tietokannan saa käynnistettyä muistissa käyttämällä osoitetta <code>"jdbc:h2:mem:tietokannannimi"</code>. Lisää vaihtoehtoja löytyy H2-tietokannan <a href="http://www.h2database.com/html/features.html" target="_blank">dokumentaatiosta</a>.</p>

        <p>Konkreettinen yhteys luodaan JDBCn <code><a href="http://docs.oracle.com/javase/6/docs/api/java/sql/DriverManager.html" target="_blank">DriverManager</a></code>-luokan avulla.</p>


<pre class="sh_java">
        Class.forName("org.h2.Driver");
        String jdbcUrl = "&lt;jdbc-osoite tietokantaan&gt;";
        String username = "SA";
        String password = "";
        
        Connection connection = DriverManager.getConnection(jdbcUrl, username, password);
</pre>


        <p>Kyselyn tekeminen tapahtuu pyytämällä yhteydeltä <code><a href="http://docs.oracle.com/javase/6/docs/api/java/sql/Statement.html" target="_blank">Statement</a></code>-oliota, jota käytetään kyselyn tekemiseen ja tulosten pyytämiseen. Metodi <code>executeQuery</code> suorittaa parametrina annettavan SQL-kyselyn, ja palauttaa tulokset sisältävän <code><a href="http://docs.oracle.com/javase/6/docs/api/java/sql/ResultSet.html" target="_blank">ResultSet</a></code>-olion.</p>

<pre class="sh_java">
        Statement statement = connection.createStatement();
        ResultSet resultSet = statement.executeQuery("SELECT * FROM Henkilo");
</pre>

        <p>Tämän jälkeen <code>ResultSet</code>-oliossa olevat tulokset käydään läpi. Metodia <code>next()</code> kutsumalla siirrytään kyselyn palauttamissa tulosriveissä eteenpäin. Kultakin riviltä voi kysyä sarakeotsikon perusteella solun arvoa. Esimerkiksi kutsu <code>getString("nimi")</code> palauttaa kyseisellä rivillä olevan sarakkeen <code>"nimi"</code> arvon String-tyyppisenä.</p>

<pre class="sh_java">
        while(resultSet.next()) {
            int id = resultSet.getInt("id");
            String nimi = resultSet.getString("nimi"); 
            String huone = resultSet.getString("huone");
            
            System.out.println(id + "\t" + nimi + "\t" + huone);
        }
</pre>

        <p>Lopulta tietokantayhteys suljetaan. Tämä vapauttaa tietokantakyselyyn liittyvät resurssit.</p>

<pre class="sh_java">
        connection.close();
</pre>


        <p>JDBC:n avulla voi tehdä myös päivitysoperaatioita. Esimerkiksi seuraava kysely luo aiemmin nähdyn tietokantataulun, ja lisää sinne rivin.</p>

<pre class="sh_java">
        // ...

        Statement statement = connection.createStatement();

        // taulun luova kysely
        statement.executeUpdate(
                "CREATE TABLE Henkilo ("
                + "id INT NOT NULL PRIMARY KEY, "
                + "nimi VARCHAR(255) NOT NULL, "
                + "huone VARCHAR(255))");

        // lisätään rivi
        statement.executeUpdate("INSERT INTO Henkilo VALUES (1, 'arto', 'B215')");

        connection.close();

        // ...
</pre>


<div class="extra">
  <p>Vuonna 2011 kerätyssä vaarallisimmat ohjelmointivirheet sisältävässä <a href="http://cwe.mitre.org/top25/index.html" target="_blank">listassa</a> on SQL-injektiot numerona 1.</p>

  <p>Käytännössä suurin osa sovelluksista liittyy tietoon: tiedon hakemiseen tietokannasta, tiedon muokkaamiseen ja näyttämiseen, ja tiedon tallentamiseen tietokantaan. Jos hyökkääjä voi vaikuttaa tehtävien SQL-kyselyiden sisältöön, pääsee hän vaikuttamaan myös näytettävään tietoon.</p>

  <p>Yksinkertaisimmillaan SQL-injektio on tilanne, jossa sovelluksen käyttäjä syöttää SQL-komennon osaksi siihen kuulumatonta tavaraa. Oletetaan esimerkiksi että sovellus suorittaa kirjautumisen tarkistamalla onko seuraavan kyselyn tulos tyhjä:</p>

<pre class="sh_java">
// ...
String nimi = "nimi";
String salasana = "salasana";

String kysely = "SELECT * FROM user WHERE username = '"
                           + nimi + "' AND password = '" + salasana + "'";
// ...
</pre>

  <p>Jos käyttäjä antaa käyttäjänimen muodossa <code>haha' OR '1'='1</code>, on kyselyssä tuloksena <em>kaikki</em> taulun <code>user</code> käyttäjät ja kirjautuminen onnistuu aina.</p>

  <p>SQL-injektioesimerkkejä löytyy mm. osoitteesta <a href="http://www.unixwiz.net/techtips/sql-injection.html" target="_blank">http://www.unixwiz.net/techtips/sql-injection.html</a></p>

</div>


<h4>Prepared Statement</h4>

        <p>Prepared Statement-kyselyt ovat valmiiksi määriteltyjä kyselyitä, joissa kyselyissä käytettävät arvot annetaan parametreina. Valmiita kyselyitä käyttämällä pystytään estämään ainakin osa SQL-injektioista, sillä parametreja käytettäessä varmistetaan että parametrien arvot liittyvät aina vain tiettyyn kenttään -- kyselyparametrit eivät "vuoda yli". Prepared Statement-kyselyt mahdollistavat myös kyselyiden optimoinnin, sillä kysely on aina samanmuotoinen.</p>

        <p>Valmiit kyselyt määritellään <code>Connection</code>-olion <code>prepareStatement</code>-metodin avulla. Metodi palauttaa <code><a href="http://docs.oracle.com/javase/6/docs/api/java/sql/PreparedStatement.html" target="_blank">PreparedStatement</a></code>-olion, johon kyselyn käyttämät arvot määritellään parametreina. Esimerkiksi SQL-injektioesimerkissä oleva kysely luodaan valmiiden kyselyiden avulla seuraavasti:</p>

<pre class="sh_java">
        // ...
        String name = "nimi";
        String password = "kala";

        PreparedStatement statement = 
            connection.prepareStatement("SELECT * FROM user WHERE username = ? AND password = ?");

        statement.setString(1, name);
        statement.setString(2, password);
        
        ResultSet resultSet = statement.executeQuery();
        // ...
</pre>

        <p>Vastaavasti tietokantaa muokkaavan kyselyn voi tehdä seuraavasti (alla oletetaan että taulussa <code>user</code> on vain kaksi saraketta):</p>

<pre class="sh_java">
        // ...
        String name = "nimi";
        String password = "kala";

        PreparedStatement statement = 
            connection.prepareStatement("INSERT INTO user VALUES (?, ?)");

        statement.setString(1, name);
        statement.setString(2, password);
        
        statement.execute();
        // ...
</pre>


        <p>Huomaa että tietojenkäsittelytieteilijöille epätyypillisesti kyselyssä käytettävien parametrien indeksointi alkaa numerosta 1.</p>



<div class="tehtavat">
<NEXTWEEK></NEXTWEEK>


<h3>First SQL Queries</h3>

<p>Kaverisi ohjelmoi ensimmäisiä SQL-kyselyjään tietokantasovellukseen, mutta jätti sovellukseen muutaman SQL-injektion mentävän aukon. Tässä tehtävässä paikkaat ne. Älä muuta tehtävässä muuta kuin luokan <code>CourseDatabase</code> metodeja <code>listCoursesByName</code> ja <code>addCourse</code>.</p>


<h4>Bugi metodissa <code>listCoursesByName</code></h4>


<p>Luokkaan <code>CourseDatabase</code> toteutettuun metodiin <code>listCoursesByName</code> on jäänyt pieni tietoturva-aukko. Jos käyttäjä antaa parametriksi esimerkiksi merkkijonon</p>
<pre>
"hups' OR '1'='1"
</pre>

<p>tulee tietokantaan tehtävän hakukyselyn <code>WHERE</code>-ehto olemaan aina totta, jolloin listaus listaus sisältää aina kaikki kurssit. Korjaa kysely siten, että käytät <code>PreparedStatement</code>-tyyppistä kyselylausetta, jossa hakuehto asetetaan kyselyn parametriksi.</p>


<h4>Bugi metodissa <code>addCourse</code></h4>


<p>Myös metodissa <code>addCourse</code> on "pieni" tietoturva-aukko. Jos käyttäjä antaa päivityskyselyn parametriksi esimerkiksi merkkijonon</p>

<pre>
"hups');DROP TABLE course;INSERT INTO course ('hah"
</pre>

<p>suoritetaan tietokannassa kolme kyselyä: (1) päivityskysely, (2) tietokantataulun "course" poistaminen, (3) päivityskysely. Ei hyvä.</p>

<p>Korjaa päivityskysely siten, että käytät <code>PreparedStatement</code>-tyyppistä lausetta kurssin lisäämiseen.</p>

<p>Kun olet valmis, lähetä sovellus TMC:lle tarkistettavaksi. Tutki myös sovelluksen rakennetta tarkemmin: ohjelmassa on huomattava määrä koodia saavutettuun hyötyyn nähden.</p>

</div>


<h3>DataSource</h3>

        <p><code>DriverManager</code>-luokkaa käytettäessä yhteys tietokantaan luodaan yleensä alusta asti. Yhteyden luominen voi kestää jopa sekunteja riippuen ajurin lataamisesta, palvelimen sijainnista ja käytössä olevasta infrastruktuurista. <code>DriverManager</code>-olion käyttöä suositellumpi tapa JDBC-yhteyksien luomiseen on <code><a href="http://docs.oracle.com/javase/6/docs/api/javax/sql/DataSource.html" target="_blank">DataSource</a></code>-rajapinnan toteuttavan palvelun käyttö.</p>

        <p>Eräs toteutus DataSource-rajapinnalle on Apache Commons-projektin <a href="http://commons.apache.org/dbcp/" target="_blank">DBCP</a>-projekti. Commons DBCP-projektin saa käyttöön lisäämällä siihen liittyvän riippuvuuden <code>pom.xml</code>-tiedostoon.</p>

<pre class="sh_xml">
        &lt;dependency&gt;
            &lt;groupId&gt;commons-dbcp&lt;/groupId&gt;
            &lt;artifactId&gt;commons-dbcp&lt;/artifactId&gt;
            &lt;version&gt;1.2.2&lt;/version&gt;
        &lt;/dependency&gt;
</pre>

        <p>Yksinkertaisimmillaan yhteyden luominen ei juurikaan poikkea aiemmista esimerkeistämme.</p>

<pre class="sh_java">
// ...
import org.apache.commons.dbcp.BasicDataSource;
// ...      
  
        // ...
        BasicDataSource dataSource = new BasicDataSource();
        dataSource.setDriverClassName("org.h2.Driver");
        dataSource.setUrl(jdbcUrl);
        dataSource.setUsername(username);
        dataSource.setPassword(password);
        
        Connection connection = dataSource.getConnection();
        
        // ...
</pre>

        <p><code>DataSource</code>-rajapinnan toteuttavalle <code><a href="http://commons.apache.org/dbcp/api-1.2.2/org/apache/commons/dbcp/BasicDataSource.html" targt="_blank">BasicDataSource</a></code>-oliolle asetetaan käytettävä JDBC-ajuri, tietokannan osoite, käyttäjätunnus ja salasana, jonka jälkeen siltä voidaan pyytää uutta yhteyttä kutsumalla <code>getConnection()</code>-metodia.</p>

        <p>Suurin hyöty meidän kannaltamme liittyy siihen, että voimme käyttää <code>DataSource</code>-olioita Springin IoC-mekanismin avulla. Lisätään projektiin Springin <code>spring-context</code> -riippuvuus, joka lienee jo hieman tutuhko.</p>

<pre class="sh_xml">
        &lt;!-- Oliokonteksti --&gt;
        &lt;dependency&gt;
            &lt;groupId&gt;org.springframework&lt;/groupId&gt;
            &lt;artifactId&gt;spring-context&lt;/artifactId&gt;
            &lt;version&gt;3.1.2.RELEASE&lt;/version&gt;
        &lt;/dependency&gt;
</pre>

        <p>Nyt voimme luoda käytettävän <code>DataSource</code>-olion Springin oliokontekstiin myöhempää käyttöä varten.</p>

<pre class="sh_xml">
&lt;?xml version="1.0" encoding="UTF-8"?&gt; 
&lt;beans xmlns="http://www.springframework.org/schema/beans" 
       xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" 
       xsi:schemaLocation="http://www.springframework.org/schema/beans 
                           http://www.springframework.org/schema/beans/spring-beans-3.0.xsd"&gt;
    
    &lt;bean id="dataSource" class="org.apache.commons.dbcp.BasicDataSource"&gt;
        &lt;property name="driverClassName" value="org.h2.Driver"/&gt;
        &lt;property name="url" value="&lt;kannan osoite&gt;"/&gt;
        &lt;property name="username" value="SA" /&gt;
        &lt;property name="password" value="" /&gt;
    &lt;/bean&gt;
&lt;/beans&gt;
</pre>

        <p>Kontekstissa olevaan <code>DataSource</code>-olioon pääsee käsiksi sille määritellyllä tunnuksella. Käytännössä omaa <code>DataSource</code>-oliota ei tarvitse luoda, vaan Spring hoitaa sen puolestamme.</p>


<pre class="sh_java">
// ...
import javax.sql.DataSource;
// ...

        // ...
        ApplicationContext appContext = new ClassPathXmlApplicationContext("beans.xml");
        DataSource dataSource = (DataSource) appContext.getBean("dataSource");

        Connection connection = dataSource.getConnection();
        // ...
</pre>

        <p>Koska <code>DataSource</code>-olion voi määritellä <em>beaniksi</em>, on sen asettaminen projektiin <code>@Autowired</code>-annotaation avulla mahdollista.</p>


        <h3>JDBC ja kielto pyörän uudelleen keksimiseen: JDBCTemplate</h3>


        <p>Spring tarjoaa oman JDBC-kyselyjen tekemistä helpottavan komponentin. Komponentti <code>spring-jdbc</code> saadaan käyttöön lisäämällä se projektin <code>pom.xml</code>-tiedostoon.</p> 

<pre class="sh_xml">
        &lt;dependency&gt;
            &lt;groupId&gt;org.springframework&lt;/groupId&gt;
            &lt;artifactId&gt;spring-jdbc&lt;/artifactId&gt;
            &lt;version&gt;3.1.2.RELEASE&lt;/version&gt;
        &lt;/dependency&gt;
</pre>

        <p>Riippuvuus tuo käyttöömme muutamia hyödyllisiä apuvälineitä, joista eräs on <code><a href="http://static.springsource.org/spring/docs/current/javadoc-api/org/springframework/jdbc/core/JdbcTemplate.html" target="_blank">JdbcTemplate</a></code> (<a href="http://static.springsource.org/spring/docs/3.0.x/reference/jdbc.html">dokumentaatio</a>). Luokka <code>JdbcTemplate</code> hoitaa tietokantakyselyihin liittyviä toistuvia asioita puolestamme. Esimerkiksi tietokantayhteyden avaaminen, pyynnön suorittaminen, transaktioiden käsittely sekä yhteyden sulkeminen on luokan <code>JdbcTemplate</code> vastuulla.</p>

        <p><code>JdbcTemplate</code>-luokan konstruktori tarvitsee <code>DataSource</code>-olion parametrina. <code>DataSource</code>-olio injektoidaan yleensä <code>JdbcTemplate</code>-olion toiminnallisuutta käyttävälle luokalle. Oletetaan, että käytössämme on seuraavankaltainen tietokantataulu:</p>

        <p>
          <table border=1>
            <tr><th colspan="2">User</th></tr>
            <tr><th>name</th><th>password</th></tr>

            <tr><td>Arto</td><td>wateva!</td></tr>
            <tr><td>Matti</td><td>rails!</td></tr>
            <tr><td>Mikael</td><td>play!</td></tr>
          </table>
        </p>

        <p>Kyselyiden muodostaminen Springin <code>JdbcTemplate</code>-luokan avulla on helpohkoa. Luodaan luokka <code>UserDatabase</code> yllä kuvatun taulun käsittelyyn.</p>

<pre class="sh_java">
// ... importit

@Component
public class UserDatabase {

    private JdbcTemplate jdbcTemplate;

    @Autowired
    public final void setDataSource(DataSource dataSource) {
        this.jdbcTemplate = new JdbcTemplate(dataSource);
    }

    public void addUser(String name, String password) throws SQLException {
        this.jdbcTemplate.update("INSERT INTO User VALUES (?, ?)", name, password);
    }

    public List&lt;Map&lt;String, Object&gt;&gt; retrieveUsers() throws SQLException {
        return this.jdbcTemplate.queryForList("SELECT * FROM User");
    }
}    
</pre>

        <p>Oletetaan että käytössämme olevassa <code>beans.xml</code>-konfiguraatiossa on määritelty <code>DataSource</code>-olio sekä haettu annotoidut oliot käyttöön komennolla <code>&lt;context:component-scan base-package="&lt;pakkaus&gt;"&gt;</code>. Luokan <code>UserDatabase</code> käyttö onnistuu nyt oliokontekstin avulla.</p>

<pre class="sh_java">
        ApplicationContext appContext = new ClassPathXmlApplicationContext("beans.xml");
        UserDatabase database = (UserDatabase) appContext.getBean("userDatabase");

        database.addUser("Kasper", "spring!");

        List&lt;Map&lt;String, Object&gt;&gt; users = database.retrieveUsers();

        for (Map&lt;String, Object&gt; user : users) {
            String name = (String) user.get("name");
            String password = (String) user.get("password");

            System.out.println(name + "\t" + password);
        }
</pre>

<pre>
Arto      wateva!
Matti     rails! 
Mikael    play!  
Kasper    spring!
</pre>

<h4>RowMapper</h4>

        <p>Springin JDBC-komponentti tarjoaa myös tuen tulosten kytkemiseen olioihin. Oletetaan että käytössämme on seuraava luokka <code>User</code>:</p>

<pre class="sh_java">
// pakkaus

public class User {

    private String name;
    private String password;

    public String getName() {
        return name;
    }

    public void setName(String name) {
        this.name = name;
    }

    public String getPassword() {
        return password;
    }

    public void setPassword(String password) {
        this.password = password;
    }
}
</pre>

        <p>Kyselytulosten kytkeminen olioihin onnistuu <code>JdbcTemplate</code>n ja <code><a href="http://static.springsource.org/spring/docs/current/javadoc-api/org/springframework/jdbc/core/RowMapper.html" target="_blank">RowMapper</a></code>-rajapinnan avulla. Käytännössä <code>RowMapper</code> rajapinnan toteuttava luokka luo <code>ResultSet</code>-oliossa olevista tuloksista halutun tyyppisiä olioita. Luodaan oma <code>UserMapper</code>-luokka, joka toteuttaa rajapinnan <code>RowMapper</code>. Huomaa että rajapinnalle annetaan tyyppiparametrina luokka, johon tulokset kytketään.</p>

<pre class="sh_java">
// pakkaus ja mahdollisesti muita importteja
import java.sql.ResultSet;
import java.sql.SQLException;
import org.springframework.jdbc.core.RowMapper;

public class UserMapper implements RowMapper&lt;User&gt; {

    public User mapRow(ResultSet resultSet, int rowIndex) throws SQLException {
        User user = new User();
        user.setName(resultSet.getString("name"));
        user.setPassword(resultSet.getString("password"));

        return user;
    }
}
</pre>

        <p>Rajapinnan <code>RowMapper</code> toteuttavia luokkia käytetään Springin JdbcTemplatekyselyjen avulla seuraavasti:</p>

<pre class="sh_java">
        // ... jdbcTemplaten luonti dataSourcen avulla jne
        List&lt;User&gt; users = this.jdbcTemplate.query("SELECT * FROM User", new UserMapper());

        for(User user: users) {
            System.out.println(user.getName() + "\t" + user.getPassword());
        }
        // ...
</pre>


<div class="tehtavat">
<h3>JDBC Template SQL Queries</h3>

<p>Toteutetaan tässä tehtävässä tietokantatoiminnallisuutta Springin JDBC Templaten avulla.</p>

<h4>Metodit <code>listCourses</code> ja <code>listCoursesByName</code></h4>

<p>Toteuta luokkaan <code>CourseDatabase</code> metodit <code>listCourses</code> ja <code>listCoursesByName</code>.</p>

<p>
  <ul>
    <li>Metodin <code>listCourses</code> tulee hakea <code>jdbcTemplate</code>-olion avulla tietokannasta kaikki kurssit, ja antaa tuloksena saatu lista metodin <code>printCourses</code> tulostettavaksi.</li>

    <li>Metodin <code>listCoursesByName</code> tulee hakea <code>jdbcTemplate</code>-olion avulla tietokannasta kurssit, joiden nimi (<code>name</code>) on parametrina annettu merkkijono. Tulosta kyselyn tuloksena saatu lista metodin <code>printCourses</code> avulla.</li>
  </ul>
</p>

<h4>Uusi RowMapper-olio ja kurssiolioiden noutaminen</h4>

<p>Luo pakkaukseen <code>wad.jdbctemplatequeries</code> luokka <code>CourseRowMapper</code>, joka toteuttaa rajapinnan <code>RowMapper&lt;Course&gt;</code>. Toteuta luokkaan rajapinnan vaatima metodi <code>mapRow</code>, joka muuntaa tulosrivit <code>Course</code>-olioiksi.</p>

<p>Kun RowMapper-olio on valmis, muokkaa luokan <code>CourseDatabase</code> metodia <code>getCourses</code> siten, että siinä haetaan tietokannasta kaikki kurssit, muunnetaan ne <code>CourseRowMapper</code>-olion avulla <code>Course</code>-olioiksi, ja lopulta palautetaan ne.</p>

<p>Kun olet valmis, lähetä sovellus TMC:lle testattavaksi.</p>

</div>



<h3>"Olioita tietokannassa, häh?"</h3>


        <p>Huomaamme, että tietokantataulujen kuvaaminen luokkien avulla on oikeastaan aika loogista. Tietokantataulun nimi vastaa luokan nimeä ja taulun attribuutit (eli sarakkeiden nimet) ovat luokan attribuutteja. Jokainen luokasta luotava olio vastaa yhtä tietokantataulun riviä. Viitteet eri taulujen välillä voidaan taas kuvata viitteinä olioiden välillä.</p>

        <p>Sovelluksia suunniteltaessa yksi lähestymistapa ongelma-alueeseen on tallennettavaa tietoa kuvaavien olioiden luonti. Tämä tapahtuu luonnollisesti yhteistyössä asiakkaan kanssa, jolloin voidaan varmistaa että puhutaan asiakkaan ja ongelma-alueen käyttämällä kielellä. Tutkitaan seuraavaa lentokentän hallintajärjestelmän kuvausta:</p>

        <p><strong>Case: Lentokenttä</strong></p>

        <p>He told us: <em>"...Basically what we need is a system for monitoring aircrafts and airports. Each aircraft has a unique identifier, e.g. LOL-52, and a numeric capacity. Airports on the other hand reside in a location, have a unique identifier and a name, e.g. e.g. <code>LOL</code> for Derby Field United States and <code>FUN</code> for International Tuvalu. Each airport can host one or more aircrafts..."</em></p>

        <p>Ongelma-alueen purkaminen lähtee perinteisesti liikkeelle substantiivien etsimisellä.</p>

        <p>He told us: <em>"...Basically what we need is a <strong>system</strong> for monitoring <strong>aircrafts</strong> and <strong>airports</strong>. Each <strong>aircraft</strong> has a unique <strong>identifier</strong>, e.g. LOL-52, and a numeric <strong>capacity</strong>. <strong>Airports</strong> on the other hand reside in a <strong>location</strong>, have a unique <strong>identifier</strong> and a <strong>name</strong>, e.g. <code>LOL</code> for Derby Field United States and <code>FUN</code> for International Tuvalu. Each <strong>airport</strong> can host one or more <strong>aircrafts</strong>..."</em></p>

        <p>Tämän jälkeen substantiiveista erotetaan pääkäsitteet, pääkäsitteiden attribuutit, ja ei-oleelliset käsitteet. Pääkäsitteitä ovat <code>aircraft</code> ja <code>airport</code>, ja <code>system</code> on ei-oleellinen käsite. Loput ovat pääkäsitteiden attribuutteja.</p>

        <p>Pääkäsitteiden attribuutit löytyy etsimällä lisätietoa antavia lauseita (esim. <code>has a</code>, <code>in a</code>, ...). Yllä olevasta esimerkistä löytyy seuraavat käsitteet attribuutteineen.</p>

<pre>
Aircraft
 - identifier
 - capacity

Airport
 - location
 - identifier
 - name
</pre>

        <p>Tämän lisäksi lentokenttä (<code>Airport</code>) sisältää yhden tai useamman lentokoneen. Käsitteitä tietokantaan lisättäviksi olioiksi muunnettaessa jokaiselle luokalle lisätään yleensä numeerinen <code>id</code>-attribuutti, joka toimii taulun pääavaimena. Oliot olisivat lopulta esimerkiksi seuraavankaltaiset:</p>

<pre class="sh_java">
// pakkaus

public class Aircraft {

    private Long id;
    private String identifier;
    private Integer capacity;

    // getterit ja setterit
}
</pre>


<pre class="sh_java">
// pakkaus

public class Airport {

    private Long id;
    private String location;
    private String identifier;
    private String name;
    private List&lt;Aircraft&gt; aircrafts;
    
    // getterit ja setterit
}
</pre>


        <p>Luotujen käsitteiden pohjalta voidaan lähteä hahmottelemaan sovelluksen toimintaa. Oikeastaan tässäkään vaiheessa tietokannan käyttö ei ole vielä pakollista.</p>

        <h4>DAO-pattern</h4>

        <p>DAO-pattern (<em>Data Access Object</em>) on suunnittelumalli, jossa tiedon tallennusmekanismi kapseloidaan sovelluslogiikalle näkymättömäksi. DAO-rajapinnan ideana on mahdollistaa tallennusmekanismin helppo vaihtaminen: sovellus voi aluksi säilyttää olioita esimerkiksi muistissa -- rajapinnan käyttäjän ei tarvitse välittää toteutuksesta. Toteutetaan aiemmin esitellyille olioille DAO-oliot ja niihin liittyvät toteutukset. </p>

        <p>Käytetään perinteistä CRUD-tyyliä rajapintojen metodien nimeämiseen.</p>
        

<pre class="sh_java">
public interface AircraftDAO {
    Aircraft create(Aircraft object);
    Aircraft read(Long id);
    Aircraft update(Aircraft object);
    void delete(Long id);
}
</pre>

<pre class="sh_java">
public interface AirportDAO {
    Airport create(Airport object);
    Airport read(Long id);
    Airport update(Airport object);
    void delete(Long id);
}
</pre>

        <p>Huomaamme heti toistavamme itseämme. Refaktoroidaan rajapinnoista erillistä tyyppiparametria käyttävä yleishyödyllinen rajapinta <code>DAO</code>.</p>

<pre class="sh_java">
public interface DAO&lt;T&gt; {
    T create(T object);
    T read(Long id);
    T update(T object);
    void delete(Long id);
}
</pre>

        <p>Nyt aiemmat rajapinnat <code>AircraftDAO</code> ja <code>AirportDAO</code> voidaan muuttaa seuraavanlaisiksi.</p>

<pre class="sh_java">
public interface AircraftDAO extends DAO&lt;Aircraft&gt; {
}
</pre>

<pre class="sh_java">
public interface AirportDAO extends DAO&lt;Airport&gt; {
}
</pre>

        <p>Luodaan ensimmäinen DAO-toteutus, lentokoneiden tallentamiseen. Koska voimme vaihtaa toteutusta lennossa, tehdään ensimmäinen versio sellaiseksi, että siinä ei ole oikeaa tallennuslogiikkaa. Tiedot tallennetaan <code>AircraftDAO</code>-toteutuksen kapseloimaan <code>Map</code>-tyyppiseen olioon.</p>

<pre class="sh_java">
@Component
public class InMemoryAircraftDAO implements AircraftDAO {
 
    private Map&lt;Long, Aircraft&gt; aircrafts = new TreeMap&lt;Long, Aircraft&gt;();
    private static Long COUNTER = new Long(0);


    @Override
    public Aircraft create(Aircraft object) {
        if (object.getId() != null) {
            throw new IllegalArgumentException("A new object should not have an ID");
        }

        COUNTER++;
        object.setId(COUNTER);
        aircrafts.put(object.getId(), object);

        return object;
    }

    @Override
    public Aircraft read(Long id) {
        return aircrafts.get(id);
    }

    @Override
    public Aircraft update(Aircraft object) {
        if (object.getId() == null) {
            throw new IllegalArgumentException("An object to be updated should have an ID");
        }

        aircrafts.put(object.getId(), object);
        return object;
    }

    @Override
    public void delete(Long id) {
        aircrafts.remove(id);
    }
}
</pre>

        <p>Käytössämme on nyt luokka <code>AircraftDAO</code>, joka tarjoaa toiminnallisuuden lentokone-olioiden muistiin tallentamiseen. Jos haluamme vaihtaa toteutuksen, meidän tulee luoda toinen toteutus rajapinnalle. Esimerkiksi tiedostoja käyttävä luokka <code>FileAircraftDAO</code>, joka tallentaisi lentokoneet tiedostoon. Huomaa, että Springin oliokontekstia käyttäessä joudumme määrittelemään komponentille erillisen tunnuksen, jotta olion automaattinen asetus onnistuu.</p>

<pre class="sh_java">
@Component(value="fileAircraftDAO")
public class FileAircraftDAO implements AircraftDAO {
    // ...
}
</pre>

        <p>Myös muistia käyttävälle toteutukselle tulee määritellä oma nimi.</p>

<pre class="sh_java">
// ...
@Component(value = "inMemoryAircraftDAO")
public class InMemoryAircraftDAO implements AircraftDAO {
    // ...
</pre>

        <p>Nyt voimme käyttää <code>@Autowired</code>-annotaation lisäksi <code>@Qualifier</code>-annotaatiota, jolla kerrotaan mikä toteutus halutaan käyttöön. Alla olevaan <code>Application</code> luokkaan injektoitaisiin <code>InMemoryAircraftDAO</code>-luokan toteutus.</p>

<pre class="sh_java">
// ...
@Component
public class Application {

    @Autowired
    @Qualifier("inMemoryAircraftDAO")
    private AircraftDAO aircraftDao;

    // ...
</pre>


<div class="tehtavat">
  <h3>In-memory DAO</h3>

  <p></p>

  <h4>Album</h4>

  <p>Täydennä musiikkialbumia kuvaavaa luokkaa <code>wad.inmemorydao.Album</code> siten, että sillä on seuraavat attribuutit, sekä vastaavat getter- ja setter-metodit:
  <ul>
    <li><code>id</code> - uniikki merkkijonotunnus, jonka perusteella albumi voidaan tunnistaa</li>
    <li><code>artist</code> - albumin artistin nimi</li>
    <li><code>name</code> - itse albumin nimi</li>
    <li><code>year</code> - albumin julkaisuvuosi <code>int</code>-kokonaislukuna</li>
  </ul></p>

  <h4>InMemoryAlbumDAO</h4>

  <p>Luo luokka <code>wad.inmemorydao.InMemoryAlbumDAO</code>, joka toteuttaa tehtäväpohjassa annetun rajapinnan <code>wad.inmemorydao.AlbumDAO</code>. Lisää luokalle vielä annotaatio <code>Component</code>, jotta Spring tunnistaa sen. Tämän DAO-luokan tulee tallettaa <code>Album</code>-oliot muistiin Javan <code>HashMap</code>-hajautustaulun avulla. Hajautustaulun avaimena tulee luonnollisesti käyttää albumin ID-tunnistetta. Luokan metodien tulee toimia seuraavalla tavalla:
    <ul>
      <li><code>create</code> tallettaa annetun albumin hajautustauluun. Jotta albumeille saataisiin yhdenmukaiset uniikit ID-tunnisteet, on järkevää generoida ja asettaa ne tässä metodissa. Käytä ID-tunnisteena Javan tarjoamaa generaattoria <code>UUID.randomUUID()</code>. Jos parametrina annetulla albumilla on jo tunniste, tulee metodin heittää poikkeus <code>IllegalArgumentException</code>.<br/><br/></li>
      <li><code>update</code> päivittää hajautustauluun uuden albumin ID-tunnuksen perusteella. Jos parametrina annetulla albumilla ei ole tunnistetta, tulee metodin heittää poikkeus <code>IllegalArgumentException</code>.<br/><br/></li>
      <li><code>read</code> palauttaa albumin, jolla on annettu ID-tunnus. Jos ID-tunnuksella ei löydy albumia, palauttaa metodi <code>null</code>-viitteen.<br/><br/></li>
      <li><code>delete</code> poistaa albumin, jolla on annettu ID-tunnus. Jos ID-tunnuksella ei löydy albumia, metodi ei tee mitään.<br/><br/></li>
      <li><code>list</code> palauttaa listan talletetuista albumeista. Jotta metodi toimisi oikein, tulee sen kopioida hajautustaulussa olevat albumit uuteen listaan ja palauttaa se. Palautettujen albumien järjestyksellä ei ole merkitystä.<br/><br/></li>
    </ul></p>
  
  <h4>AlbumApplication</h4>

  <p>Tehdään vielä lopuksi ohjelmaan hieman toiminnallisuutta, joka käyttää edellä tehtyä <code>AlbumDAO</code>-toteutusta.</p>

  <p>Luo luokka <code>wad.inmemorydao.AlbumApplication</code>, joka toteuttaa tehtäväpohjassa annetun rajapinnan <code>wad.inmemorydao.Application</code>. Lisää luokalle vielä annotaatio <code>Component</code>, jotta Spring tunnistaa sen. Luokan tulee injektoida itselleen käyttöön <code>AlbumDAO</code>-toteutus. Luokan metodien tulee toimia seuraavalla tavalla:
    <ul>
      <li><code>populateAlbums</code> luo ja tallettaa vähintään neljä albumia, joiden nimi, artisti ja vuosi tulee olla määriteltyjä. Vuoden tulee olla suurempi kuin 1900. Voit itse keksiä albumien loput tiedot.<br/><br/></li>
      <li><code>deleteAlbumsFromArtist</code> poistaa albumit, joiden artistina on metodille parametrina annettu artistin nimi</li>
    </ul></p>

  <p><strong>Huom!</strong> Tehtäväpohjan luokassa <code>Main</code> on lisäksi hieman testausta helpottavaa koodia, jonka avulla voit tulostaa DAO-luokan varastoimia albumeja. Esimerkkikoodi poistaa kaikki albumit, joiden artisti on "Scorpions" ja tulostaa jäljelle jääneet albumit.</p>
  
</div>



<h3>Object Relational Mapping ja JPA</h3>
          

        <p>ORM-työkalut (<em>Object Relational Mapping</em>) tarjoavat mm. toiminnallisuuden tietokantataulujen luomiseen määritellyistä luokista. Työkalut hallinnoivat luokkien välisiä viittauksia ja ylläpitävät mm. tietokannan eheyttä. Käyttäjän vastuulle jää yleensä sovellukselle tarpeellisten kyselyiden toteuttaminen niiltä osin kun niitä ei tarjota valmiiksi.</p>

        <p>Relaatiotietokantojen käsittelyyn on kehitetty joukko ORM-sovelluksia joista nimekkäin lienee Hibernate. Oracle/Sun standardoi olioiden tallentamisen relaatiotietokantoihin <a href="http://en.wikipedia.org/wiki/Java_Persistence_API" target="_blank">JPA</a> (<em>Java Persistence API</em>) -standardilla. JPA:n toteuttavat kirjastot (esim. <a href="http://www.hibernate.org/" target="_blank">Hibernate</a>, <a href="http://www.eclipse.org/eclipselink/" target="_blank">EclipseLink</a>) abstrahoivat relaatiotietokannan, ja mahdollistavat kyselyjen tekemisen suoraan ohjelmakoodista.

        <p>Käytämme tällä kurssilla <code>EclipseLink</code>-kirjaston versiota <code>2.4.0</code>, jonka saa käyttöön lisäämällä projektiin seuraavat riippuvuudet. Alempi riippuvuus tuo käyttöön <code>JPA2</code>-APIn.</p>

<pre class="sh_xml">
        &lt;dependency&gt;
            &lt;groupId&gt;org.eclipse.persistence&lt;/groupId&gt;
            &lt;artifactId&gt;eclipselink&lt;/artifactId&gt;
            &lt;version&gt;2.4.0&lt;/version&gt;
        &lt;/dependency&gt;

        &lt;dependency&gt;
            &lt;groupId&gt;org.eclipse.persistence&lt;/groupId&gt;
            &lt;artifactId&gt;javax.persistence&lt;/artifactId&gt;
            &lt;version&gt;2.0.0&lt;/version&gt;
        &lt;/dependency&gt;
</pre>

        <p>EclipseLink-riippuvuudet eivät ole yleisesti käytössä olevissa riippuvuusvarastoissa. Joudumme lisäämään <code>pom.xml</code>-tiedostoon myös Eclipsen oman repository-osoitteen.</p>

<pre class="sh_xml">
    &lt;repositories&gt;
        &lt;!-- muut määritellyt latauspaikat --&gt;
        &lt;repository&gt;
            &lt;id&gt;eclipselink repo&lt;/id&gt;
            &lt;url&gt;http://download.eclipse.org/rt/eclipselink/maven.repo&lt;/url&gt;
        &lt;/repository&gt;
    &lt;/repositories&gt;
</pre>

        <h4>Tallennettavat oliot</h4>

        <p>Muunnetaan luokka <code>Aircraft</code> <em>entiteetiksi</em>, eli olioksi jonka voi tallentaa JPA:n avulla tietokantaan.</p>

<pre class="sh_java">
// pakkaus

public class Aircraft {

    private Long id;
    private String identifier;
    private Integer capacity;

    // getterit ja setterit
}
</pre>


        <p>Jokaisella tietokantaan tallennettavalla oliolla tulee olla annotaatio <code>@Entity</code>. Annotaation <code>@Entity</code> lisäksi jokaisella tallennettavalla luokalla on oltava <code>@Id</code>-annotaatiolla merkattu kenttä, joka toimii tietokantataulun ensisijaisena avaimena. JPA:ta käytettäessä <code>id</code>-attribuutti on usein numeerinen (<code>Long</code> tai <code>Integer</code>), mutta merkkijonojen käyttö on yleistymässä.</p>


        <p>Numeeriselle avainattribuutille voidaan lisäksi määritellä annotaatio <code>@GeneratedValue(strategy = GenerationType.AUTO)</code>, joka antaa id-kentän arvojen luomisen vastuun tietokannalle. Muokataan luokkaa Aircraft vielä siten, että se toteuttaa rajapinnan Serializable, ja lisätään sille tyhjä konstruktori. Luokka näyttää nyt seuraavalta:</p>


<pre class="sh_java">
// pakkaus

import java.io.Serializable;
import javax.persistence.Entity;
import javax.persistence.GeneratedValue;
import javax.persistence.GenerationType;
import javax.persistence.Id;

@Entity
public class Aircraft implements Serializable {

    @Id
    @GeneratedValue(strategy = GenerationType.AUTO)
    private Long id;
    private String identifier;
    private Integer capacity;

    // getterit ja setterit
}
</pre>


        <p>Koska haluamme, että tietokantataulumme ovat selkeitä, ja sarakkeiden nimet kuvaavia, määritellään ne tarkemmin <code>@Column</code>-annotaation avulla. Lisätään luokalle myös <code>@Table</code>-annotaatio, jonka avulla määritellään luotavan tietokantataulun nimi.</p>

<pre class="sh_java">
// pakkaus

import java.io.Serializable;
import javax.persistence.Column;
import javax.persistence.Entity;
import javax.persistence.GeneratedValue;
import javax.persistence.GenerationType;
import javax.persistence.Id;
import javax.persistence.Table;

@Entity
@Table(name = "Aircraft")
public class Aircraft implements Serializable {

    @Id
    @GeneratedValue(strategy = GenerationType.AUTO)
    @Column(name = "id")
    private Long id;
    @Column(name = "identifier")
    private String identifier;
    @Column(name = "capacity")
    private Integer capacity;

    // getterit ja setterit
</pre>
        
        <p>Käytössämme on nyt täysiverinen tietokantaan tallennettava olio.</p> 


        <h4>JPA:n konfiguraatio: persistence.xml</h4>


        <p>JPA:n konfigurointi tapahtuu <code>persistence.xml</code>-nimisen tiedoston avulla. Tiedosto <code>persistence.xml</code> asetetaan kansioon NetBeansissa näkyvään Other Sources-kansion (kansio <code>/src/main/resources/</code>) sisälle <code>META-INF</code>-kansioon. Alla olevassa konfiguraatiossa tiedostoon <code>persistence.xml</code> on määritelty käytettävän tietokannan osoite sekä hallinnoitavat entiteetit. Käytössämme on EclipseLink.</p>


<pre class="sh_xml">
&lt;?xml version="1.0" encoding="UTF-8"?&gt;
&lt;persistence version="2.0" xmlns="http://java.sun.com/xml/ns/persistence" 
             xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" 
             xsi:schemaLocation="http://java.sun.com/xml/ns/persistence                  
                http://java.sun.com/xml/ns/persistence/persistence_2_0.xsd"&gt;
    &lt;persistence-unit name="persistenceUnit" transaction-type="RESOURCE_LOCAL"&gt;
        &lt;provider&gt;org.eclipse.persistence.jpa.PersistenceProvider&lt;/provider&gt;

        <strong>&lt;class&gt;pakkaus.Aircraft&lt;/class&gt;</strong>

        &lt;exclude-unlisted-classes&gt;true&lt;/exclude-unlisted-classes&gt;
        &lt;properties&gt;
            &lt;property name="eclipselink.logging.level" value="FINE"/&gt;
            &lt;property name="eclipselink.ddl-generation" value="drop-and-create-tables"/&gt;
            &lt;property name="javax.persistence.jdbc.driver" value="org.h2.Driver"/&gt;
            &lt;property name="javax.persistence.jdbc.url" value="<strong>jdbc:h2:mem:inmemorydb</strong>"/&gt;
            &lt;property name="javax.persistence.jdbc.user" value="SA"/&gt;
            &lt;property name="javax.persistence.jdbc.password" value=""/&gt;
        &lt;/properties&gt;
    &lt;/persistence-unit&gt;
&lt;/persistence&gt;
</pre>

        <p>Konfiguraatiossa määrittelee käyttöömme muistiin ladattavan tietokannan sekä <code>Aircraft</code>-luokan. Konfiguraation nimi (<em>persistence-unit name</em>) on <code>persistenceUnit</code>. Luodaan ensimmäinen esimerkkisovellus, jossa luokan <code>Aircraft</code> ilmentymä tallennetaan tietokantaan. Ohjelmassa käytetyt luokat selitetään hieman myöhemmin.</p>

<pre class="sh_java">
// pakkaus

import javax.persistence.EntityManager;
import javax.persistence.EntityManagerFactory;
import javax.persistence.Persistence;

public class Main {
    public static void main(String[] args) throws Exception {
        EntityManagerFactory emf = Persistence.createEntityManagerFactory("persistenceUnit");
        EntityManager em = emf.createEntityManager();
        Aircraft craft = em.find(Aircraft.class, new Long(1));
        
        if(craft == null) {
            System.out.println("Not found :(");
        } else {
            System.out.println("Found!");
        }
        
        Aircraft airforceOne = new Aircraft();
        airforceOne.setCapacity(1);
        airforceOne.setIdentifier("Air Force One");

        // luodaan transaktio tallennusoperaation ajaksi 
        em.getTransaction().begin();
        airforceOne = em.merge(airforceOne);
        em.getTransaction().commit();

        System.out.println("Aircraft inserted to the database.");
        System.out.println("Autogenerated id: " + airforceOne.getId());
        System.out.println("Identifier: " + airforceOne.getIdentifier());

        
        craft = em.find(Aircraft.class, new Long(1));
        
        if(craft == null) {
            System.out.println("Not found :(");
        } else {
            System.out.println("Found!");
        }
    }
}
</pre>

        <p>Sovellusta suoritettaessa näemme seuraavanlaisen tulostuksen (tulostusta "hieman" siistitty):</p>

<pre>
[EL Fine]: sql: CREATE TABLE Aircraft (id BIGINT NOT NULL, capacity INTEGER, identifier VARCHAR, PRIMARY KEY (id))
...
[EL Fine]: sql: SELECT id, capacity, identifier FROM Aircraft WHERE (id = ?)
        bind => [1]
<strong>Not found :(</strong>
[EL Fine]: sql: --INSERT INTO Aircraft (id, capacity, identifier) VALUES (?, ?, ?)
        bind => [1, 1, Air Force One]
...
Aircraft inserted to the database.
Autogenerated id: <strong>1</strong>
Identifier: Air Force One
<strong>Found!</strong>
</pre>

        <p>JPA luo tietokantataulua kuvaavan <code>Aircraft</code>-luokan käsittelyyn tarvittavat SQL-kyselyt, jotka se suorittaa automaattisesti ohjelmassa käytettyjen kyselyiden aikana. Tutkitaan seuraavaksi pikaisesti käytettyjä luokkia.</p>


        <h4>Persistence ja EntityManagerFactory</h4>

        
        <p>Luokkaa <code><a href="http://docs.oracle.com/javaee/6/api/javax/persistence/Persistence.html" target="_blank">Persistence</a></code> käytetään <code>EntityManagerFactory</code>-olion ohjelmalliseen luomiseen. <code>Persistence</code>-luokan luokkametodille <code>createEntityManagerFactory</code> annetaan parametrina käytettävän konfiguraation nimi, jonka perusteella tiedostosta <code>persistence.xml</code> etsitään oikea konfiguraatio. Luokkaa <code>Persistence</code> käytetään vain silloin, jos sovellusta halutaan käyttää erillisenä web-ympäristöstä (esim. yllä ollut demo) -- web-kontekstissa tarvittavat luokat injektoidaan automaattisesti.</p>

        <p>Luokka <code><a href="http://docs.oracle.com/javaee/6/api/javax/persistence/EntityManagerFactory.html" target="_blank">EntityManagerFactory</a></code> on tehdasluokka, josta saadaan entiteettien tallentamista hallinnoivia <code><a href="http://docs.oracle.com/javaee/6/api/javax/persistence/EntityManager.html" target="_blank">EntityManager</a></code>-olioita.</p>


        <h4>EntityManager</h4>


        <p><code>EntityManager</code> hallinnoi entiteettejä ja niiden tallennusta tietokantaan. Sovelluskehys -- tai sovelluskehittäjä -- luo <code>EntityManager</code>-olion tarpeen vaatiessa. <code>EntityManager</code> tarjoaa joukon palveluita, joista oleellisimmat ovat olion tietokantaan lisääminen (metodit <code>persist</code> ja <code>merge</code>), poistaminen (metodi <code>remove</code>) ja hakeminen (metodi <code>find</code>).</p>

        <p><code>EntityManager</code> tarjoaa toiminnallisuuden tietokantatransaktioiden hallintaan. Metodi <code>getTransaction()</code> palauttaa <code><a href="http://docs.oracle.com/javaee/6/api/javax/persistence/EntityTransaction.html" target="_blank">EntityTransaction</a></code>-olion, jota käytetään transaktioden aloittamiseen (metodi <code>begin</code>) ja lopettamiseen (metodi <code>commit</code>).</p>


        <h3>JPA ja Web</h3>


        <p>Tutustutaan seuraavaksi samaan, mutta tällä kertaa web-kontekstissa. Koska käytämme Inversion of Control-tyyliä tukevaa sovelluskehystä, haluamme että käytettävät oliot luodaan meille automaattisesti. Spring tarjoaa ORM-tuen, jonka saa käyttöön lisäämällä riippuvuuden spring-orm <code>pom.xml</code>-tiedostoon. Oletamme, että myös aiemmin mainitut riippuvuudet ovat käytössä.</p>


<pre class="sh_xml">
        &lt;dependency&gt;
            &lt;groupId&gt;org.springframework&lt;/groupId&gt;
            &lt;artifactId&gt;spring-orm&lt;/artifactId&gt;
            &lt;version&gt;3.1.2.RELEASE&lt;/version&gt;
        &lt;/dependency&gt;
</pre>


        <h4>Springin konfiguraatio: front-controller-servlet.xml</h4>


        <p>Muutetaan seuraavaksi <code>front-controller-servlet.xml</code>-tiedostossa olevaa konfiguraatiota siten, että siellä luodaan <code>DataSource</code>-olio, <code>EntityManagerFactory</code>-olio, sekä JPA-transaktioita hallinnoiva <code>JpaTransactionManager</code>-olio. Näiden lisäksi määritellään erilliset tietokantapoikkeuksien käsittelyyn käytettävät luokat. Tiedosto <code>front-controller-servlet.xml</code> kokonaisuudessaan:</p>

<pre class="sh_xml">
&lt;?xml version="1.0" encoding="UTF-8"?&gt;
&lt;beans xmlns="http://www.springframework.org/schema/beans"
       xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
       xmlns:context="http://www.springframework.org/schema/context"
       xmlns:tx="http://www.springframework.org/schema/tx"
       xmlns:jdbc="http://www.springframework.org/schema/jdbc"
       xsi:schemaLocation="http://www.springframework.org/schema/beans
                            http://www.springframework.org/schema/beans/spring-beans-3.1.xsd
                            http://www.springframework.org/schema/context
                            http://www.springframework.org/schema/context/spring-context-3.1.xsd
                            http://www.springframework.org/schema/tx
                            http://www.springframework.org/schema/tx/spring-tx-3.1.xsd
                            http://www.springframework.org/schema/jdbc
                            http://www.springframework.org/schema/jdbc/spring-jdbc-3.1.xsd"&gt;

    &lt;!-- Sovelluksemme lähdekooditiedostot sijaitsevat wad tai sen alipakkauksissa--&gt;
    &lt;context:component-scan base-package="wad" /&gt;

    &lt;!-- Ladataan käyttöön springin view-resolver: luokka, jota käytetään
    näkymätiedostojen päättelyyn --&gt;    
    &lt;!-- Nyt Controller-luokkien metodeissa palautettu merkkijono määrittää
    JSP-tiedoston, joka näytetään --&gt;
    &lt;bean class="org.springframework.web.servlet.view.InternalResourceViewResolver"&gt;
        &lt;property name="prefix" value="/WEB-INF/jsp/" /&gt;
        &lt;property name="suffix" value=".jsp" /&gt;
    &lt;/bean&gt;

    &lt;!-- lyhennetty versio BasicDataSource-olion luomisesta --&gt;
    &lt;jdbc:embedded-database id="dataSource" type="H2"/&gt;

    &lt;!-- käytämme persistence.xml -tiedostossa olevaa persistenceUnit-konfiguraatiota, 
            dataSource injektoidaan luotavaan entityManagerFactory-olioon, ja 
            JPA-apin toteuttaja on EclipseLink --&gt;
    &lt;bean id="entityManagerFactory" class="org.springframework.orm.jpa.LocalContainerEntityManagerFactoryBean"&gt;
        &lt;property name="persistenceUnitName" value="persistenceUnit" /&gt; 
        &lt;property name="dataSource" ref="dataSource" /&gt;
        &lt;property name="jpaVendorAdapter"&gt;
            &lt;bean class="org.springframework.orm.jpa.vendor.EclipseLinkJpaVendorAdapter"/&gt;
        &lt;/property&gt;
    &lt;/bean&gt;

    &lt;!-- Hallinnoidaan transaktioita automaattisesti --&gt;
    &lt;bean id="transactionManager" class="org.springframework.orm.jpa.JpaTransactionManager"&gt;
        &lt;property name="entityManagerFactory" ref="entityManagerFactory"/&gt;
    &lt;/bean&gt;

    &lt;!-- Transaktioiden hallinta voidaan määritellä annotaatioilla --&gt;
    &lt;tx:annotation-driven transaction-manager="transactionManager" /&gt;

    &lt;!-- Muunnetaan tietokantaspesifit poikkeukset yleisemmiksi --&gt;
    &lt;bean class="org.springframework.orm.jpa.support.PersistenceAnnotationBeanPostProcessor"/&gt;
    &lt;bean class="org.springframework.dao.annotation.PersistenceExceptionTranslationPostProcessor"/&gt;
&lt;/beans&gt;
</pre>

        <h4>JPA:n konfiguraatio: persistence.xml</h4>


        <p>Kun sovellus toimii palvelinympäristössä, tiedoston <code>persistence.xml</code> ei tarvitse sisältää tallennettavia luokkia. Tietokantayhteys on asetettu valmiiksi <code>EntityManagerFactory</code>-olion käyttöön, joten tietokantakonfiguraatiotakaan ei tarvitse <code>persistence.xml</code>-tiedostoon. Muutetaan tiedosto <code>persistence.xml</code> seuraavanlaiseksi:</p>


<pre class="sh_xml">
&lt;?xml version="1.0" encoding="UTF-8"?&gt;
&lt;persistence version="2.0" xmlns="http://java.sun.com/xml/ns/persistence" 
             xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" 
             xsi:schemaLocation="http://java.sun.com/xml/ns/persistence
                                 http://java.sun.com/xml/ns/persistence/persistence_2_0.xsd"&gt;

    &lt;persistence-unit name="persistenceUnit" transaction-type="RESOURCE_LOCAL"&gt;
        &lt;properties&gt;
            &lt;property name="showSql" value="true"/&gt;
            &lt;!-- sovellusta käynnistettäessä tietokantataulut luodaan uudestaan --&gt;
            &lt;property name="eclipselink.ddl-generation" value="drop-and-create-tables"/&gt;
            &lt;property name="eclipselink.ddl-generation.output-mode" value="database"/&gt;
            &lt;!-- ei yritetä optimoida tietokantaolioita --&gt;            
            &lt;property name="eclipselink.weaving" value="false"/&gt;
            &lt;!-- logiin kirjoitettavien viestien taso on "FINE" --&gt;
            &lt;property name="eclipselink.logging.level" value="FINE"/&gt;
        &lt;/properties&gt;
    &lt;/persistence-unit&gt;
&lt;/persistence&gt;
</pre>


        <p>Tässä vaiheessa lienee hyvä mainita, että <strong>konfiguraatioon liittyviä kysymyksiä ei ole kokeessa</strong>.</p>
        

        <h4>Ensimmäinen JPA:ta käyttävä DAO</h4>


        <p>Spring injektoi <code>EntityManager</code>-olion sovellukselle <code>@PersistenceContext</code>-annotaation avulla. Luodaan rajapinnan <code>AircraftDAO</code> toteuttava luokka <code>JpaAircraftDAO</code>, joka käyttää JPA:ta olioiden tallentamiseen tietokantaan. Huomaa, että annotoimme luokan annotaatiolla <code>@Repository</code> aiemmin käytetyn annotaation <code>@Component</code> sijaan. Spring muuntaa <code>@Repository</code>-annotaatioilla merkityissä luokissa tapahtuvat tietokantapoikkeukset ihmisystävällisemmiksi, sekä injektoi <code>EntityManager</code>-olion annotaatiolla <code>@PersistenceContext</code> merkittyyn olioon.</p>

<pre class="sh_java">
// pakkaus

import javax.persistence.EntityManager;
import javax.persistence.PersistenceContext;
import org.springframework.stereotype.Repository;
import org.springframework.transaction.annotation.Transactional;

@Repository
@Transactional
public class JpaAircraftDAO implements AircraftDAO {

    @PersistenceContext
    private EntityManager entityManager;

    public Aircraft create(Aircraft object) {
        return entityManager.merge(object);
    }

    public Aircraft read(Long id) {
        return entityManager.find(Aircraft.class, id);
    }

    public Aircraft update(Aircraft object) {
        return entityManager.merge(object);
    }

    public void delete(Long id) {
        Aircraft craft = read(id);
        if(craft != null) {
            entityManager.remove(craft);
        }
    }
}
</pre>

        <p>Yllä on kaikki koodi mitä <code>Aircraft</code>-olioiden tietokantaan tallentamiseen tarvitaan.</p>

        <p>Annotaatiolla <code>@Transactional</code> määrittelemme, että jokainen luokan metodi suoritetaan omassa transaktiossa. Huomaat todennäköisesti, että käytämme <code>EntityManager</code>-olion <code>merge</code>-metodia useassa paikassa. Metodi <code>merge</code> luo olion tietokantaan, jos se ei ole jo tietokannassa. Jos olio on jo tietokannassa, se päivittää olion tilan tietokantaan. Metodi palauttaa viitteen tietokannassa olevaan olioon.</p>



        <h4>Spring ja transaktiot</h4>


        <p>Spring tarjoaa apuvälineitä transaktioiden hallintaan. Luokka <code>JpaTransactionManager</code> delegoi transaktioiden käsittelyn <code>EntityManager</code>-olioille. Käytännössä transaktiot voidaan määritellä metodi- tai luokkatasolla annotaation <code>@Transactional</code> avulla. Tällöin annotaatiolla <code>@Transactional</code> merkittyä metodia suoritettaessa metodin alussa aloitetaan tietokantatransaktio, jossa tehdyt muutokset viedään tietokantaan metodin lopussa. Jos annotaatio <code>@Transactional</code> määritellään luokkatasolla, se koskee jokaista luokan metodia.</p>

<pre class="sh_java">
// pakkaus

@Repository
@Transactional
public class JpaAircraftDAO implements AircraftDAO {

    @PersistenceContext
    private EntityManager entityManager;

    public Aircraft create(Aircraft object) {
        return entityManager.merge(object);
    }

    public Aircraft read(Long id) {
        return entityManager.find(Aircraft.class, id);
    }

    // ...
</pre>

        <p>Käytännössä emme kuitenkaan halua jokaiselle metodille transaktiota, jossa tietokantamuutosten tekeminen on mahdollista. Annotaatiolle <code>@Transactional</code> voidaan määritellä parametrin <code>readOnly</code> avulla kirjoitetaanko muutokset tietokantaan. Jos parametrin <code>readOnly</code> arvo on <code>true</code>, metodiin liittyvä transaktio perutaan metodin lopussa (rollback). Tällöin metodi ei yksinkertaisesti voi muuttaa tietokannassa olevaa tietoa. Muunnetaan ylläoleva luokka sellaiseksi, että metodi <code>create</code> käyttää tietokantaa muokkaavaa transaktiota, mutta metodissa <code>read</code> ei voi tehdä tietokantamuutoksia.</p>


<pre class="sh_java">
// pakkaus

@Repository
public class JpaAircraftDAO implements AircraftDAO {

    @PersistenceContext
    private EntityManager entityManager;

    @Transactional(readOnly=false)
    public Aircraft create(Aircraft object) {
        return entityManager.merge(object);
    }

    @Transactional(readOnly=true)
    public Aircraft read(Long id) {
        return entityManager.find(Aircraft.class, id);
    }

    // ...
</pre>


        <h4>JPQL</h4>


        <p><a href="http://en.wikipedia.org/wiki/Java_Persistence_Query_Language" target="_blank">JPQL</a> (<em>Java Persistence Query Language</em> on kyselykieli, jonka avulla <code>@Entity</code>-annotaatioilla merkittyjen luokkien instansseja voidaan hakea tietokannasta. Kyselyt ovat SQL-kyselyiden kaltaisia, mutta JPQL ei tue kaikkia SQL-kielen ominaisuuksia. <code>EntityManager</code>-ilmentymän avulla on mahdollista kirjoittaa myös puhtaita SQL-kyselyitä. Kaikki <code>Aircraft</code>-oliot listaava kysely on seuraavanlainen.</p>

<pre>
SELECT a FROM Aircraft a
</pre>

        <p><code>EntityManager</code>-luokan ilmentymän avulla voimme hakea listan esineitä vastaavasti.</p>

<pre class="sh_java">
String queryString = "SELECT a FROM Aircraft a";
Query query = entityManager.createQuery(queryString);
List&lt;Aircraft&gt; aircrafts = query.getResultList();
</pre>

        <p>Ehtojen lisääminen tapahtuu parametrien avulla</p>

<pre class="sh_java">
String queryString = "SELECT a FROM Aircraft a WHERE a.capacity = :capacity";
Query query = entityManager.createQuery(queryString);
query.setParameter("capacity", 33);
List&lt;Aircraft&gt; aircrafts = query.getResultList();
</pre>

        <p>Huom! Kyselyissä käytettävä <code>Aircraft</code> on entiteetin nimi, ei tietokantataulun nimi. Jos <code>@Entity</code>-annotaatiolle ei määritellä <code>name</code>-attribuuttia, entiteetin nimenä käytetään oletuksena luokan nimeä.</p>

        <h4>Ajan tallentaminen</h4>

        <p>Aikaa kuvaavat attribuutit tulee annotoida <code><a href="http://docs.oracle.com/javaee/6/api/javax/persistence/Temporal.html" target="_blank">@Temporal</a></code>-annotaatiolla, joka määrittelee mikä osa ajasta tallennetaan. Annotaatiolle annetaan parametrina <code><a href="http://docs.oracle.com/javaee/6/api/javax/persistence/TemporalType.html" target="_blank">TemporalType</a></code>-tyyppinen arvo, joka kertoo tarkemman tallennusmuodon. Arvo <code>TemporalType.DATE</code> tallentaa päivämäärän (esim. 2012-09-15), <code>TemporalType.TIME</code> tallentaa kellonajan (esim. 18:00:00), ja arvo <code>TemporalType.TIMESTAMP</code> tallentaa päivän ja ajan (esim. 2012-09-15 18:00:00).</p>

        <p>Annotaatiolla <code>@Temporal</code> merkityn attribuutin tulee olla joko tyyppiä <code>java.util.Date</code> tai tyyppiä <code>java.util.Calendar</code>. Alla on määritelty entiteettiluokka <code>GroceryItem</code>, joka kuvaa elintarviketta. Elintarvikkeella on myös parasta ennen-päivämäärä (bestBeforeDate).</p>

<pre class="sh_java">
// pakkaus

import java.io.Serializable;
import java.util.Date;
import javax.persistence.Column;
import javax.persistence.Entity;
import javax.persistence.GeneratedValue;
import javax.persistence.GenerationType;
import javax.persistence.Id;
import javax.persistence.Table;
import javax.persistence.Temporal;
import javax.persistence.TemporalType;

@Entity
@Table(name = "GroceryItem")
public class GroceryItem implements Serializable {

    @Id
    @GeneratedValue(strategy = GenerationType.AUTO)
    @Column(name = "id")
    private Long id;
    @Column(name = "name")
    private String name;
    @Column(name = "best_before")
    @Temporal(TemporalType.DATE)
    private Date bestBefore;
    
    // getterit ja setterit
}
</pre>


        <h4>Merkkijonot entiteettien avaimina</h4>


        <p>Joissain tapauksissa entiteettien avainarvot halutaan saada tietoon jo ennen tietokantaan tallentamista. Tällöin avainarvoina käytetään sovelluksen itse luomaa mahdollisimman yksilöivää arvoa. Jos avainarvoja ei luoda tietokannan toimesta, on mahdollista että useammalla entiteetillä on sama avainarvo. Tällöin pyritään siihen, että saman avainarvon kahdesti luomisen todennäköisyys on mahdollisimman pieni.</p>

        <p>Yleisin ratkaisu satunnaisen avaimen luomiseen on satunnaisen merkkijonon käyttäminen avaimena. Javalla hyvin satunnaisen merkkijonon saa luotua esimerkiksi <code><a href="http://docs.oracle.com/javase/6/docs/api/java/util/UUID.html" target="_blank">UUID</a></code>-luokan avulla. UUID-luokka arpoo merkkijonon joukosta, jossa on noin 2<sup>128</sup> vaihtoehtoa.</p>

        <p>Esimerkiksi yllä luotua <code>GroceryItem</code>-entiteettiä tulee muuttaa seuraavasti, jotta sille voidaan asettaa merkkijonoavain. Avaimen generointi voi tapahtua esimerkiksi luokan parametrittomassa konstruktorissa tai osana luokkaa käyttävää palvelua.</p>

<pre class="sh_java">
// pakkaus

import java.io.Serializable;
import java.util.Date;
import java.util.UUID;
import javax.persistence.Column;
import javax.persistence.Entity;
import javax.persistence.Id;
import javax.persistence.Table;
import javax.persistence.Temporal;
import javax.persistence.TemporalType;

@Entity
@Table(name = "GroceryItem")
public class GroceryItem implements Serializable {

    @Id
    @Column(name = "id")
    private String id;
    @Column(name = "name")
    private String name;
    @Column(name = "best_before")
    @Temporal(TemporalType.DATE)
    private Date bestBefore;

    public GroceryItem() {
        this.id = UUID.randomUUID().toString();
    }
    
    // getterit ja setterit
}
</pre>



        <p>Käytämme tällä kurssilla sekä numeerisia avaimia että merkkijonoavaimia.</p>



<div class="tehtavat">
  <h3>JPA Chat</h3>

<hr/>
  <p>Huom! Jos et ole jo tarkistanut onko TMC:stä päivityksiä ja päivittänyt TMC:tä, tee se nyt. Voit tarkistaa päivitykset valitsemalla NetBeansista Help -&gt; Check for Updates.</p>

  <p>Tehtävässä on ollut huomattavasti ongelmia pajassa. Tässä muutamia hyödyllisiä koodirivejä heti alkuun.</p>

<pre class="sh_java">
// ...
@Repository
public class JpaMessageRepository implements MessageRepository&lt;JpaMessage&gt; {
    @PersistenceContext
    private EntityManager entityManager;
    // ...
</pre>

<pre class="sh_java">
// ...
@Service
public class JpaMessageService implements MessageService&lt;JpaMessage&gt; {
    @Autowired
    private MessageRepository&lt;JpaMessage&gt; messageRepository;
    // ...
</pre>

  <p>Kannattaa tutustua myös seuraaviin linkkeihin: <a href="http://docs.oracle.com/javase/tutorial/java/generics/types.html" target="_blank">Generic Types (Oracle)</a>, <a href="http://insidecoding.wordpress.com/2011/09/07/the-generic-dao-pattern-in-java-with-spring-3-and-jpa-2-0/" target="_blank">Generic DAO Pattern in Java with Spring 3 and JPA2</a></p>

<hr/>


  <p>Tässä tehtävässä toteutetaan chat-ohjelma, joka tallettaa lähetetyt viestit tietokantaan JPA:n avulla. Ohjelma pitää kirjaa viestin lähetysajankohdasta sekä viestin lähettäjästä. Lisäksi ohjelmassa on mahdollista estää (eli <em>bannata</eM>) ennalta määritettyjen nimimerkkien käyttö. Lista estetyistä nimimerkeistä talletetaan tietokantaan erilliseen tauluun.</p>


  <h4>JpaMessage</h4>

  <p>Toteutetaan aluksi viestien tallettaminen tietokantaan.</p>

  <p>Luo pakkaukseen <code>wad.jpachat.data</code> luokka <code>JpaMessage</code>, joka toteuttaa samassa pakkauksessa olevan rajapinnan <code>Message</code>. Tee luokasta entiteetti ja määritä sille tietokantataulun nimi <code>Message</code>. Entiteetillä tulee olla rajapinnan määrittämät neljä attribuuttia: <code>id</code> (uniikki generoitava merkkijonoavain), <code>nickname</code> (viestin lähettäneen käyttäjän nimimerkki), <code>timestamp</code> (viestin lähetysajankohta) ja <code>message</code> (viestin tekstisisältö). Voit luoda <code>timestamp</code>-olion esimerkiksi luokan konstruktorissa (<code>new Date()</code>).</p>

  <p>Luo pakkaukseen <code>wad.jpachat.repository</code> luokka <code>JpaMessageRepository</code>, joka toteuttaa rajapinnan <code>MessageRepository</code>. Anna rajapinnalle tyyppiparametrina luokka <code>JpaMessage</code>. Lisää luokalle Springiä varten <code>Repository</code>-annotaatio ja toteuta DAO-metodit injektoidun <code>EntityManager</code>-instanssin avulla ylläolevien esimerkkien mukaisesti. Metodin <code>list</code> tulee palauttaa lista, joka sisältää kaikki viestit. Listaus onnistuu JPQL-kyselykielen avulla: tutustu vielä JPQL-osiossa olevaan kommenttiin entiteeteistä ja tietokantatauluista. Varmista että luokka <code>JpaMessageRepository</code> käyttää <code>JpaMessage</code>-olioita!</p>

  <p><strong>Huom!</strong> Tässä tehtävässä transaktiot määritellään palveluluokkiin. Selvitämme tätä myöhemmin kurssilla.</p>

  <p>Luo pakkaukseen <code>wad.jpachat.service</code> luokka <code>JpaMessageService</code>, joka toteuttaa rajapinnan <code>MessageService</code>. Merkitse luokka annotaatiolla <code>@Service</code> palveluksi. Kuten huomaat, <code>MessageService</code>-rajapinnan metodit ovat lähes identtiset <code>MessageRepository</code>-rajapinnan kanssa, mikä ei ole sattumaa: palvelutasolla yleensä kerätään matalamman tason toiminnallisuutta (kuten repository-luokkien operaatioita) suuremmiksi kokonaisuuksiksi. Tämä tehtävä on kuitenkin sen verran yksinkertainen, että metodit ainoastaan <em>delegoivat</em> toiminnallisuuden vastaavalle repository-luokalle, joka saadaan käyttöön injektoimalla se palveluluokkaan. Poikkeuksia ovat metodit <code>create</code>, jonka tulee määritellä uusi uniikki merkkijonoavain annetulle <code>JpaMessage</code>-entiteetille <code>UUID.randomUUID()</code>-metodin avulla, sekä <code>delete</code>, joka saa parametrina ID-merkkijonon sijaan <code>JpaMessage</code>-instanssin: tässä tapauksessa metodin täytyy välittää annetun instanssin ID repositoryn <code>delete</code>-metodille. Delegoinnin lisäksi palveluluokan tulee huolehtia tietokantatransaktioiden määrittelystä, joten merkitse jokaiselle metodille <code>Transactional</code>-annotaatio ja määrittele sille boolean-tyyppinen parametri <code>readOnly</code> sen mukaan muuttaako metodi tietokannassa olevaa tietoa vai ei. Esimerkiksi viestien listaus ainoastaan lukee tietoa tietokannasta, joten <code>readOnly</code>-parametrin arvoksi tulee <code>true</code>.</p>

  <p><strong>Huom!</strong> Ilman transaktioiden määrittelyä tiedon lisääminen tietokantaan ei onnistu!</p>

  <p>Täydennä lopuksi tehtäväpohjassa annetun luokan <code>ChatController</code> metodia <code>addMessage</code> siten, että se luo uuden <code>JpaMessage</code> viestin ja tallettaa sen tietokantaan käyttämällä <code>MessageService</code>-rajapintaa. Estä HTML-tagien käyttö nimimerkissä ja viestin sisällössä <code>StringEscapeUtils.escapeHtml4</code>-metodilla edellisten chat-tehtävien tapaan. Huom! Varmista että käytät <code>MessageService</code>-rajapintaa, etkä konkreettista toteutusta.</p>

  <p>Tässä vaiheessa kannattaa kokeilla chattia ja tarkistaa, että viestien lähetys ja talletus toimii oikein. Chatissa olevat viestit säilyvät tallessa niin pitkään kuin ohjelma on käynnissä, joten chatista voi välillä poistua ja kirjautua sinne uudestaa eri nimimerkillä.</p>

  <p>Viestien tulisi näyttää esimerkiksi tältä:</p>

<pre>
Mon Sep 17 09:53:04 EEST 2012 &lt;El Barto&gt; Anyone around?

Mon Sep 17 09:53:38 EEST 2012 &lt;El Barto&gt; ... it seems to be really quiet here

Mon Sep 17 09:56:37 EEST 2012 &lt;Anna&gt; I am Anna, the Online Assistant.

Mon Sep 17 09:56:50 EEST 2012 &lt;El Barto&gt; ????????
</pre>

  <h4>JpaBannedUser</h4>

  <p>Toteutetaan seuraavaksi nimimerkkien estäminen.</p>

  <p>Luo pakkaukseen <code>wad.jpachat.data</code> luokka <code>JpaBannedUser</code>, joka toteuttaa samassa pakkauksessa olevan rajapinnan <code>BannedUser</code>. Tee luokasta entiteetti ja määritä sille tietokantataulun nimi <code>BannedUser</code>. Entiteetillä tulee olla rajapinnan määrittämät attribuutit: <code>id</code> (uniikki ohjelman generoima merkkijonoavain) ja <code>nickname</code> (estetty nimimerkki).</p>

  <p>Luo pakkaukseen <code>wad.jpachat.repository</code> luokka <code>JpaBannedUserRepository</code>, joka toteuttaa rajapinnan <code>BannedUserRepository</code>. Anna rajapinnalle tyyppiparametrina luokka <code>JpaBannedUser</code>. Toteuta luokka edellisen kohdan ohjeiden mukaisesti, mutta käytä entiteettinä luokkaa <code>JpaBannedUser</code>. Metodin <code>isNicknameBanned</code> tehtävänä on selvittää tietokannasta löytyykö <code>JpaBannedUser</code>-entiteetin määrittämästä tietokantataulusta riviä, jossa on annettu nimimerkki. Jos nimimerkki löytyy, on se estetty ja metodi palauttaa <code>true</code>. Metodin toteutus onnistuu JPQL-kyselykielen avulla määrittelemällä where-ehto. Where-ehdon tulee testata onko <code>nickname</code>-attribuutti sama kuin annettu parametri.  Varmista vielä että luokka <code>JpaBannedUserRepository</code> käyttää <code>JpaBannedUser</code>-olioita!</p>

  <p>Luo pakkaukseen <code>wad.jpachat.service</code> luokka <code>JpaBannedUserService</code>, joka toteuttaa rajapinnan <code>BannedUserService</code>. Toteuta luokka edellisen kohdan ohjeiden mukaisesti, mutta käytä entiteettinä luokkaa <code>JpaBannedUser</code>.</p>

  <p>Täydennä lopuksi luokan <code>ChatController</code> metodeja <code>login</code> sekä <code>addMessage</code> siten, että metodit tarkistavat <code>BannedUserService</code>-palvelun avulla onko pyynnössä lähetetty nimimerkki estetty. Jos nimimerkki on estetty, tulee kummankin metodin uudelleenohjata pyyntö osoitteeseen <code>banned</code>. Lisää lisäksi metodissa <code>list</code> <code>MessageService</code>-rajapinnan toteuttaman olion palauttamat viestit <code>Model</code>-olion attribuuttiin <code>messages</code>. Varmista myös että käytät <code>BannedUserService</code>-rajapintaa, etkä konkreettista toteutusta.</p>

  <p>Jotta nimimerkin käytön estoa voisi kokeilla, täytyy estettyjä nimimerkkejä erikseen lisätä tietokantaan. Springin hallinnoimissa luokissa (joilla on jokin Springin annotaatiosta) voi määritellä metodille annotaation <code>javax.annotation.PostConstruct</code>, jolloin kyseinen metodi suoritetaan ohjelmaa käynnistettäessä. Tehtäväpohjan <code>ChatController</code>-luokassa on annettu tyhjä metodi nimeltä <code>init</code>, jolle tulee määritellä tämä annotaatio. Tällöin estetyt nimimerkit voidaan lisätä <code>init</code>-metodissa, jolloin lisäys tapahtuu ohjelman käynnistyessä. Estä nimimerkit <code>El Bimbo</code> ja <code>Casanova</code> käyttämällä <code>BannedUserService</code>-palvelua.</p>

</div>



        <p>Huomaamme tietokantalogiikassa vieläkin melko paljon toisteisuutta. Esimerkiksi CRUD-operaatiot ovat lähes aina samanlaiset. Tutustutaan seuraavaksi Spring Data JPA-projektiin, joka pyrkii vähentämään tietokantalogiikan toteutukseen tarvittavan koodin määrää.</p>




        <h3>Spring Data JPA</h3>

        <p>Olemme huomanneet että iso osa tietokantatoiminnoista on valmiiden operaatioiden toistamista. Käytännössä lähes jokainen JPA:n kanssa paininut paljon tietokantakyselyitä luova sovelluskehittäjä on jossain vaiheessa luonut itselleen hieman seuraavankaltaisen pohjan, jonka perimällä saa käyttöön oleellisimmat toiminnot.</p>

<pre class="sh_java">
// yleiskäyttönen JpaDao

public abstract class JpaDAO&lt;T&gt; implements DAO&lt;T&gt; {

    @PersistenceContext
    EntityManager entityManager;

    private Class clazz;
    
    public JpaDAO(Class clazz) {
        this.clazz = clazz;
    }   
    
    @Override
    public void create(T instance) {
        entityManager.merge(instance);
    }

    @Override
    public T read(Long id) {
        return (T)entityManager.find(clazz, id);
    }

    @Override
    public T update(T instance) {
        return entityManager.merge(instance);
    }


    @Override
    public void delete(Long id) {
        T instance = read(id);

        if(instance != null) {
            entityManager.remove(instance);
        }
    }
    
    @Override
    public List&lt;T&gt; list() {
        // CriteriaBuilder on ohjelmallinen API kyselyjen tekemiseen
        CriteriaBuilder criteriaBuilder = entityManager.getCriteriaBuilder();
        CriteriaQuery query = criteriaBuilder.createQuery(clazz);
        return entityManager.createQuery(query).getResultList();
    }
}
</pre>

        <p>Konkreettinen tietokantatoiminnallisuus yllä olevaa luokkaa käyttäen vaatisi luokan perimisen. Esimerkiksi aiemmin toteuttamamme <code>JpaAircraftDAO</code> pienenee seuraavaan muotoon.</p>


<pre class="sh_java">
// pakkaus

import javax.persistence.EntityManager;
import javax.persistence.PersistenceContext;
import org.springframework.stereotype.Repository;
import org.springframework.transaction.annotation.Transactional;

@Repository
@Transactional
public class JpaAircraftDAO extends JpaDAO&lt;Aircraft&gt; implements AircraftDAO {
    public JpaAircraftDAO() {
        super(Aircraft.class);
    }
}
</pre>


        <p>Useat ohjelmistokehittäjät tarjoavat myös tekeleitään muiden käyttöön (esim. <a href="http://code.google.com/p/daofusion/" target="_blank">daofusion</a> ja <a href="http://code.google.com/p/generic-dao/" target="_blank">generic-dao</a>). Näissäkin joudut aina perimään jonkun luokan.</p>

        <p>Spring Data JPA (<a href="http://www.springsource.org/spring-data/jpa" target="_blank">http://www.springsource.org/spring-data/jpa</a>) on Spring-sovelluskehykseen liittyvä projekti, joka helpottaa tyypillisten JPA-tietokantaluokkien toteuttamista. Spring Data JPAn etuna muihin "geneeriset daot"-toteutuksiin on integroituminen Spring-sovelluskehykseen, ja sitä kautta pääsy inversion of control ja dependency injection -mekanismeihin. Spring Data JPAn saa käyttöön lisäämällä seuraavan riippuvuuden projektimme <code>pom.xml</code>-tiedostoon. Riippuvuuskonfiguraatioon on lisätty <code>&lt;exclusions&gt;</code>-elementti, jolla voidaan poistaa riippuvuuden käyttämiä välillisiä riippuvuuksia. Spring Data JPAn versio 1.1.0.RELEASE käyttää Spring-riippuvuuksia, joiden versio ei ole haluamamme <code>3.1.2.RELEASE</code>. </p>

<pre class="sh_xml">
        &lt;dependency&gt;
            &lt;groupId&gt;org.springframework.data&lt;/groupId&gt;
            &lt;artifactId&gt;spring-data-jpa&lt;/artifactId&gt;
            &lt;version&gt;1.1.0.RELEASE&lt;/version&gt;
            &lt;exclusions&gt;
                &lt;exclusion&gt;
                    &lt;groupId&gt;org.springframework&lt;/groupId&gt;
                    &lt;artifactId&gt;spring-jdbc&lt;/artifactId&gt;
                &lt;/exclusion&gt;
                &lt;exclusion&gt;
                    &lt;groupId&gt;org.springframework&lt;/groupId&gt;
                    &lt;artifactId&gt;spring-orm&lt;/artifactId&gt;
                &lt;/exclusion&gt;
                &lt;exclusion&gt;
                    &lt;groupId&gt;org.springframework&lt;/groupId&gt;
                    &lt;artifactId&gt;spring-tx&lt;/artifactId&gt;
                &lt;/exclusion&gt;           
            &lt;/exclusions&gt;
        &lt;/dependency&gt; 
</pre>

        <p>Kun tarvittu kirjasto on käytössä, meidän tulee konfiguroida lisäksi tietokantaoperaatioita tekevien luokkiemme sijainti projektille. Lisätään tiedostoon <code>front-controller-servlet.xml</code> seuraava rivi <code>InternalResourceViewResolver</code>-olion konfiguroinnin jälkeen.</p>

<pre class="sh_xml">
    &lt;jpa:repositories base-package="pakkaus.jossa.repository.luokat.ovat" /&gt;
</pre>

        <p>Jotta saamme etuliitteellä <code>jpa:</code> alkavat elementit käyttöömme, tulee <code>front-controller-servlet.xml</code>-tiedostoon määritellä myös <code>jpa</code>-elementin sijainti:</p>

<pre class="sh_xml">
       ...
       xmlns:jpa="http://www.springframework.org/schema/data/jpa"
       ...
       xsi:schemaLocation="http://www.springframework.org/schema/beans
                            http://www.springframework.org/schema/beans/spring-beans-3.1.xsd
                            ...
                            http://www.springframework.org/schema/data/jpa
                            http://www.springframework.org/schema/data/jpa/spring-jpa.xsd">
      ...
</pre> 

        <p>Luodaan <em>taas</em> lentokoneiden tallennuslogiikkaa, tällä kertaa Spring Data JPA:n avulla. Spring Data JPA määrittelee oman <code><a href="http://static.springsource.org/spring-data/data-jpa/docs/1.1.0.RELEASE/api/org/springframework/data/repository/CrudRepository.html" target="_blank">CrudRepository</a></code>-rajapinnan, jolle annetaan tyyppiparametreina tallennettava olio sekä avainkentän tyyppi. Määritellään oma rajapinta <code>AircraftRepository</code>, joka perii Spring Data JPAn <code>CrudRepository</code>-rajapinnan.</p>

<pre class="sh_java">
// pakkaus

import org.springframework.data.repository.CrudRepository;

public interface AircraftRepository extends CrudRepository&lt;Aircraft, Long&gt; {
}
</pre>

        <p>Tämän jälkeen tehdään <code>AircraftRepository</code>-luokkaa käyttävät muut komponentit. <strong>Hei! Eihän tuolla toteutettu tuota <code>AircraftRepository</code>-rajapintaa!</strong> Ei niin. Avainsanoina tälle magialle perintä, inversion of control ja dependency injection. Spring Data JPA:n käyttämissä luokissa on määritelty luokkatason transaktiot, joten tallennusoperaatiot toimivat myös ilman <code>@Transactional</code>-annotaatiota.</p>


<div class="tehtavat">
<h3>Easy Storing of Objects</h3>

<p>Luodaan sovellus, jossa voi lisätä esineitä tietokantaan. Tietokannassa olevien esineiden lukumäärää pystyy myös kasvattamaan. Käyttöliittymätiedostot sekä suurin osa projektin konfiguraatiosta tulee valmiina projektin mukana.</p>

<h4>Tallennettava: Item</h4>

<p>Luo pakkaukseen <code>wad.storage.domain</code> luokka <code>Item</code>, joka toteuttaa rajapinnan <code>Serializable</code>. Luokalla <code>Item</code> on <code>@Entity</code>-annotaatio sekä attribuutit <code>id</code>, <code>name</code> ja <code>count</code>, joiden tyypit ovat <code>Long</code>, <code>String</code> ja <code>Integer</code> vastaavasti.</p>

<p>Lisää attribuutille <code>id</code> annotaatiot <code>@Id</code>, <code>@GeneratedValue(strategy = GenerationType.TABLE)</code> ja <code>@Column</code>. Lisää <code>@Column</code> annotaatio myös attribuuteille <code>name</code> ja <code>count</code>. Lisää jokaiselle attribuutille myös get- ja set-metodit.</p>

<h4>Tallentaja: ItemRepository</h4>

<p>Luo seuraavaksi pakkaukseen <code>wad.storage.repository</code> <em>rajapinta</em>luokka <code>ItemRepository</code>. Rajapintaluokka <code>ItemRepository</code> perii Spring Data JPA:n rajapintaluokan <code>CrudRepository</code> siten, että tallennettava olio on tyyppiä <code>Item</code>, ja avaimena on <code>Long</code>.</p>

<p>Lisää myös kansiossa <code>/WEB-INF/</code> olevaan tiedostoon <code>database.xml</code> Spring Data JPA-tyyppisten repository-luokkien etsimiseen tarkoitettu konfiguraatio:</p>

<pre class="sh_xml">
&lt;jpa:repositories base-package="wad.storage.repository" /&gt;
</pre>


<h4>Kontrolleri: StorageController</h4>

<p>Luo pakkaukseen <code>wad.storage.controller</code> luokka <code>StorageController</code>, joka toteuttaa rajapinnan <code>StorageControllerInterface</code>. Luokka <code>StorageController</code> kapseloi rajapintaluokan <code>ItemRepository</code>, jonka tulee olla merkattu annotaatiolla <code>@Autowired</code>. Toteuta luokalta <code>StorageController</code> vaaditut metodit seuraavasti:</p>

<p>
  <ul>

    <li>Metodi <code>String view(Model model)</code> kuuntelee GET-tyyppisiä pyyntöjä osoitteeseen <code>view</code>. Pyynnössä ei ole parametreja. Metodi <code>view</code> saa parametrinaan <code>Model</code>-olion, jonka attribuuttiin <code>items</code> tulee asettaa kaikki rajapintaluokasta <code>ItemRepository</code> metodilla <code>findAll</code> saatavat esineet. Metodi palauttaa <code>view</code>-merkkijonon, jolloin käyttäjälle näytetään <code>/WEB-INF/jsp/view.jsp</code>-tiedosto.<br/><br/></li>

    <li>Metodi <code>String add(String name)</code> kuuntelee POST-tyyppisiä pyyntöjä osoitteeseen <code>add</code>. Pyynnössä tulee olla parametri nimeltä <code>name</code>, jonka pohjalta luodaan uusi <code>Item</code>-olio, joka tallennetaan rajapintaluokan <code>ItemRepository</code> avulla. Uuden <code>Item</code>-olion <code>count</code>-muuttujan arvon tulee olla aina aluksi 1. Pyyntö ohjataan lopulta <code>view</code>-osoitteeseen.<br/><br/></li>

    <li>Metodi <code>String increaseCount(String name)</code> kuuntelee POST-tyyppisiä pyyntöjä osoitteeseen <code>increaseCount</code>. Pyynnössä tulee olla parametri nimeltä <code>itemId</code>. Pyynnön parametria <code>itemId</code> käytetään <code>Item</code>-olion etsimiseen <code>ItemRepository</code>-rajapintaluokan avulla. Kun olio on löytynyt, kasvata sen count-arvoa yhdellä ja ohjaa pyyntö <code>view</code>-osoitteeseen. Muistathan varmistaa että olion uusi arvo tallennetaan myös tietokantaan (esim. ItemRepository-oliota käyttämällä..).</li>
  </ul>
</p>

<p>Kun sovelluksesi toimii, lähetä se TMC:lle. Vertaa myös tarvitsemasi tietokantalogiikkaan liittyvän koodin määrää edellisiin tehtäviin.</p>

</div>

        <h4>Omien kyselyiden toteuttaminen</h4>

        <p>Spring Data JPA ei tarjoa kaikkia kyselyitä valmiiksi. Jos tarvitset tietynlaisen kyselyn, sinun tulee yleensäottaen myös määritellä se. Laajennetaan aiemmin määriteltyä rajapintaa <code>AircraftRepository</code> siten, että sillä on metodi <code>List&lt;Aircraft&gt; findByCapacity(Integer capacity)</code> -- eli hae koneet, joilla on tietty kapasiteetti.</p>


<pre class="sh_java">
// pakkaus

import org.springframework.data.repository.CrudRepository;

public interface AircraftRepository extends CrudRepository&lt;Aircraft, Long&gt; {
    List&lt;Aircraft&gt; findByCapacity(Integer capacity);
}
</pre>

        <p>Ylläoleva esimerkki on esimerkki kyselystä, johon Spring Data ei tarvitse erillistä toteutusta. Se arvaa että kysely olisi muotoa <code>SELECT a FROM Aircraft a WHERE a.capacity = :capacity</code>, ja luo sen valmiiksi. Lisää Spring Data JPA:n kyselyjen arvaamisesta löytyy sen <a href="http://static.springsource.org/spring-data/data-jpa/docs/1.1.0.RELEASE/reference/html/#jpa.query-methods" target="_blank">dokumentaatiosta</a>.</p>

        <p>Tehdään toinen esimerkki, jossa joudumme oikeasti luomaan oman kyselyn. Lisätään rajapinnalle <code>AircraftRepository</code> metodi <code>findAirForceOne</code>, joka suorittaa kyselyn <code>"SELECT a FROM Aircraft a WHERE a.identifier = 'Air Force One'"</code>.</p>


<pre class="sh_java">
// pakkaus

import org.springframework.data.jpa.repository.Query;
import org.springframework.data.repository.CrudRepository;

public interface AircraftRepository extends CrudRepository&lt;Aircraft, Long&gt; {
    List&lt;Aircraft&gt; findByCapacity(Integer capacity);
    @Query("SELECT a FROM Aircraft a WHERE a.identifier = 'Air Force One'")
    Aircraft findAirForceOne();
}
</pre>

        <p>Käytössämme on nyt myös metodi <code>findAirForceOne</code>, joka suorittaa <code>@Query</code>-annotaatiossa määritellyn kyselyn. Tarkempi kuvaus kyselyiden määrittelystä osana rajapintaa löytyy Spring Data JPAn <a href="http://static.springsource.org/spring-data/data-jpa/docs/1.1.0.RELEASE/reference/html/#jpa.query-methods.at-query" target="_blank">dokumentaatiosta</a>.</p>


        <h3>Tietokantataulujen viitteet</h3>

        <p>Osoitteessa <a href="http://nikojava.wordpress.com/2011/08/04/essential-jpa-relationships/" target="_blank">http://nikojava.wordpress.com/2011/08/04/essential-jpa-relationships/</a> on erittäin hyvä ja kattava kuvaus viitteiden lisäämisestä entiteetteihin. Tutustu osoitteessa olevaan blogikirjoitukseen ennen seuraavan tehtävän tekemistä.</p> 


<div class="extra">
  <p><strong>Polut kuntoon!</strong></p>

  <p>REST-tyyppisessä ajatusmaailmassa osoitteissa käytettävien polkujen muodolla on suuri merkitys. Seuraavissa tehtävissä käytetään REST-tyyliä lähenteleviä polkuja. Springin avulla osoitepolkuihin lisättyjä parametreja voi käsitellä <code>@PathVariable</code>-annotaation avulla. Esimerkiksi alla on määritelty metodi <code>assignAirport</code>, joka kuuntelee polkuun <code>{aircraftId}/airport</code> tulevia pyyntöjä. Polun osa {aircraftId} muunnetaan luvuksi ja asetetaan <code>@PathVariable</code>-annotaatiolla merkattuun parametriin.</p>

  <p>Metodi odottaa myös että pyynnön mukana tulee myös numeerinen parametri <code>airportId</code>.</p>

<pre class="sh_java">
    // ...
    @RequestMapping(value = "{aircraftId}/airport", method = RequestMethod.POST)
    @Override
    public String assignAirport(
                    @PathVariable(value="aircraftId") Long aircraftId, 
                    @RequestParam Long airportId) {
    // ...
</pre>

  <p>Kontrollereissa voidaan määritellä <code>@RequestMapping</code>-annotaation avulla myös korkean tason osoite. Esimerkiksi seuraavassa luokassa oleva metodi <code>assignAirport</code> kuuntelee pyyntöjä osoitteeseen <code>aircraft/{aircraftId}/airport</code>.</p>

<pre class="sh_java">
//importit jne

@Controller
@RequestMapping("aircraft")
public class AircraftController {

    // ...
    @RequestMapping(value = "{aircraftId}/airport", method = RequestMethod.POST)
    @Override
    public String assignAirport(
                    @PathVariable(value="aircraftId") Long aircraftId, 
                    @RequestParam Long airportId) {
    // ...
</pre>


</div>


<div class="tehtavat">
<h3>Going for a Flight</h3>

<p>Jatkokehitetään tässä tehtävässä sovellusta lentokoneiden ja lentokenttien hallintaan. Projektissa on jo valmiina ohjelmisto, jossa voidaan lisätä ja poistaa lentokoneita. Tavoitteena on lisätä toiminnallisuus lentokoneiden kotikenttien asettamiseksi.</p>

<h4>Tallennettavat: <code>Aircraft</code> ja <code>Airport</code>.</h4>

<p>Lisää luokkaan <code>Aircraft</code> attribuutti <code>airport</code>, joka on tyyppiä <code>Airport</code>. Koska usealla lentokoneella voi olla sama kotikenttä, käytä attribuutille <code>airport</code> annotaatiota <code>@ManyToOne</code>. Lisää attribuutille myös <code>@JoinColumn</code>-annotaatio, jonka avulla kerrotaan että tämä attribuutti viittaa toiseen tauluun. Lisää luokalle myös oleelliset get- ja set-metodit.</p>

<p>Lisää seuraavaksi <code>Airport</code> attribuutti <code>aircrafts</code>, joka on tyyppiä <code>List&lt;Aircraft&gt;</code>. Koska yhdellä lentokentällä voi olla useita koneita, lisää attribuutille annotaatio <code>@OneToMany</code>. Koska luokan <code>Aircraft</code> attribuutti <code>airport</code> viittaa tähän luokkaan, aseta annotaatioon <code>@OneToMany</code> parametri <code>mappedBy="airport"</code>. Nyt luokka <code>Airport</code> tietää että attribuuttiin <code>aircrafts</code> tulee ladata kaikki <code>Aircraft</code>-oliot, jotka viittaavat juuri tähän kenttään.</p>

<p>Lisää myös luokalle <code>Airport</code> oleelliset get- ja set-metodit.</p>

<h4>Lentokentän asetus lentokoneelle</h4>

<p>Lisää sovellukselle toiminnallisuus lentokentän lisäämiseen lentokoneelle. Käyttöliittymä sisältää jo tarvittavan toiminnallisuuden, joten käytännössä sinun tulee toteuttaa luokan <code>AircraftController</code> metodi <code>String assignAirport</code>. Kun käyttäjä lisää lentokoneelle lentokenttää, käyttöliittymä lähettää POST-tyyppisen kyselyn osoitteeseen <code>/app/aircraft/{aircraftId}/airport</code>, missä <code>aircraftId</code> on lentokoneen tietokantatunnus. Pyynnön mukana tulee lisäksi parametri <code>airportId</code>, joka sisältää lentokentän tietokantatunnuksen.</p>

<p>Toteuta metodi siten, että haet aluksi tietokantatunnuksia käyttäen lentokoneen ja lentokentän, tämän jälkeen asetat lentokoneelle lentokentän ja lentokentälle lentokoneen, ja tallennat haetut oliot.</p>

<p>Ohjaa lopuksi pyyntö osoitteeseen <code>/app/aircraft/</code></p>

<p>Kun olet valmis, lähetä sovellus TMC:lle tarkistettavaksi.</p>
</div>




<h2>Kerrosarkkitehtuuri</h2>


        <p>Kerrosarkkitehtuuri jakaa sovelluksen kerroksiin; tiedon tallentamiseen ja hakemiseen liittyvään logiikkaan, sovelluksen palveluihin liittyvään logiikkaan, käyttöliittymästä tehtyjä pyyntöjä ohjaavaan kerrokseen, ja käyttöliittymäkerrokseen.</p>

        <p>N-tier -arkkitehtuurilla tarkoitetaan yleisesti sovelluksen jakamista itsenäisiin osiin, jotka toimivat vuorovaikutuksessa muiden osien kanssa. Client-Server -arkkitehtuuri on esimerkki 2-tier arkkitehtuurista, 3-tier -arkkitehtuuri taas esimerkiksi jakaa käyttöliittymän, sovelluslogiikan, ja tietokantalogiikan erillisiksi osioikseen. Tällä kurssilla kerrosarkkitehtuurista puhuessamme tarkoitamme yleisesti ottaen seuraavaa jakoa:</p>

        <p>
          <ul>
            <li>Käyttöliittymälogiikka (JSP)</li>
            <li>Pyyntöjen ohjaus ja syötteiden tarkistus (Controller)</li>
            <li>Palvelulogiikka (Service)</li>
            <li>Tallennuslogiikka (Repository)</li>
          </ul>
        </p>

        <p>Tiedon hakemiseen ja tallentamiseen liittyvässä logiikassa käytetään lähes aina valmiita komponentteja, esim. JPA tai Spring Data JPA. Alimman kerroksen toiminnallisuus -- relaatiotietokannat, key/value -tietokannat, dokumenttitietokannat, jne.. -- ovat web-sovelluskehittäjän näkökulmasta "done", eli omaa ei kannata lähteä toteuttamaan.</p>

        <p>Sovelluksen oleellisin osa on palveluissa, eli keskitasossa. <em>Sovelluslogiikka sisältää toiminnallisuuden, joka tekee sovelluksestamme arvokkaan.</em> Sovelluslogiikka käyttää alempana olevan tietokantakerroksen tarjoamia palveluita. Sovelluslogiikkakerros sisältää yleensä myös transaktioiden hallinnan.</p>

        <p>Sovelluslogiikkakerroksen päällä on käyttöliittymäkutsuja ohjaava kerros, "kontrollikerros". Käyttöliittymäkutsuja ohjaavan kerroksen tehtävänä on toimia rajapintana sovelluskerroksen ja käyttöliittymän välillä. Se vastaanottaa käyttäjän tekemiä pyyntöjä ja ohjaa niitä eteenpäin tarpeellisille palveluille. Kontrollikerroksen tulee olla mahdollisimman ohut; siinä käytetään sovelluskerroksen tarjoamaa toiminnallisuutta. Kutsun suorittamisen jälkeen kontrollikerros palauttaa dataa <em>jossain muodossa</em>. Javascript-kutsulla voi pyytää XML- tai JSON-muodossa olevaa dataa, jonka näyttäminen tapahtuu selainpuolella. Toisaalta, palautettu data voidaan ohjata erilliselle käyttöliittymän renderöintipalvelulle, joka luo näytettävän HTML-sivun.</p>

        <p>Kontrollikerroksen päällä on käyttöliittymä. Käyttöliittymiä voi olla useita erilaisia. Kaikille yhteistä on se, että ne tekevät pyyntöjä web-sovelluksen tarjoamiin osoitteisiin.</p>


            
        <h3>Sovelluslogiikkakerros</h3>


        <p>Sovelluslogiikka jaetaan oliosuunnittelun periaatteiden mukaisesti toiminnallisuutta tarjoaviin palveluihin, joita kontrollikerros käyttää. Spring tarjoaa hyvät välineet sovelluslogiikan ja kontrollikerroksen erottamiseen. Tutustumme seuraavaksi kontrolliluokan ja sovelluslogiikan yhteistoimintaan. Pieni kertaus ennen sitä.</p>


        <h4>Inversion of Control ja Dependency Injection</h4>

        <p>Jokaisella oliolla on oma selkeä vastuualueensa, ja niiden sekoittamista tulee välttää. Inversion of Control ja Dependency Injection ovat suunnitelumalleja, joilla pyritään vähentämään olioiden turhia riippuvuuksia.</p>

        <p><strong>Inversion of Control</strong></p>
        
        <p>Perinteisissä ohjelmistoissa luokkien ilmentymien luominen on ohjelmoijan vastuulla. Huomasimme jo aiemmin että Spring luo käyttöömme luokkia joita tarvitsemme: Kontrollin käännöllä tarkoitetaan ohjelman toiminnan hallinnan vastuun siirtämistä sovelluskehykselle ja ohjelmaa suorittavalle palvelimelle.</p>
        
        <p><strong>Dependency Injection</strong></p>
        
        <p>Dependency Injectionin tehtävänä on syöttää riippuvuudet silloin kun niitä tarvitaan.</p>
        
        <p>Käytännössä siis: palvelin ja sovelluskehys ottaa vastuuta luokkien hallinnoinnista. Sovelluskehys syöttää riippuvuudet niitä tarvittaessa. Molemmat toiminnallisuudet ovat oleellisia kerrosarkkitehtuurin kerrosten toisistaan erottamisessa.</p>

        <h4>Palveluesimerkki: HitCounter</h4>
  
        <p>Luodaan palvelu jonka tehtävänä on yksittäisten vierailujen määrän laskeminen. Määritellään rajapinta HitCounter-palvelulle. Rajapinta tarjoaa kaksi metodia: <code>getCount()</code>, joka palauttaa kävijöiden määrän, ja <code>incrementCount()</code>, joka kasvattaa kävijöiden määrää yhdellä.</p>

<pre class="sh_java">
// pakkaus 

public interface HitCounter {
    int getCount();
    void incrementCount();
}
</pre>

        <p>Luodaan rajapinnalle toteutus <em>InMemoryHitCounter</em>. Toteutus merkitään annotaatiolla <em>@Service</em>. Annotaatio <code>@Service</code> on kuin <code>@Component</code>, mutta se kuvaa paremmin komponentit tarkoitusta.</p>

<pre class="sh_java">
// pakkaus ja muut importit

import org.springframework.stereotype.Service;


@Service
public class InMemoryHitCounter implements HitCounter {
    private int count = 0;

    @Override
    public int getCount() {
        return count;
    }

    @Override
    public void incrementCount() {
        count++;
    }
}
</pre>

        <p>Luodaan seuraavaksi näkymä, jonka tehtävänä on kertoa käyntien määrä. Esimerkissämme näkymä sijaitsee tiedostossa <code>hits.jsp</code>.</p>

<pre class="sh_xml">
&lt;%@page contentType="text/html" pageEncoding="UTF-8"%&gt;
&lt;!DOCTYPE html&gt;
&lt;html&gt;
    &lt;head&gt;
        &lt;meta http-equiv="Content-Type" content="text/html; charset=UTF-8"&gt;
        &lt;title&gt;uno dos tres&lt;/title&gt;
    &lt;/head&gt;
    &lt;body&gt;
        &lt;h1&gt;Hits: ${hits}&lt;/h1&gt;
    &lt;/body&gt;
&lt;/html&gt;
</pre> 

        <p>Näkymässämme on EL-tägi <em>hits</em>, jonka tehtävänä on näyttää osumien määrä. Luodaan lopuksi kontrolleri <em>HitController</em>, joka vastaanottaa pyynnöt osoitteeseen <em>hitme</em>, kutsuu HitCounter-palvelun tarjoamia metodeja, ja palauttaa lopuksi luodun mallin näkymää varten.</p>

<pre class="sh_java">
// pakkaus

import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.stereotype.Controller;
import org.springframework.ui.Model;
import org.springframework.web.bind.annotation.RequestMapping;

@Controller
public class HitController {

    @Autowired
    HitCounter hitCounter;

    @RequestMapping("hitme")
    public String incrementAndReturn(Model model) {
        hitCounter.incrementCount();
        model.addAttribute("hits", hitCounter.getCount());
        
        return "check";
    }
}
</pre>


        <h4>Tietokantatransaktioiden hallinta palvelutasolla</h4>


        <p>Sovelluksia suunniteltaessa transaktiot toteutetaan yleensä palvelutasolla. Tällöin tietokantatason operaatioita kerätään saman transaktion sisään, ja kaikkien suoritus riippuu transaktion onnistumisesta. Oletetaan että käytössämme on aiemmin luotu <code>AircraftRepository</code>, ja <code>Aircraft</code>-olioiden avain on tyyppiä <code>Long</code>. Luodaan rajapinta <code>AircraftService</code>, joka tarjoaa metodit <code>Iterable&lt;Aircraft&gt; list()</code> ja <code>void changeIdentifierString(Long aircraftId, String identifierString)</code>.</p>

<pre class="sh_java">
// pakkaus

public interface AircraftService {
    Iterable&lt;Aircraft&gt; list();
    void changeIdentifierString(Long aircraftId, String identifierString);
}
</pre>

        <p>Luodaan seuraavaksi rajapinnalle toteutus. Tutki erityisesti metodin <code>changeIdentifierString</code> toteutusta.</p>

<pre class="sh_java">
// importit ym

@Service
public class RepositoryAircraftService implements AircraftService {

    @Autowired
    private AircraftRepository aircraftRepository;

    @Override
    @Transactional(readOnly = true)
    public Iterable&lt;Aircraft&gt; list() {
        return aircraftRepository.findAll();
    }

    @Override
    @Transactional(readOnly = false)
    public void changeIdentifierString(Long aircraftId, String identifierString) {
        Aircraft craft = aircraftRepository.findOne(aircraftId);
        if ( craft == null ) {
            throw new NoSuchElementException("No aircraft with id " + aircraftId);
        }

        craft.setIdentifier(identifierString);
    }

//...
</pre>


        <p>Huomionarvoista on että metodissa <code>changeIdentifierString</code> oliota <code>Aircraft</code> ei tallenneta erikseen. JPAn <code>EntityManager</code>-luokkaa käytettäessä entiteetit ovat <code>EntityManager</code>-olion hallinnoitavana koko transaktion ajan. Metodissa <code>changeIdentifierString</code> aloitetaan transaktio, luetaan <code>Aircraft</code>-olio tietokannasta, ja asetetaan oliolle uusi <code>identifier</code>-muuttujan arvo metodilla <code>setIdentifier</code>. Transaktion lopussa <code>EntityManager</code> tutkii onko hallinnoitaviin olioihin tehty muutoksia. Jos muutoksia on tehty, muutokset tallennetaan tietokantaan automaattisesti.</p>


        <p>Entiteetti on hallinnoitava jos <code>EntityManager</code> on hakenut sen tietokannasta kyseisen transaktion sisällä. Myös Spring Data JPA käyttää <code>EntityManager</code>-olioita toteutuksessaan.</p>


<div class="tehtavat">


<h3>Movie Database</h3>

<p>Tämä tehtävä on avoin tehtävä jossa saat itse suunnitella huomattavan osan ohjelman sisäisestä rakenteesta. Ainut määritelty asia ohjelmassa on käyttöliittymä, joka tulee tehtäväpohjan mukana. Käyttöliittymään on määritelty EL-kielellä attribuutit, joita käyttöliittymän tulee näyttää. Tehtäväpohjassa on myös valmis konfiguraatio spring-projektille.</p>

<p>Tehtävästä on mahdollista saada yhteensä 4 pistettä.</p>


<p>Luo tehtävässä sovellus, joka toimii kuten osoitteessa <a href="http://t-avihavai.users.cs.helsinki.fi/moviedatabase/" target="_blank">http://t-avihavai.users.cs.helsinki.fi/moviedatabase/</a> oleva sovellus. Sovelluksessasi ei tarvitse olla XSS-tarkastusta, ja yksittäisen näyttelijän elokuvia tarkasteltaessa uuden elokuvan lisäämisessä ei tarvitse poistaa näyttelijällä jo olevia elokuvia.</p>

<p>Vinkki: Aloita yksittäisestä asiasta, esimerkiksi näyttelijän lisäämisestä ja poistamisesta. Suunnittele ensin sopiva tietokantaolio, sekä sille sopivat repository-oliot. Jatka tämän jälkeen palvelukerroksella, ja siirry siitä kontrolleriin. Kannattaa hyödyntää käyttöliittymätiedostoissa käytettyä EL-kieltä tietokantaolioiden attribuuttien määrittelyssä.</p>

<p><strong>Pisteytys:</strong></p>

<ol style="list-style-type: none;">
  <li>+ 1p: Näyttelijän lisääminen ja poistaminen onnistuu. Käyttöliittymän olettamat osoitteet ja niiden parametrit:<br/>
    <ul>
      <li><code>GET /app/actor/</code> - näyttelijöiden listaus, ei parametreja pyynnössä.</li>
      
      <li><code>POST /app/actor/</code> - parametri <code>name</code>, joka sisältää lisättävän näyttelijän nimen. Lisäyksen tulee lopulta ohjata pyyntö osoitteeseen <code>/app/actor/</code>.</li>
      
      <li><code>POST /app/actor/{actorId}/delete</code> - polun parametri <code>actorId</code>, joka sisältää poistettavan näyttelijän tietokantatunnuksen. Poiston tulee lopulta ohjata pyyntö osoitteeseen <code>/app/actor/</code>.</li>
    </ul>
  </li>
  
  <br/><br/>
  
  <li>+ 1p: Elokuvan lisääminen ja poistaminen onnistuu. Käyttöliittymän olettamat osoitteet ja niiden parametrit:<br/>
    <ul>
      <li><code>GET /app/movie/</code> - elokuvien listaus, ei parametreja pyynnössä.</li>
      
      <li><code>POST /app/movie/</code> - elokuvan lisäys, parametrit <code>name</code>, joka sisältää lisättävän elokuvan nimen, ja <code>lengthInMinutes</code>, joka sisältää elokuvan pituuden minuuteissa. Lisäyksen tulee lopulta ohjata pyyntö osoitteeseen <code>/app/movie/</code>.</li>

      <li><code>POST /app/movie/{movieId}/delete</code> - polun parametri <code>movieId</code>, joka sisältää poistettavan elokuvan tietokantatunnuksen. Poiston tulee lopulta ohjata pyyntö osoitteeseen <code>/app/movie/</code>.</li>
    </ul>
  </li>
  
  <br/><br/>
  
  <li>+ 2p: Näyttelijän voi lisätä elokuvaan (kun näyttelijä tai elokuva poistetaan, poistetaan myös viitteet näyttelijästä elokuvaan ja elokuvasta näyttelijään). Käyttöliittymän olettamat osoitteet ja niiden parametrit:<br/>
    <ul>
      
      <li><code>GET /app/actor/{actorId}</code> - polun parametri <code>actorId</code>, joka sisältää näytettävän näyttelijän tietokantatunnuksen. Näyttää sivun <code>/WEB-INF/jsp/actor.jsp</code> (tutustu tiedostoon, ja varmista että pyynnössä on sivun sisältämät attribuutit.)</li>
      
      <li><code>POST /app/actor/{actorId}/movie</code> - polun parametri <code>actorId</code>, joka sisältää kytkettävän näyttelijän tietokantatunnuksen, ja parametri <code>movieId</code>, joka sisältää kytkettävän elokuvan tietokantatunnuksen. Lisäämisen tulee lopulta ohjata pyyntö osoitteeseen <code>/app/actor/</code>.</li>
      
    </ul>
  </li>
</ol>

</div>



<!--
VK4:


kerrosarkkitehtuurin jatkoa

  * kontrolleritaso
    * vastuut (kontrolleri vain kevyt, muut palveluihin)
    * parametrien validointi
      * flashmap jos tarttee ohjata sivulle jossa "errorerror"

    TEHT: PARAMETRIEN VALIDOINTI (AV)

    * spring form ja modelobject
      * model objektien validointi

    TEHT: FORMI JA MODELOBJEKTI, VALIDOINTI (AV)


-->


        <h3>Kontrolleritaso</h3>


        <p>Kontrolleritaso kuuntelee käyttöliittymältä tulevia pyyntöjä, ja vastaanottaa lähetettyä dataa. Käytännössä sovelluskehyksissä pyynnöt ohjataan kontrollereille erillisen front controllerin kautta. Front controller kuuntelee kaikkia sovellukselle ohjattuja pyyntöjä. Springiä käytettäessä käytämme Springin omaa <code>DispatcherServlet</code>-toteutusta, joka toimii front controllerina.</p>


        <p>Kontrolleritason ensisijaisena vastuuna on pyyntöjen kuuntelu, pyyntöjen ohjaaminen oikealle palvelulle, sekä tuotetun tiedon ohjaaminen oikealle näkymälle. Jotta palveluille ei ohjata epäoleellista dataa, esimerkiksi huonoja arvoja sisältäviä parametreja, on kontrolleritason vastuulla myös pyyntöparametrien validointi. Parametrien validointi tapahtuu käytännössä käsin, joko siten, että ohjelmoija itse toteuttaa validoinnin, tai jotain olemassaolevaa validointimekanismia käyttämällä.</p>


        <h4>Pyyntöparametrien validointi</h4>

        <p>Ensimmäinen askel pyyntöparametrien validointiin on pyyntöparametrien asettaminen odotetun tyyppisiin muuttujiin. Esimerkiksi numeerisia arvoja saavan parametrin oikeellisuuden voi varmistaa asettamalla sen <code>Integer</code>-tyyppiseen muuttujaan. Poikkeustapauksessa tiedämme heti, että käyttäjä on yrittänyt syöttää sovellukselle virheellisiä arvoja.</p>

        <p>Alkeellinen muuttujien arvojen validointi toteutetaan kontrolleriin tai erilliseen validointiluokkaan. Oletetaan että seuraava lomake sijaitsee tiedostossa <code>grocery-item-form.jsp</code>, lomakkeen lähetys ohjautuu luokassa <code>GroceryItemController</code> olevalle metodille <code>addGroceryItem</code>. Lisäksi käytössämme on erillinen rajapinta <code>GroceryItemService</code>, joka tarjoaa metodit tallentamiseen ja listaamiseen.</p>

<pre class="sh_xml">
&lt;form action="grocery-item" method="POST"&gt;
    &lt;input type="text" name="name"/&gt; &lt;br/&gt;
    &lt;input type="submit"/&gt;
&lt;/form&gt;
</pre>

<pre class="sh_java">
// ...
@Controller
public class GroceryItemController {
    
    @Autowired
    private GroceryItemService groceryItemService; 

    @RequestMapping(value = "grocery-item", method=RequestMethod.GET)
    public String viewForm() {
        return "grocery-item-form";
    }


    @RequestMapping(value = "grocery-item", method=RequestMethod.POST)
    public String addGroceryItem(@RequestParam String name) {
        // validointi

        groceryItemService.add(name);
        return "redirect:success";
    }

    // ...
} 
</pre>

<pre class="sh_java">
// ...
public interface GroceryItemService {
    void add(String name);
    List&lt;GroceryItem&gt; list();
}
</pre>

        <p>Ensimmäisessä validoinnissa estämme merkkijonot, joiden pituus on alle 5 tai yli 20. Jos merkkijono ei kelpaa, lomakkeessa tulee näyttää virheviesti "Length of name should be between 5 and 20.". Tämän lisäksi lomakkeessa tulee näyttää syötetty teksti. </p>


        <p>Jotta lomakkeessa voisi näkyä aiemmin syötetty teksti, tulee lomakkeessa olla sille attribuutti. Muokataan lomaketta siten, että siinä on paikka sekä virheelle että syötetylle datalle. Lomakkeessa olevalle <code>input</code>-elementille voi asettaa arvon <code>value</code>-attribuutin avulla. Virheviesti on merkattu EL-kielen attribuuttina <code>${nameError}</code> ja näytetään lomakekentän jälkeen. </p>


<pre class="sh_xml">
&lt;form action="grocery-item" method="POST"&gt;
    &lt;input type="text" name="name" value="${name}" /&gt; ${nameError} &lt;br/&gt;
    &lt;input type="submit"/&gt;
&lt;/form&gt;
</pre>


        <p>Muunnetaan seuraavaksi kontrolleriluokassa olevaa <code>addGroceryItem</code>-metodia siten, että nimen ollessa liian pitkä tai liian lyhyt, käyttäjälle palautetaan lomake jossa näkyy aiemmin lähetetty arvo sekä virhekuvaus. Tarvitsemme tätä varten POST-pyyntöä kuuntelevassa metodissa <code>Model</code>-olion.</p>


<pre class="sh_java">
// ...
@Controller
public class GroceryItemController {
    
    @Autowired
    private GroceryItemService groceryItemService; 

    @RequestMapping(value = "grocery-item", method=RequestMethod.GET)
    public String viewForm() {
        return "grocery-item-form";
    }

    @RequestMapping(value = "grocery-item", method=RequestMethod.POST)
    public String addGroceryItem(Model model, @RequestParam String name) {
        // validointi
        if(name.length() &lt; 5 || name.length() &gt; 20) {
            model.addAttribute("name", name);
            model.addAttribute("nameError", "Length of name should be between 5 and 20.");
            return "grocery-item-form";
        }

        groceryItemService.add(name);
        return "redirect:success";
    }

    // ...
} 
</pre>

        <p>Huomattavaa tässä on se, että emme pyydä käyttäjän selainta tekemään uudelleenohjausta lomakkeen lähetyksen epäonnistuessa, vaan palautamme käyttäjän takaisin lomakesivulle. Jos tarkistusmetodi tekisi uudelleenohjauksen myös lomakesivulle, ei <code>Model</code>-olioon lisättyjä attribuutteja olisi käytössä.</p>

<div class="pohdi">
  <p>Miksi <code>Model</code>-olioon lisätyt attribuutit eivät ole käytössä redirect-pyynnön jälkeen?</p>

  <p>&nbsp;</p>
  <p>&nbsp;</p>

</div> 

<div class="tehtavat">
  <NEXTWEEK></NEXTWEEK>
  <h3>Going for a Ball</h3>

  <p>Tehtävän mukana tulee sovellus, jota käytetään tanssijuhliin ilmoittatumiseen. Tällä hetkellä käyttäjä voi ilmoittautua juhliin oikeastaan minkälaisilla tiedoilla tahansa. Tehtävänäsi on toteuttaa parametreille seuraavanlainen validointi:</p>

  <p>
    <ol>
      <li>Nimen (<code>name</code>) tulee olla vähintään 4 merkkiä pitkä ja enintään 30 merkkiä pitkä.</li>
      <li>Osoitteen (<code>address</code>) tulee olla vähintään 4 merkkiä pitkä ja enintään 50 merkkiä pitkä.</li>
      <li>Sähköpostiosoitteessa (<code>email</code>) tulee olla <code>@</code>-merkki.</li>
    </ol>
  </p>

  <p>Jos yksikään ylläolevista tarkastuksista epäonnistuu, tulee käyttäjälle näyttää rekisteröitymislomake uudelleen. Tällöin lomakkeessa tulee olla lähetetyt parametrit valmiina. Tämän lisäksi jokaiselle virhetapaukselle tulee olla oma virheviesti. Virheviestit lisätään Model-olioon, jotta ne voidaan näyttää näkymässä. Virheviesteinä tulee käyttää seuraavia:</p>

  <p>
    <ol>
      <li>Attribuutin nimi: <code>nameError</code>, arvo: <code>Length of name should be between 4 and 30</code>.</li>
      <li>Attribuutin nimi: <code>addressError</code>, arvo: <code>Length of address should be between 4 and 50</code>.</li>
      <li>Attribuutin nimi: <code>emailError</code>, arvo: <code>Email should contain a @-character</code>.</li>
    </ol>
  </p>

  <p>Virheviestiä ei tule lisätä vastaukseen jos kyseistä virhettä ei lähetetyssä lomakkeessa ole. Käyttöliittymä on tehtävässä valmiina -- älä muuta luokassa <code>RegistrationController</code> olevien metodien parametrimäärittelyjä. Saat toki muokata metodien sisältöä sekä lisätä uusia metodeja. Alkuperäisten metodien toiminnan tulee säilyä <em>kun käyttäjän antamat rekisteröitymistiedot ovat oikein</em>.</p>

</div>


<div class="extra">
  <p><strong>Huom!</strong> TMC:ssä on bugi, joka liittyy tämän viikon tehtävien tarkistukseen. Jos saat TMC:stä virheviestin</p>

<pre>
java.lang.NoSuchMethodError: org.hamcrest.Matcher.describeMismatch
</pre>

  <p>ratkaisussasi on hyvin todennäköisesti virhe. Ongelmana on se, että TMC:n käyttämä testikehys käyttää testausta auttavan Hamcrest-kirjaston vanhempaa versiota kuin itse testit. Tämän takia testikehys suorittaa metodit eri tavalla kuin toivottu.</p>

  <p>Virheviesti kertoo käytännössä että sovelluksesta ei löydy metodia jolla kertoisin tästä virheestä.</p>

  <p>Toistaiseksi virheen kanssa tulee elää, käytännössä pulman voi ratkaista tarkastelemalla mitä asioita testi testaa. Jo testimetodien nimien pitäisi olla melko kuvaavia.</p>

  <p>Voit myös testata projekteja NetBeansissa valitsemalla projektin oikealla hiirennäppäimellä, ja klikkaamalla vaihtoehtoa <code>Test</code>. Tällöin ylläolevan ongelman ei pitäisi ilmaantua, ja saat hieman selkeämmän virhekuvauksen. Samoin projektien testaaminen onnistuu komentoriviltä komennolla <code>mvn test</code>.</p>

</div>



        <h4>Lomakkeet ja oliot</h4>


        <p>Kun pohdimme lomakkeita hieman enemmän, huomaamme että ne sopivat melko hyvin olio-ohjelmointiajatteluun. Lomakkeissa syötetään usein tietoa johonkin käsitteeseen -- luokkaan liittyen -- ja yhden lomakkeen sisältämät tiedot kuvautuvat helposti oliona. Onkin itseasiassa suhteellisen helppoa rakentaa oma luokka, joka muuntaa pyynnössä olevat parametrit tietynlaiseksi olioksi.</p>

        <p>Ajatustasolla olion luominen pyynnöstä tapahtuu luomalla ensin oliosta ilmentymä, ja sen jälkeen käymällä pyynnön parametreja läpi. Jos pyynnössä on parametri, joka on saman niminen kuin olion attribuutti, asetetaan parametrin arvo olion attribuutiksi. Huomattava osa yleisessä käytössä olevista sovelluskehyksistä tekee tämän jollain tavalla puolestamme. Spring-sovelluskehyksessä tämän toiminnallisuuden saa käyttöön lisäämällä Springin konfiguraatioon komennon <code>&lt;mvc:annotation-driven /&gt;</code>. Myös mvc-nimiavaruus tulee lisätä Springin konfiguraatioon.</p> 

<pre class="sh_xml">
...
       xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"        
       <strong>xmlns:mvc="http://www.springframework.org/schema/mvc"</strong>
       xmlns:context="http://www.springframework.org/schema/context"
       xsi:schemaLocation="http://www.springframework.org/schema/beans
                            <strong>...</strong>       
                            <strong>http://www.springframework.org/schema/mvc 
                            http://www.springframework.org/schema/mvc/spring-mvc-3.1.xsd</strong>
                            <strong>...</strong>
                            http://www.springframework.org/schema/context/spring-context-3.1.xsd"&gt;



&lt;mvc:annotation-driven /&gt;
</pre>

        <p>Nyt voimme käyttää olioita kontrollerissa olevien metodien parametrina. Tutkitaan tätä hieman tarkemmin.</p>

        <p>Oletetaan että käytössämme on luokka <code>Person</code>, joka sisältää attribuutit <code>name</code> ja <code>email</code>. Luokka on bean-tyyppinen, eli sillä on parametriton konstruktori ja getterit ja setterit (luistamme taas Serializable-rajapinnan toteutuksesta).</p>

<pre class="sh_java">
// pakkaus jne
public class Person {

    private String name;
    private String email;

    public String getName() {
        return name;
    }

    public void setName(String name) {
        this.name = name;
    }

    public String getEmail() {
        return email;
    }

    public void setEmail(String email) {
        this.email = email;
    }
}
</pre>

        <p><em>Kai olet jo huomannut, että bean-tyyppistä luokkaa luodessa sinun tarvitsee kirjoittaa luokalle vain attribuutit, ja valita NetBeansin insert code-toiminnallisuus sopivat toiminnallisuudet. Esimerkiksi get- ja set-metodien käsin kirjoittaminen on turhaa.</em></p>

        <p><code>Person</code>-luokalla on attribuutit <code>name</code> ja <code>email</code>. Luodaan lomake tietojen lähettämiseen.</p>

<pre class="sh_xml">
    &lt;form action="person" method="POST"&gt;
        &lt;span&gt;Name: &lt;input type="text" name="name" &gt;&lt;/span&gt;&lt;br&gt;
        &lt;span&gt;Email: &lt;input type="text" name="email" &gt;&lt;/span&gt;&lt;br&gt;
        &lt;input type="submit"&gt;
    &lt;/form&gt;
</pre>

        <p>Huomaa, että lomakkeen kenttien nimet ovat samat kuin luokan <code>Person</code> attribuuttien nimet. Luodaan seuraavaksi kontrollerimetodi pyynnön vastaanottamista varten. Spring-sovelluskehyksen annotaatio <em>@ModelAttribute</em> asettaa pyyntöön liittyviä parametreja annotoidun olion arvoksi.</p>

<pre class="sh_java">
    @RequestMapping(value = "person", method = RequestMethod.POST)
    public String createPerson(@ModelAttribute Person person) {
        // lähetetään person-olio esimerkiksi palvelulle
        return "redirect:list";
    }
</pre>


        <p>Pyyntöä suoritettaessa Spring asettaa pyynnön parametreja ensin <code>@ModelAttribute</code>-annotaatiolla merkattuihin olioihin. Tämän jälkeen arvoja asetetaan <code>@RequestParam</code>-annotaatiolla merkattuihin muuttujiin.</p>


        <h4>Olioiden validointi</h4>


        <p>Lomakkeiden ja lähetettävän datan validointi on web-sovelluksille hyvin oleellista. Emme halua että käyttäjä pääsee lähettämään sovelluksellemme toisten koneilla suoritettavaa koodia. Ensimmäinen askel -- jonka olemme jo ottaneet -- on tallennettavan datan järkevä esitys. Käytämme datan esittämiseen olioita, joihin on määritelty sopivat kenttien tyypit. Tämä helpottaa työtämme jo hieman: esimerkiksi numerokenttiin ei saa asetettua merkkijonoja.</p>

        <p>Tämä ei kuitenkaan vielä riitä.</p>

        <p>Javassa on oma API Bean-tyyppisten olioiden validoinnille: <a href="http://jcp.org/en/jsr/detail?id=303">Bean Validation API</a> (<a href="http://docs.oracle.com/javaee/6/api/javax/validation/constraints/package-summary.html">Javadoc</a>). Bean validation API on, kuten muutkin JSRt (<code>Java Specification Request</code>, vain rajapinta, jolla voi olla useampi toteuttaja. Käytämme JSR-303 -apin, eli Bean Validation APIn, toteutuksena <code><a href="http://www.hibernate.org/subprojects/validator.html" target="_blank">Hibernate Validator</a></code>-projektia (<a href="http://docs.jboss.org/hibernate/validator/4.3/reference/en-US/html_single/" target="_blank">dokumentaatio</a>), jonka saamme käyttöömme lisäämällä <code>pom.xml</code>-tiedostoon seuraavan riippuvuuden.</p>

<pre class="sh_xml">
        &lt;dependency&gt;
            &lt;groupId&gt;org.hibernate&lt;/groupId&gt;
            &lt;artifactId&gt;hibernate-validator&lt;/artifactId&gt;
            &lt;version&gt;4.3.0.Final&lt;/version&gt;
        &lt;/dependency&gt;
</pre>

        <p>Koska JSR-303:n määrittelemä Bean Validation API on hieman vaillinainen, eikä tarjoa työkaluja esimerkiksi sähköpostiosoitteiden validointiin, käytämme suoraan Hibernaten toteutusta.</p>


        <h4>Oliomuuttujien validointi</h4>


        <p>Muuttujien validointia varten tarkistettaville muuttujille määritellään annotaatiot. Muokataan aiemmin käytettyä luokkaa <code>Person</code> siten, että henkilöllä tulee olla henkilötunnus, nimi ja sähköpostiosoite.</p>


<pre class="sh_java">
// pakkaus jne
public class Person {

    private String socialSecurityNumber;
    private String name;
    private String email;

    public String getSocialSecurityNumber() {
        return socialSecurityNumber;
    }

    public void setSocialSecurityNumber(String socialSecurityNumber) {
        this.socialSecurityNumber = socialSecurityNumber;
    }

    public String getName() {
        return name;
    }

    public void setName(String name) {
        this.name = name;
    }

    public String getEmail() {
        return email;
    }

    public void setEmail(String email) {
        this.email = email;
    }
}
</pre>


        <p>Lisätään seuraavaksi attribuuttien validointi. Sovitaan että henkilötunnus ei saa koskaan olla tyhjä, ja sen tulee olla tasan 11 merkkiä pitkä. Nimen tulee olla vähintään 5 merkkiä pitkä, ja korkeintaan 30 merkkiä pitkä, ja sähköpostiosoitteen tulee olla validi sähköpostiosoite. Hibernate Validator-projektista löytyy näitä varten sopivia validointiannotaatioita. Annotaatio <code>@NotBlank</code> varmistaa ettei annotoitu attribuutti ole tyhjä -- lisätään se kaikkiin. Annotaatiolla <code>@Length</code> voidaan määritellä pituusrajoitteita muuttujalle, ja annotaatiolla <code>@Email</code> varmistetaan, että attribuutin arvo on varmasti sähköpostiosoite.</p>


<pre class="sh_java">
// pakkaus

import org.hibernate.validator.constraints.Email;
import org.hibernate.validator.constraints.Length;
import org.hibernate.validator.constraints.NotBlank;

public class Person {

    @NotBlank
    @Length(min = 11, max = 11)
    private String socialSecurityNumber;

    @NotBlank
    @Length(min = 5, max = 30)
    private String name;

    @NotBlank
    @Email
    private String email;

    // getterit ja setterit
</pre> 

        <p>Testataan luokan validointia ensin komentoriviltä. Olion validointi tapahtuu validoijan avulla, jonka voi luoda <code>javax.validation</code>APIn (JSR-303) avulla. Tämän jälkeen luodaan validoitava olio, joka annetaan validoijalle. Validoija taas palauttaa joukon validointivirheitä, jotka lopuksi tulostamme. Kun olemme nähneet joukon virheitä, asetamme sähköpostiosoite-kenttään arvon, jonka jälkeen validoimme olion uudestaan.</p>

<pre class="sh_java">
// pakkaus ja muita importteja

import java.util.Set;
import javax.validation.ConstraintViolation;
import javax.validation.Validation;
import javax.validation.Validator;
import javax.validation.ValidatorFactory;
import org.hibernate.validator.HibernateValidator;
import org.hibernate.validator.HibernateValidatorConfiguration;

public class ValidatoreApp {

    public static void main(String[] args) {
        // luodaan validoija
        HibernateValidatorConfiguration config = Validation.byProvider(HibernateValidator.class).configure();
        ValidatorFactory factory = config.buildValidatorFactory();
        Validator validator = factory.getValidator();

        // luodaan validoitava
        Person person = new Person();

        // validointi
        Set&lt;ConstraintViolation&lt;Person&gt;&gt; violations = validator.validate(person);

        // validointivirheiden tulostus
        for (ConstraintViolation&lt;Person&gt; violation : violations) {
            String path = violation.getPropertyPath().toString();
            String message = violation.getMessage();

            System.out.println(path + " " + message);
        }

        person.setName("El Barto");
        person.setEmail("elbarto");

        System.out.println("*****");

        for (ConstraintViolation&lt;Person&gt; violation : validator.validate(person)) {
            String path = violation.getPropertyPath().toString();
            String message = violation.getMessage();

            System.out.println(path + " " + message);
        }
    }
}
</pre>

        <p>Ylläolevan ohjelman tulostus on seuraavanlainen:</p>

<pre>
email may not be empty
socialSecurityNumber may not be empty
name may not be empty
*****
email not a well-formed email address
socialSecurityNumber may not be empty
</pre>

        <p>Käytännössä siis validointi onnistuu Hibernate Validator-komponentin avulla annotaatioilla. Lisätään validointi seuraavaksi osaksi kontrolleriluokkaa.</p> 


        <h4>Pyynnössä saatavan olion validointi kontrollerissa</h4>
        

        <p>Pyynnössä saatavan olion, joka on merkitty annotaatiolla <code>@ModelAttribute</code> validointi on helpohkoa. Kun olemme lisänneet Spring-konfiguraatioon komennon <code>&lt;mvc:annotation-driven/&gt;</code>, saamme käyttöön muitakin toiminnallisuuksia kuin olioiden generoinnin pyynnöstä. Yksi ominaisuus on olioiden validointi. Spring lataa automaattisesti käyttöönsä validointikehyksen, jos sellainen löytyy käytössä olevista kirjastoista. Jos olemme lisänneet Hibernate Validator-projektin osaksi <code>pom.xml</code>-tiedostoa, on se käytössämme automaattisesti.</p>

        <p>Itse olion validointi tapahtuu lisäämällä kontrollerimetodissa olevalle <code>@ModelAttribute</code>-annotaatiolle merkatulle oliolle annotaatio <code>@Valid</code> (<code>javax.validation.Valid;</code>).</p>

<pre class="sh_java">
    @RequestMapping(value = "person", method = RequestMethod.POST)
    public String create(@Valid @ModelAttribute Person person) {
        // .. toteutus
   }
</pre>

        <p>Nyt <code>person</code>-olion ilmentymä validoidaan heti kun se kontrollerissa vastaanottaa pyynnön. Validointivirheet eivät kuitenkaan ole kovin kaunista luettavaa. Yllä olevalla kontrollerimetodilla esimerkiksi virheellisen nimen kohdalla saamme statuskoodin <code>500</code>, sekä hieman kaoottisen ilmoituksen.</p>

<pre>
org.springframework.web.util.NestedServletException: Request processing failed; 
  nested exception is org.springframework.validation.BindException: 
  org.springframework.validation.BeanPropertyBindingResult: 4 errors
Field error in object 'person' on field 'name': rejected value []; 
  codes [NotBlank.person.name,NotBlank.name,NotBlank.java.lang.String,NotBlank]; 
  arguments [org.springframework.context.support.DefaultMessageSourceResolvable: 
  codes [person.name,name]; 
  arguments []; 
  default message [name]]; 
  default message [may not be empty]
  ...
</pre>

        <p>Ei kovin kaunista katseltavaa.</p>

        <p>Helpotetaan elämäämme hieman kytkemällä validointitulokset erilliseen olioon.</p>


        <h4>Olioiden validointi ja BindingResult</h4>


        <p>Kontrollerimetodissa oliota validoidessa validointivirheet aiheuttavat poikkeuksen, jos niille ei erikseen määritellä tallennuspaikkaa. Luokka <code>BindingResult</code> toimii validointivirheiden tallennuspaikkana, jonka kautta voimme käsitellä virheitä omien tarpeidemme mukaan. <code>BindingResult</code>-olio kuvaa aina yksittäisen olion luomisen ja validoinnin onnistumista, ja se tulee asettaa heti validoitavan olion jälkeen. Seuraavassa esimerkki kontrollerista, jossa validoinnin tulos lisätään <code>BindingResult</code>-olioon.</p> 

<pre class="sh_java">
    @RequestMapping(value = "person", method = RequestMethod.POST)
    public String create(@Valid @ModelAttribute Person person, BindingResult bindingResult) {
        if(bindingResult.hasErrors()) {
            // validoinnissa virheitä: virheiden käsittely
        }

        // muu toteutus 
    }
</pre>

        <p>Ylläolevassa esimerkissä kaikki validointivirheet tallennetaan <code>BindingResult</code>-olioon. Oliolla on metodi <code>hasErrors</code>, jonka perusteella päätämme jatketaanko pyynnön prosessointia vai ei. Yleinen muoto lomakedataa tallentaville kontrollereille on seuraavanlainen:</p>

<pre class="sh_java">
    @RequestMapping(value = "person", method = RequestMethod.POST)
    public String create(@Valid @ModelAttribute Person person, BindingResult bindingResult) {
        if(bindingResult.hasErrors()) {
            return "form";
        }

        // .. toteutus
    }
</pre>

        <p>Yllä oletetaan että lomake lähetettiin sivulta "form". Käytännössä jos näemme virheen validoinnissa, palaamme takaisin sivulle. Aiempaa lähestymistapaa seuraten voisimme käyttää erillistä <code>Model</code>-oliota validointivirheiden lisäämiseksi ja niiden näyttämiseksi sivulla. Tutkitaan seuraavaksi toista tapaa.</p>


        <h4>Springin lomakkeet ja BindingResult</h4>


        <p>Spring tarjoaa käyttöömme tägikirjaston lomakkeiden luomiseen JSP-sivulla. Lomakekirjaston saa JSP-sivulla käyttöön lisäämällä sivun alkuun seuraavan komennon.</p>

<pre class="sh_xml">
&lt;%@ taglib uri="http://www.springframework.org/tags/form" prefix="form"%&gt;
</pre>


        <p>Komento tuo käyttöömme springin lomakkeet, joita voi käyttää <code>form:</code>-etuliitteellä. Lomakkeet määritellään kuten normaalit HTML-lomakkeet, mutta sisältävät muutaman apuvälineen. Lomakkeen attribuutti <code>commandName</code> kertoo mihin kontrollerissa olevaan olioon lomakkeen kentät tulee pyrkiä liittämään. Sitä käytetään yhdessä kontrolleriluokan <code>ModelAttribute</code>-annotaation kanssa. Lomakkeen kentät määritellään polkujen <code>path</code> avulla, jotka kertovat ModelAttribute-annotaatiolla merkityn olion kentät. Ehkä oleellisin on kuitenkin tägi <code>&lt;form:errors path="..." /&gt;</code>, jonka avulla saamme kenttiin liittyvät virheet esille.</p>

        <p>Luodaan lomake aiemmin nähdyn <code>Person</code>-olion luomiseen.</p>


<pre class="sh_xml">
&lt;%@ taglib uri="http://www.springframework.org/tags/form" prefix="form"%&gt;
&lt;%@page contentType="text/html" pageEncoding="UTF-8"%&gt;
&lt;!DOCTYPE html&gt;
&lt;html&gt;
    &lt;head&gt;
        &lt;meta http-equiv="Content-Type" content="text/html; charset=UTF-8"&gt;
        &lt;title&gt;Person&lt;/title&gt;
    &lt;/head&gt;
    &lt;body&gt;
        &lt;h1&gt;Create new person&lt;/h1&gt;
        &lt;form:form commandName="person" action="${pageContext.request.contextPath}/person" method="POST"&gt;
            &lt;form:input path="socialSecurityNumber" /&gt;&lt;form:errors path="socialSecurityNumber" /&gt;&lt;br/&gt;
            &lt;form:input path="name" /&gt;&lt;form:errors path="name" /&gt;&lt;br/&gt;
            &lt;form:input path="email" /&gt;&lt;form:errors path="email" /&gt;&lt;br/&gt;
            &lt;input type="submit"&gt;
        &lt;/form:form&gt;
    &lt;/body&gt;
&lt;/html&gt;
</pre>

        <p>Yllä on määritelty lomake, joka lähettää lomakkeen tiedot osoitteessa <code>&lt;sovellus&gt;/person</code> olevalle alla kontrollerimetodille. Lomakkeelle tullessa tarvitsemme erillisen tiedon käytössä olevasta oliosta. Alla on näytetty sekä kontrollerimetodi, joka ohjaa GET-pyynnöt lomakkeeseen, että kontrollerimetodi, joka käsittelee POST-tyyppiset pyynnöt. Huomaa erityisesti <code>@ModelAttribute</code>-annotaatio kummassakin metodissa, sekä annotaation parametri <code>"person"</code>, joka vastaa lomakkeessa olevaan <code>command</code>-attribuuttia. Tämän avulla lomake tietää, mitä oliota käsitellään.</p>

<pre class="sh_java">
// yleistä tauhkaa

    @RequestMapping(value = "person", method = RequestMethod.GET)
    public String viewForm(@ModelAttribute("person") Person person) {
        return "form";
    }

    @RequestMapping(value = "person", method = RequestMethod.POST)
    public String create(@Valid @ModelAttribute Person person, BindingResult bindingResult) {
        if(bindingResult.hasErrors()) {
            return "form";
        }

        // .. toteutus
    }
</pre>

        <p>Jos lomakkeella lähetetyissä kentissä on virheitä, virheet tallentuvat <code>BindingResult</code>-olioon. Tarkistamme kontrollerimetodissa <code>create</code> ensin virheiden olemassaolon -- jos virheitä on, palataan takaisin lomakkeeseen. Tällöin Spring tuo lomakkeelle käyttöön sekä validointivirheet <code>BindingResult</code>-oliosta, että aiemmin lomakkeeseen syötetyt arvot <code>@ModelAttribute</code>-annotaatiolla merkitystä oliosta. Huomaa että virheet ovat pyyntökohtaisia, ja esimerkiksi kutsu "redirect:person" kadottaisi virheet.</p>

        <p><strong>Huom!</strong> Springin lomakkeita käytettäessä lomakesivut haluavat käyttöönsä olion, johon data kytketään jo sivua ladattaessa. Yllä lisäsimme pyyntöön <code>Person</code>-olion seuraavasti:</p>

<pre class="sh_java">
    @RequestMapping(value = "person", method = RequestMethod.GET)
    public String view(@ModelAttribute("person") Person person) {
        return "form";
    }
</pre>

        <p>Lomakkeista löytyy lisää tietoa Springin näkymäteknologioihin liittyvän dokumentaation osassa: <a href="http://static.springsource.org/spring/docs/current/spring-framework-reference/html/view.html" target="_blank">http://static.springsource.org/spring/docs/current/spring-framework-reference/html/view.html</a>. Jotta annotaatioilla avulla tapahtuva validointi toimisi, tulee Springin konfiguraatiossa olla rivi <code>&lt;mvc:annotation-driven /&gt;</code>.</p>


<div class="tehtavat">
  <h3>Going for a better Ball</h3>


  <p>Edellisessä tehtävässä parametrien validointi tehtiin käsin osana kontrolleriluokan toimintaa. Käytetään tällä kertaa ModelAttributea, Spring form-elementtiä ja annotaatioilla tapahtuvaa validointia.</p>

  <p>Jotta validoinnin saa päälle, sinun tulee lisätä seuraava rivi <code>front-controller-servlet.xml</code>-tiedostoon. Tiedostoon on valmiiksi määritelty <code>mvc:</code>-nimiavaruus.</p>

<pre class="sh_xml">
&lt;mvc:annotation-driven /&gt;
</pre>

  <p>Spring Form-lomake on toteutettu valmiiksi tehtäväpohjan mukana tuleviin JSP-sivuihin. Tehtävänäsi on toteuttaa validointitoiminnallisuus pakkauksessa <code>wad.registration.domain</code> olevaan luokkaan <code>Registration</code>.</p>

  <p>
    <ol>
      <li>Nimen (<code>name</code>) tulee olla vähintään 4 merkkiä pitkä ja enintään 30 merkkiä pitkä.</li>
      <li>Osoitteen (<code>address</code>) tulee olla vähintään 4 merkkiä pitkä ja enintään 50 merkkiä pitkä.</li>
      <li>Sähköpostiosoitteen (<code>email</code>) tulee olla validi sähköpostiosoite.</li>
    </ol>
  </p>

  <p>Jos yksikään ylläolevista tarkastuksista epäonnistuu, tulee käyttäjälle näyttää rekisteröitymislomake uudelleen. Muista lisätä kontrolleriin validoitavalle parametrille annotaatio <code>@Valid</code>. Virheviestien ei tule näkyä vastauksessa jos lomakkeessa ei ole virhettä. Käyttöliittymä on tehtävässä valmiina.</p>

</div>


        <h4>Validointi ja entiteetit</h4>


        <p>Vaikka esimerkissämme käyttämäämme <code>Person</code>-luokkaa ei oltu merkitty <code>@Entity</code>-annotaatiolla -- eli se ei ollut tallennettavissa JPAn avulla tietokantaan -- mikään ei estä meitä lisäämästä sille <code>@Entity</code>-annotaatiota. Toisaalta, lomakkeet voivat usein sisältää tietoa, joka liittyy useaan eri talletettavaan olioon. Tällöin onkin fiksua luoda erillinen lomakkeen validointiin tarkoitettu <em>lomakeolio</em>, <code>Form Object</code>, jonka pohjalta luodaan tietokantaan tallennettavat oliot kunhan validointi onnistuu. Erilliseen lomakeobjektiin voi täyttää myös kannasta haettavia listoja ym. ennalta.</p>


        <h3>Model ja Redirect</h3>


        <p>Kun käyttäjä ohjataan tekemään uusi pyyntö <code>redirect:</code>-komennon avulla, selaimelle käytännössä palautetaan HTTP statuskoodi 303 (tai 302), sekä uusi osoite. Tällöin selain tekee pyynnön uuteen osoitteeseen. Koska HTTP on tilaton protokolla, ei sillä ole välineistöä käyttäjän pyyntöjen yhdistämiseen: aiemmassa pyynnössä käytössä oleva data ei ole käytössä seuraavassa pyynnössä.</p>

        <p>Tämä on yleensä täysin hyväksyttävää, ja toivottavaakin, mutta joissain tapauksissa ohjelmoija haluaa aiemmasta pyynnöstä tietoja myös seuraavaan pyyntöön. Tyypillinen käyttötapaus on tietyn informaatioviestin lisääminen sivulle, johon käyttäjä ohjataan. HTTP-protokollan tarjoamat evästeet mahdollistavat tiedon katoamisen kiertämisen: jos kaivattu tieto tallennetaan sessioon, on se olemassa myös seuraavalla pyynnöllä. Vastaava toiminnallisuus on myös useassa sovelluskehyksessä valmiina.</p>

        <p>Spring tarjoaa pyynnöissä käytettävän parametrin <code><a href="http://static.springsource.org/spring/docs/current/javadoc-api/org/springframework/web/servlet/mvc/support/RedirectAttributes.html" target="_blank">RedirectAttributes</a></code>, johon voi tallentaa attribuutteja, jotka halutaan näkyville seuraavalla pyynnöllä. Käytännössä <code>RedirectAttributes</code>-olio tallentaa attribuutit sessioon, josta ne lisätään <code>Model</code>-olion attribuutteihin seuraavan pyynnön yhteydessä.</p>

        <p>Jotta <code>RedirectAttributes</code> toimii, on Spring-konfiguraatiossa oltava merkkijono <code>&lt;mvc:annotation-driven /&gt;</code>.</p>

        <p>Pohditaan tilannetta, jossa luomme uutta <code>Person</code>-oliota. Kun henkilö on luotu, käyttäjä ohjataan sivulle, jossa on henkilön tiedot. Kun käyttäjä tulee sivulle ensimmäisen kerran, sivulla näytetään myös viesti "New person created!". Lisätään <code>Person</code>-luokalle attribuutti <code>id</code>, jota käytetään henkilön tunnistamiseen.</p>

<pre class="sh_java">
// pakkaus

import org.hibernate.validator.constraints.Email;
import org.hibernate.validator.constraints.Length;
import org.hibernate.validator.constraints.NotBlank;

public class Person {

    private Long id;

    @NotBlank
    @Length(min = 11, max = 11)
    private String socialSecurityNumber;

    @NotBlank
    @Length(min = 5, max = 30)
    private String name;

    @NotBlank
    @Email
    private String email;

    // getterit ja setterit
</pre> 


        <p>Käytössämme on rajapinta <code>PersonService</code>, joka tarjoaa seuraavat metodit:</p>


<pre class="sh_java">
public interface PersonService {
    Person create(Person registration);
    Person read(Long id);
}
</pre>


        <p>Rajapinnan toteutus injektoidaan valmiiksi kontrolleriin -- kontrollerin ei oikeastaan tarvitse tietää toteutuksesta sen enempää: palvelutaso on abstrahoitu kontrollerilta. Muokataan aiemmin käytössämme ollutta <code>PersonController</code>-luokan <code>create</code> metodia siten, että se saa parametrina <code>RedirectAttributes</code>-olion. Parametrina saatu <code>Person</code>-olio annetaan <code>PersonService</code>-palvelun metodille <code>create</code>, joka muunmuassa asettaa oliolle yksilöivän tunnuksen ja (<em>mahdollisesti</em>) tallentaa sen esimerkiksi tietokantaan. Tämän jälkeen asetamme <code>RedirectAttributes</code>-oliolle kaksi attribuuttia.</p>

        <p>Normaali attribuutti, joka lisätään metodilla <code>addAttribute</code> on käytössä tämän pyynnön loppuun asti. Alla olevassa esimerkissä lisäämme attribuutin <code>id</code>, jonka Spring myöhemmin asettaa osaksi osoitetta, johon käyttäjä ohjataan palautettavaan merkkijonooon. Tällöin pyyntö ohjautuu juuri luotua <code>Person</code>-oliota käsittelevälle sivulle. Toinen attribuutti, joka lisätään metodilla <code>addFlashAttribute</code>, on käytössä vain seuraavan pyynnön ajan. Attribuutti <code>message</code> asetetaan automaattisesti seuraavan pyynnön attribuutteihin.</p>

<pre class="sh_java">
// pakkaus ja importit

@Controller
public class PersonController {

    @Autowired
    private PersonService personService;

    @RequestMapping(value = "person", method = RequestMethod.POST)
    public String create(RedirectAttributes redirectAttributes,
            @Valid @ModelAttribute(value="person") Person person,
            BindingResult bindingResult) {
        if(bindingResult.hasErrors()) {
            return "form";
        }
        
        person = personService.create(person);
        
        redirectAttributes.addAttribute("id", person.getId());
        redirectAttributes.addFlashAttribute("message", "New person created!");
        return "redirect:person/{id}";
    }

// muut metodit
</pre>

        <p>Nyt jos pyyntöä osoitteeseen <code>person/{id}</code> kuuntelee oma kontrollerimetodi, on sillä käytössä attribuutti <code>message</code> <em>ensimmäisellä kerralla kun käyttäjä päätyy sivulle</em>. Kontrollerimetodi, joka kuuntelee osoitetta <code>person/{id}</code> voi olla esimerkiksi seuraavanlainen.</p>

<pre class="sh_java">
    // ...
    @RequestMapping(value = "person/{personId}", method = RequestMethod.GET)
    public String viewPerson(Model model, @PathVariable Long personId) {
        Person person = personService.read(personId);
        model.addAttribute("person", person);
        
        return "person";
    }

    // ...
</pre>

        <p>Itse sivu <code>person.jsp</code> voi näyttää esimerkiksi seuraavanlaiselta (huomaa mielikuvituksen puute):</p>


<pre class="sh_xml">
&lt;%@page contentType="text/html" pageEncoding="UTF-8"%&gt;
&lt;!DOCTYPE html&gt;
&lt;html&gt;
    &lt;head&gt;
        &lt;meta http-equiv="Content-Type" content="text/html; charset=UTF-8"&gt;
        &lt;title&gt;${person.name}&lt;/title&gt;
    &lt;/head&gt;
    &lt;body&gt;
        &lt;h1&gt;${person.name} ${message}&lt;/h1&gt;

        &lt;p&gt;Email-address ${person.email}&lt;/p&gt;
    &lt;/body&gt;
&lt;/html&gt;
</pre>


        <p>Huomionarvoista tässä on se, että kun käyttäjä luo uuden <code>Person</code> olion, hänet ohjataan sivulle, joka näyttää käyttäjän tiedot. Sivun voi tallentaa kirjanmerkiksi, sillä sivu on aina olemassa. Kuitenkin ensimmäisellä kerralla käyttäjän tullessa sivulle, sivulla näkyy myös käyttäjäystävällinen viesti <code>"New person created!"</code>.</p>





<div class="tehtavat">
  <h3>Post/Redirect/Get</h3>

  <p>POST/Redirect/GET on yleinen web-suunnittelumalli, jonka avulla voidaan vältää osa toisteisista lomakkeiden lähetyksistä sekä helpottaa kirjanmerkkien käyttöä. Käytännössä ajatuksena on pyytää käyttäjä tekemään GET-pyyntö onnistuneen POST-pyynnön jälkeen. GET-pyynnössä palautetaan sivu, jossa näytetään muuttuneet tiedot, kun taas POST-pyynnöllä tehtiin pyyntö tiedon muuttamiseen.</p>

  <p>Parannellaan tässä tehtävässä erään tilauspalvelun toimintaa.</p>

  <h4>Validointi</h4>


  <p>Tällä hetkellä käyttäjän syöttämiä tietoja ei validoida millään tavalla. Lisää sovellukseen tilauksen (<code>Order</code>) validointi seuraavasti:</p>

  <p>
    <ul>
      <li>Nimen (<code>name</code>) tulee olla vähintään 4 merkkiä ja enintään 30 merkkiä pitkä.</li>
      <li>Osoitteen (<code>address</code>) tulee olla vähintään 4 merkkiä ja enintään 50 merkkiä pitkä.</li>
      <li>Tilatut esineet (<code>items</code>) ei saa olla tyhjä.</li>
    </ul>
  </p>

  <p>Jos joku edelläolevista ehdoista ei täyty, näytä käyttäjälle lomake siten, että siinä näkyy virheviestit ja jo syötetyt tiedot. Käyttöliittymä on rakennettu puolestasi, joten sinun tarvitsee muokata vain luokkia <code>OrderController</code> ja <code>Order</code>. Huom! Kannattanee käyttää <code>@NotEmpty</code>-annotaatiota esineiden tyhjyyden tarkistamiseen.</p>


  <h4>Post, Redirect, Get</h4>


  <p>Muuta sovellusta siten, että lomakkeen lähetyksen onnistuessa käyttäjä ohjataan erilliseen osoitteeseen, jossa näkyy hänen juuri tekemänsä ostos. Käyttäjän tulee pystyä asettamaan osoite kirjanmerkiksi, eli sen tulee olla pysyvä. Kun käyttäjä ohjautuu sivulle ensimmäistä kertaa, sivulla tulee näkyä viesti <code>Order placed!</code>. Toteuta uudelleenohjaus käyttämällä <code>RedirectAttributes</code> luokkaa osana toteutusta: aseta attribuutiksi <code>orderId</code> luodun tilauksen <code>id</code>, sekä lisää pyyntöön flash-attribuutti <code>message</code>, joka sisältää viestin <code>Order placed!</code>. Joudut myös muokkaamaan metodin palauttamaa merkkijonoa sopivasti.</p>

</div>



<h2>REST</h2>


        <p>REST (representational state transfer) on HTTP-protokollaan perustuva arkkitehtuurimalli erityisesti web-pohjaisten sovellusten toteuttamiseen. Taustaidea on periaatteessa yksinkertainen: osoitteilla määritellään haettavat ja muokattavat resurssit, pyyntömetodit kuvaavat resurssiin kohdistuvaa operaatiota, ja pyynnön rungossa on tarvittaessa resurssiin liittyvää dataa. HTTP:n GET- ja POST-komentojen lisäksi REST-sovellukset käyttävät ainakin PUT ja DELETE-pyyntöjä. Esimerkiksi yksinkertainen henkilöstörekisteri voitaisiin toteuttaa seuraavilla osoitteilla ja pyyntötavoilla.</p>
  
  <p>
    <ul>
      <li>GET osoitteeseen <em>/person</em> palauttaa henkilöiden tiedot <em>tai</em> osajoukon henkilöiden tiedoista -- riippuen toteutuksesta.</li>
      <li>PUT osoitteeseen <em>/person/{id}</em> lisää tai muokkaa henkilön tietoja tietyllä tunnuksella. Henkilön tiedot lähetetään pyynnön rungossa.</li>
      <li>DELETE osoitteeseen <em>/person/{id}</em> poistaa henkilön tietyllä tunnuksella.</li>
      <li>POST osoitteeseen <em>/person</em> luo uuden henkilön pyynnössä lähetettävän datan pohjalta. Palvelun vastuulla on päättää henkilölle tunnus.</li>
    </ul>
  </p>
  

        <p>Oleellisia asioita RESTissä ovat resurssien nimentä web-osoitteita käyttäen sekä HTTP-protokollan tarjoamien pyyntötyyppien käyttö. Osoitteissa käytetään substantiivejä -- ei <code>getPerson?id={tunnus}</code> vaan <code>/henkilo/{tunnus}</code>, ja pyynnöt kategorisoidaan pyyntötyyppien mukaan. DELETE-tyyppisessä pyynnössä poistetaan, POST-tyyppisellä pyynnöllä lisätään, PUT-tyyppisellä pyynnöllä joko lisätään tai päivitetään, ja GET-tyyppisellä pyynnöllä haetaan. Kuten normaalissakin HTTP-kommunikaatiossa, GET-pyyntöjen ei tule muuttaa dataa.</p>

        <p>REST on hyödyllinen arkkitehtuurimalli mm. olemassaolevien jo hieman ikääntyneiden palveluiden kapselointiin. Sovelluskehittäjä voi kehittää uuden käyttöliittymän, ja käyttää vanhaan sovellukseen liittyvää toiminnallisuutta REST-rajapinnan kautta. REST-arkkitehtuuriin perustuvat palvelut ovat nykyään hyvin yleisiä ja niiden luomiseen on tehty huomattava määrä apuohjelmia. Yksinkertaisen REST-palvelun voi luoda esimerkiksi suoraan olemassaolevasta NetBeansin <em>Web Services</em> -osiossa olevien toimintojen avulla.</p>

<div class="extra">
  <p>Tutustu Roy T. Fieldingin ja Richard N. Taylorin artikkeliin <code><a href="resurssit/principled-design-of-the-modern-web-architecture.pdf" target="_blank">"Principled Design of the Modern Web Architecture"</a></code>, jossa REST-arkkitehtuurityyli määritellään.</p> 

  <p>Vaikka yllä määrittelemme REST-apin HTTP-apin kautta, on Roy Fielding (nykyään?) sitä mieltä, että <a href="http://roy.gbiv.com/untangled/2008/rest-apis-must-be-hypertext-driven" target="_blank">REST-apissa on oleellista mahdollisuus resurssien välillä navigointiin</a>. Datan tulee olla hypertekstimäistä, ja osoitteiden palauttaman datan tulee sisältää linkit toisiin resursseihin.</p>

  <p>Olemme hieman kerettiläisiä, ja määrittelemme REST-apin toisin kuin Fielding toivoo: jos noudattaisimme hypertekstimäistä navigointia emme voisi käyttää PUT- ja DELETE-metodeja.</p>

</div>

        <p>Luodaan seuraavaksi oma REST-arkkitehtuuria seuraava kontrolleri aiemmin nähtyjen <code>Person</code>-olioiden luontiin ja muokkaamiseen.</p>


        <h3>REST-tyyppinen arkkitehtuuri Person-olioiden tallentamiseen ja muokkaamiseen</h3>


        <p>Alla on esimerkki REST-tyylisen rajapinnan avulla luodusta olutpalvelusta. Olutpalvelussa käyttäjä voi lisätä, muokata ja poistaa oluita. Oletetaan, että käytössämme on palvelu <code>PersonService</code>, joka tarjoaa meille seuraavanlaisen rajapinnan:</p>

<pre class="sh_java">
public interface PersonService {
    Person create(Person person);
    Person read(Long identifier);
    Person update(Long identifier, Person person);
    void delete(Long identifier);

    List&lt;Person&gt; list();
}
</pre>

        <p>Rajapinta tarjoaa CRUD-toiminnallisuuden, sekä metodin kaikkien <code>Person</code>-olioiden listaamiseen. Toteutetaan seuraavaksi kontrolleri, joka kuuntelee pyyntöjä seuraaviin osoitteisiin:</p>

  <p>
    <ul>
      <li>POST-pyyntö osoitteeseen <em>person</em> luo uuden henkilön pyynnössä lähetettävän datan perusteella. Palvelun vastuulla on päättää henkilölle tunnus. Kun henkilö on luotu, pyyntö ohjataan näkymään, jossa näytetään henkilön tiedot.</li>
      <li>GET-pyyntö osoitteeseen <em>person/{id}</em> palauttaa näkymän, jossa näytetään yksittäisen id:llä <code>{id}</code> identifioidun henkilöt tiedot.</li>
      <li>PUT-pyyntö osoitteeseen <em>person/{id}</em> muokkaa <code>{id}</code>-tunnuksella merkityn henkilön tietoja. Henkilön tiedot lähetetään pyynnön rungossa.</li>
      <li>DELETE osoitteeseen <em>person/{id}</em> poistaa henkilön tunnuksella <code>{id}</code>.</li>
      <li>GET-pyyntö osoitteeseen <em>person</em> palauttaa näkymän, jossa listataan kaikki henkilöt.</li>
    </ul>
  </p>



<pre class="sh_java">
// pakkaus ja importit
@Controller
public class PersonController {

    @Autowired
    private PersonService personService;

    @RequestMapping(method = RequestMethod.POST, value = "person")
    public String create(RedirectAttributes redirectAttributes, 
                         @Valid @ModelAttribute Person person,
                         BindingResult bindingResult) {
        if(bindingResult.hasErrors()) {
            return "form"; // käytössä form.jsp, jossa lomake henkilön luomiseen
        }
 
        person = personService.create(person);
        
        redirectAttributes.addAttribute("personId", person.getId());
        redirectAttributes.addFlashAttribute("message", "Created!");

        return "redirect:person/{personId}";
    }

    @RequestMapping(method = RequestMethod.GET, value = "person/{personId}")
    public String read(Model model, @PathVariable Long personId) {
        model.addAttribute("person", personService.read(personId));

        return "view"; // käytössä view.jsp -niminen jsp-sivu
    }

    @RequestMapping(method = RequestMethod.PUT, value = "person/{personId}")
    public String update(RedirectAttributes redirectAttributes,
                         @ModelAttribute Person person, @PathVariable Long personId) {
        person = personService.update(personId, person);

        redirectAttributes.addAttribute("personId", person.getId());
        redirectAttributes.addFlashAttribute("message", "Updated!");

        return "redirect:person/{personId}";
    }

    @RequestMapping(method = RequestMethod.DELETE, value = "person/{personId}")
    public String delete(@PathVariable Long personId) {
        personService.delete(personId);

        return "redirect:/person";
    }

    @RequestMapping(method = RequestMethod.GET, value = "person")
    public String list(Model model) {
        model.addAttribute("list", personService.list());

        return "list"; // käytössä list.jsp -niminen jsp-sivu
    }
}
</pre>


        <p>Kuten huomaat, REST-toteutuksemme käyttää aiemmin tutuksi tulleita kommunikointimenetelmiä. Osoitteet identifioivat resurssin, pyyntötavat halutun resurssin. Ylläolevan esimerkin ohjaustyyleistä kannattaa ottaa mallia myös omiin sovelluksiin. Kontrolleriluokan metodit -- kuten kontrollerit kokonaisuudessaan -- tulee pitää mahdollisimman pieninä. Varsinainen sovelluslogiikka hoidetaan erillisessä palvelussa.</p>


        <h3>PUT ja DELETE HTML-lomakkeissa</h3>


        <p>HTML-lomakkeet tukevat vain pyyntötyyppejä GET ja POST. Haluamme pystyä käyttämään REST-tyyppisiä pyyntöjä, eli GET- ja POST-pyyntöjen lisäksi myös PUT- ja DELETE-komentoja. Käytännössä pyyntötyyppien muokkaus toteutetaan sovelluskehysten toimesta siten, että lomakkeisiin asetetaan erillinen attribuutti, joka määrittelee pyynnön tyypin. Sovelluskehys muokkaa pyyntöä attribuutin perusteella ennen sen päätymistä kontrollerille siten, että pyyntö käyttää haluttua pyyntötyyppiä.</p>

        <p>Springissä pyyntötyypin muuttaminen onnistuu Springin form-tägillä ja erillisellä filtterillä. Filtteri tulee käsittelemään <code>front-controller</code>-servletille ohjautuvia pyyntöjä. Tämä onnistuu lisäämällä seuraava konfiguraatio <code>web.xml</code>-tiedostoon.</p>

<pre class="sh_xml">
    &lt;filter&gt;
        &lt;filter-name&gt;http-method-filter&lt;/filter-name&gt;
        &lt;filter-class&gt;org.springframework.web.filter.HiddenHttpMethodFilter&lt;/filter-class&gt;
    &lt;/filter&gt;

    &lt;filter-mapping&gt;
        &lt;filter-name&gt;http-method-filter&lt;/filter-name&gt;
        &lt;servlet-name&gt;front-controller&lt;/servlet-name&gt;
    &lt;/filter-mapping&gt;
</pre>

        <p>Kun filtteri on konfiguroitu, voidaan Springin form-tägillä määriteltyjä lomakkeita muokata siten, että niissä käytetään PUT- tai DELETE-pyyntöjä. Normaalit GET- ja POST-pyynnöt toimivat kuten ennenkin. Esimerkiksi seuraavaa lomaketta voisi käyttää henkilön poistamiseen.</p>

<pre class="sh_xml">
        &lt;form:form action="${pageContext.request.contextPath}/person/${personId}" method="DELETE"&gt;
            &lt;input type="submit"&gt;
        &lt;/form:form&gt;
</pre>

        <p>Sovellusta käytettäessä Spring luo lomakkeelle piilokentän, jonka nimenä on <code>_method</code> ja arvona <code>DELETE</code>.</p>

<pre class="sh_xml">
        &lt;form id="command" action="/validatortesting/app/person/1" method="post"&gt;
            &lt;input type="hidden" name="_method" value="DELETE"/&gt;
            &lt;input type="submit"/&gt;
        &lt;/form&gt;
</pre>

        <p>Huom! Kun luot lomakkeille kontrolleria, varmista että palautusarvot ovat kunnossa. Esimerkiksi DELETE-tyyppisen kutsun käsittelyn jälkeen käyttäjä tulee ohjata tekemään uusi GET-pyyntö.</p>

<div class="tehtavat">
  <h3>Taking a REST</h3>

  <p>Tässä tehtävässä toteutetaan Unipalvelu, johon käyttäjä voi tallentaa tietoja nukkumisestaan. Tehtävässä halutaan harjoitella erityisesti <a href="http://en.wikipedia.org/wiki/REST" target="_blank">REST</a>-tyylisiä osoitteita ja pyyntöjä. Emme kuitenkaan vielä toteuta varsinaista rajapintaa vaan harjoittelemme osoitteita ja pyyntöjä tavallisilla HTML-näkymillä. Tehtävään on jo valmiiksi konfiguroitu <code>web.xml</code> tiedostoon <code>HiddenHttpMethodFilter</code>-filtteri, joka mahdollistaa DELETE-pyynnön.</p>

  <h4>Domain-luokka</h4>
  
  <p>Muokkaa pakkauksessa <code>wad.rest.domain</code> oleva luokka <code>Sleep</code> niin, että se toteuttaa alla olevan rungon. Tee luokasta entiteetti ja määritä sille tietokantataulun nimi. Muista myös luoda getterit ja setterit attribuuteille.

<pre class="sh_java sh_sourceCode">
import org.springframework.format.annotation.DateTimeFormat;

public class Sleep {

    private Long id;
    
    @DateTimeFormat(pattern = "d.M.y H.m")
    private Date start;
    
    @DateTimeFormat(pattern = "d.M.y H.m")
    private Date end;
    
    private String feeling;
}
</pre>

    <p><code>@DateTimeFormat</code> annotaatiolla Spring muuntaa patternin <code>d.M.y H.m</code> muotoisen merkkijonoesityksen päivämäärästä ja ajasta (kuten 23.9.2012 18.41) <code>Date</code>-olioksi. Voimme siis syöttää lomakkeessa merkkijonon, joka muutetaan suoraan <code>Date</code>ksi. Kätevää! Jotta <code>@DateTimeFormat</code> toimii, on <code>pom.xml</code>ään lisätty jo valmiiksi riippuvuus pakettiin <code>joda-time</code>.  

    <p>
        <strong>Attribuuteista:</strong>
        <ul>
            <li><code>id</code> - Automaattisesti generoituva <code>Long</code>-tyyppinen avain, käytä annotaatiota <code>@GeneratedValue</code> strategialla <code>AUTO</code>.</li>
            <li><code>start</code> - Käytä annotaatiota <code>@Temporal</code> tyypillä <code>DATE</code>. Haluamme myös validoida, ettei attribuutti voi olla null.</li>
            <li><code>end</code> - Kuten edeltävä attribuutti.</li>
            <li><code>feeling</code> - Halumme validoida, ettei attribuutti voi olla tyhjä tai null.</li>
        </ul>
    </p>
    
    <p>Muista myös nimetä jokaisen attribuutin tietokantataulun sarakkeiden nimet!</p>
    
    <h4>Repository-rajapinta</h4>
    
    <p>Tee entiteetille repository-rajapinta <code>SleepRepository</code> pakkaukseen <code>wad.rest.repository</code>. Rajapinnan tulee tuttuun tapaan periä Spring Data JPA:n rajapintaluokka <code>CrudRepository</code> siten, että tallennettava olio on tyyppiä <code>Sleep</code> ja avaimena on <code>Long</code>.</p>
    
    <h4>Palvelu</h4>
    
    <p>Haluamme nyt noudattaa kerrosarkkitehtuuria. Toteuta siis pakkaukseen <code>wad.rest.service</code> palveluluokka <code>JpaSleepService</code>, joka toteuttaa samassa pakkauksessa olevan rajapinnan <code>SleepService</code>. Toteuta rajapinnan määrittelemät metodit injektoimalla luokkaan <code>@Autowired</code>-annotaatiota käyttäen <code>SleepRepository</code>n toteuttava luokka. Injektoitavasta luokasta löytyy tarvittavat metodit <code>JpaSleepService</code>n toteuttamiseen.</p>
    
    <p>Muista määrittää luokan <code>JpaSleepService</code>n metodeille <code>@Transactional</code>-annotaatiot. Määritä annotaatiolle myös boolean-tyyppiset parametrit <code>readOnly</code> sen mukaan muuttaako metodi tietokannassa olevaa tietoa vai ei.</p>
    
    <h4>Kontrollerit ja näkymät</h4>
    
    <p>Tehtävässä on valmiina jo yksi kontrolleri <code>BaseController</code>. Tämän sisältämä metodi <code>getIndex</code> kaappaa juuren (joka on edelleen <code>/app/</code>) osoitteen ja palauttaa näkymän <code>index</code>. Modeliin myös lisätään tyhjä Sleep-olio näkymään lisättävää lomaketta varten.</p>
    
    <p>Muokkaa näkymää <code>index.jsp</code>. Lisää sinne Spring-lomake <code>Sleep</code> luokkaa varten. Lomakkeen <code>commandName</code> tulee olla <code>sleep</code>, <code>action</code> ohjaa polkuun <code>/app/sleeps</code> ja <code>method</code> on <code>POST</code>.</p>
    
    <p>Lomakkeessa tulee olla Spring-lomakkeen tarjoamat tekstikentät poluille <code>start</code>, <code>end</code> ja <code>feeling</code>. Määrittele kentille myös id:t (start, end ja feeling vastaavasti). Lisää myös mahdolliset virhetulostukset kyseisille poluille.</p>
    
    <p>Toteuta pakkaukseen <code>wad.rest.controller</code> kontrolleriluokka <code>RESTSleepController</code>. Luokan tulee toteuttaa samassa pakkauksessa sijaitseva rajapinta <code>SleepController</code>. Injektoi luokkaan <code>@Autowired</code>-annotaatiota käyttäen <code>SleepServicen</code>n toteuttava luokka. Luokan metodien tulee toimia seuraavanlaisesti:
    
    <ul>
        <li>
            <code>public String create(Model model, Sleep sleep, BindingResult result)</code>
            <ol>
                <li>Vastaa POST-pyyntöihin osoitteessa <code>sleeps</code>.</li>
                <li>Parametrina saadaan lomakkeesta generoitu <code>Sleep</code> entiteetti. Käytä <code>@ModelAttribute</code>-annotaatiota ja varmista, että entiteetti on validi. <code>@ModelAttribute</code>n arvona käytetään lomakkeeseen määriteltyä <code>commandName</code>a.</li>
                <li>Mikäli <code>result</code> oliossa on virheitä, lisää <code>model</code>iin parametrissa saatu <code>sleep</code> entiteetti attribuutilla <code>sleep</code>. Tällöin metodin tulee palauttaa näkymä <code>index</code> virheiden näyttämistä varten.</li> 
                <li>Mikäli virheitä ei ole, metodi käyttää palvelukerroksesta tallentaakseen <code>Sleep</code> entiteetin tietokantaan ja ohjaa käyttäjän osoitteeseen <code>/app/sleeps</code>.</li>
            </ol>
        </li>
        <li>
            <code>public String read(Model model, Long id)</code>
            <ol>
                <li>Vastaa GET-pyyntöihin osoitteessa <code>sleeps/{id}</code>, polussa tulee haettavan <code>Sleep</code> entiteetin ID.</li>
                <li>Hakee palvelukerroksesta vastaavan entiteetin ja lisää sen <code>model</code>iin attribuutilla <code>sleep</code>.</li>
                <li>Palauttaa näkymän <code>sleep</code>.</li>
            </ol>
        </li>
        <li>
            <code>public String delete(Long id)</code>
            <ol>
                <li>Vastaa DELETE-pyyntöihin osoitteessa <code>sleeps/{id}</code>, polussa tulee poistettavan <code>Sleep</code> entiteetin ID.</li>
                <li>Käyttää palvelukerrosta kyseisen <code>Sleep</code> entiteetin poistamiseen.</li>
                <li>Ohjaa käyttäjän osoitteeseen <code>/app/sleeps</code>.</li>
            </ol>
        </li>
        <li>
            <code>public String list(Model model)</code>
            <ol>
                <li>Vastaa GET-pyyntöihin osoitteessa <code>sleeps</code>.</li>
                <li>Hakee palvelukerroksesta listan kaikista <code>Sleep</code> entiteeteistä ja lisää ne <code>model</code>iin attribuutilla <code>sleeps</code>.</li>
                <li>Palauttaa näkymän <code>sleeps</code>.</li>
            </ol>
        </li>
    </ul>
    
    <p>Muokkaa vielä näkymää <code>sleep.jsp</code> lisäämälle sinne Spring-lomake <code>Sleep</code> entiteetin poistoa varten. Lomakkeen tulee tehdä <code>DELETE</code>-pyyntö osoitteeseen <code>/app/sleeps/{id}</code>. Lomakkeessa ei tarvitse olla muuta kuin input submittausta varten.</p>
    
    <p>Testaa nyt ohjelma vielä kokonaisuudessaan ja kun testit menevät läpi, lähetä sovellus TMC:lle. You better get some REST now!</p>
    
</div>

        
        <h3>JSON-muotoista dataa käyttävä REST-sovellus</h3>


        <p>REST-tyyppisten palveluiden ei aina kannata palauttaa kokonaista HTML-sivua: REST-rajapintaa käytetäänkin usein ilman erillistä HTML-sivua. Tarvitsemme kuitenkin jonkun tavan tiedon esittämiseen ja siirtämiseen. Yleisimmät tiedonsiirtomuodot tällä hetkellä ovat JSON ja XML, joista ensimmäisen suosio kasvaa jatkuvasti. Olemme tällä kurssilla lähinnä kiinnostuneita JSON-muotoisesta datasta.</p>


        <h4>JSON</h4>


        <p><a href="http://www.json.org/" target="_blank">JSON</a> (JavaScript Object Notation) on Javascriptin käyttämä tiedonsiirtoformaatti. JSON-formaatin yksi hienous on se, että JSON-objekteja voi lukea suoraan Javascript-olioiksi. Tämä tulee tutummaksi kurssilla <em>Web-selainohjelmointi</em>. JSON mahdollistaa avain-arvo -parien ja listojen esittämisen. Oletetaan, että käytössämme on seuraava olutta kuvaava luokka <code>Beer</code>.</p>


<pre class="sh_java">
public class Beer {
    private Long id;
    private String name;

    public Long getId() {
        return id;
    }

    public void setId(Long id) {
        this.id = id;
    }

    public String getName() {
        return name;
    }

    public void setName(String name) {
        this.name = name;
    }
}
</pre> 


        <p>Oluella on numeerinen tunnus ja nimi. Yksittäinen olut, jonka nimi on <code>"Hacker-Pschorr Hefe Weisse"</code> ja tunnus on <code>10</code>, esitetään JSON-notaatiolla seuraavasti.</p>

<pre>
{"name":"Hacker-Pschorr Hefe Weisse","id":10}
</pre>

        <p>Listarakenteessa, jossa oluita on enemmän, avain-arvo -parit esitetään pilkulla erotettuna hakasulkeiden (<code>[]</code>) sisällä.</p>

<pre>
[{"name":"Hacker-Pschorr Hefe Weisse","id":10},
 {"name":"Buttface Amber Ale","id":11},
 {"name":"Yellow Snow","id":12}]
</pre>

        <p>JSON hyväksyy arvoiksi merkkijonoja, numeroita, toisia avain-arvo -pareja, listoja, totuusarvoja ja tyhjiä null -elementtejä.</p>

        <p>Kuten suurin osa sovelluskehyksistä, Spring tarjoaa palvelun olioiden JSON-muotoon muuttamiseksi. Jotta olioiden muuttaminen JSON-muotoon toimisi, tulee Spring-konfiguraatiossamme olla komento <code>&lt;mvc:annotation-driven /&gt;</code> ja <code>pom.xml</code>-tiedostossa riippuvuus <a href="http://jackson.codehaus.org/" target="_blank">Jackson JSON</a>-kirjastoon.</p>

<pre class="sh_xml">
        &lt;dependency&gt;
            &lt;groupId&gt;org.codehaus.jackson&lt;/groupId&gt;
            &lt;artifactId&gt;jackson-mapper-asl&lt;/artifactId&gt;
            &lt;version&gt;1.9.9&lt;/version&gt;
        &lt;/dependency&gt;
</pre>

        <p>Spring käyttää Jacksonia JSON-datan tuottamiseen. Käytännössä Jackson käy läpi luokan attribuutit, ja luo niiden arvojen pohjalta JSON-dataa. Esimerkiksi <code>Beer</code>-olion voi tulostaa JSON-muodossa Jacksonin avulla seuraavasti:</p>

<pre class="sh_java">
// pakkaus

import java.io.IOException;
import java.io.StringWriter;
import org.codehaus.jackson.map.ObjectMapper;

public class BeerJackson {

    public static void main(String[] args) throws IOException {
        // Olio, joka muuttaa oliot JSON-dataksi
        ObjectMapper mapper = new ObjectMapper();

        // luodaan olut
        Beer beer = new Beer();
        beer.setId(1L);
        beer.setName("Buttface Amber Ale");

        // luodaan olio, johon JSON-muotoinen data tallennetaan
        StringWriter stringWriter = new StringWriter();

        // luodaan JSON-muotoinen esitys beer-oliosta
        // ja ohjataan se stringWriter-olioon
        mapper.writeValue(stringWriter, beer);
        
        // tulostetaan JSON-muotoinen esitys
        System.out.println(stringWriter);
    }
}
</pre>


        <p>Ylläolevan ohjelman tulostus on seuraavanlainen:</p>


<pre>
{"id":1,"name":"Buttface Amber Ale"}
</pre>


        <p>Jotta kontrollerimetodit osaavat käsitellä JSON-dataa, tulee <code>@RequestMapping</code>-metodeille määritellä erilliset <code>produces</code>- ja <code>consumes</code>-attribuutit, joilla kerrotaan minkälaista dataa kyseinen osoite tuottaa ja ottaa vastaan. Luodaan ensimmäinen metodi, <code>list</code>, jonka tehtävänä on tuottaa JSON-muotoinen lista kaikista palvelussa olevista oluista. Koska metodi tuottaa tietoa, se tarvitsee <code>produces</code>-attribuutin. Tuotetun tiedon muoto on <code>application/json</code>. Tämän lisäksi määrittelemme metodille annotaation <code>@ResponseBody</code>, jonka avulla sanomme, että metodin palauttama arvo asetetaan vastauksen runkoon.</p>

<pre class="sh_java">
    // ...
    @RequestMapping(method = RequestMethod.GET, value = "beer", produces="application/json")
    @ResponseBody
    public List&lt;Beer&gt; list() {
        return beerService.list();
    }
    // ...
</pre>

        <p>Jos <code>beerService.list()</code>-metodi palauttaa listan oluista, luodaan niistä JSON-muotoinen lista, joka palautetaan käyttäjälle. Alla on esimerkki metodin palautuksesta, kun selaimella tehdään kysely palveluun, jossa on aiemmin nähdyt kolme olutta.</p>

<pre>
[{"id":3,"name":"Yellow Snow"},
{"id":2,"name":"Buttface Amber Ale"},
{"id":1,"name":"Hacker-Pschorr Hefe Weisse"}]
</pre>


          <p>Voimme määritellä kontrollerimetodin vastaanottamaan JSON-muotoista dataa asettamalla siihen liittyvään <code>@RequestMapping</code>-annotaatioon <code>consumes</code>-attribuutin. Attribuutille <code>consumes</code> asetetaan arvo <code>"application/json"</code>, jolla ilmoitamme että metodi vastaanottaa JSON-muotoista dataa. Tämän lisäksi metodin vastaanottama data tulee muuntaa JSON-muotoon. Voimme tehdä tämän annotoimalla metodin parametri <code>Beer</code> <code>@RequestBody</code>-annotaatiolla.</p>

<pre class="sh_java">
    // ...
    @RequestMapping(method = RequestMethod.POST, value = "beer", consumes = "application/json")
    public String create(RedirectAttributes redirectAttributes, @RequestBody Beer beer) {
        beer = beerService.create(beer);

        redirectAttributes.addAttribute("beerId", beer.getId());

        return "redirect:beer/{beerId}";
    }
    // ...
</pre>

        <p>Ylläoleva metodi vastaanottaa POST-tyyppisiä pyyntöjä, joiden sisältö on JSON-muotoista dataa. JSON-muodossa olevasta datasta luodaan <code>Beer</code>-olio, joka tallennetaan <code>beerService</code>-olion toimesta. Tallennuksen jälkeen pyyntö ohjataan uudelle sivulle.</p>

<div class="extra">
      <p>JSON-tyyppistä dataa kuuntelevien metodien toiminnallisuutta voi kätevästi testata <code>curl</code>-komennon avulla. Alla olevassa esimerkissä palvelimelle lähetetään POST-tyyppinen pyyntö, joka sisältää JSON-tyyppistä dataa. Pyyntö tehdään osoitteeseen <code>http://palvelin-ja-sovellus/beer</code>.</p>

      <p>Kenoviivan käyttö mahdollistaa komennon kirjoittamisen useammalle riville.</p>

<pre>
curl -X POST -H "Content-Type: application/json; charset=utf-8" \
-d "{\"name\":\"Blithering Idiot\"}" \
http://palvelin-ja-sovellus/beer
</pre>

</div>

        <p>Loput <code>BeerController</code>-luokan metodit onnistuu ylläolevien metodien avulla. Alla on esimerkkitoteutus <code>BeerController</code>-luokasta, jossa on mukana myös <code>init</code>-metodi, joka <code>@PostConstruct</code>-annotaation ansiosta suoritetaan kontrolleria ensimmäistä kertaa ladattaessa.</p>

<pre class="sh_java">
// pakkaus ja importit

@Controller
public class BeerController {

    @Autowired
    private BeerService beerService;
    
    @PostConstruct
    private void init() {
        Beer beer = new Beer();
        beer.setId(1L);
        beer.setName("Hacker-Pschorr Hefe Weisse");
        beerService.create(beer);
        
        beer = new Beer();
        beer.setId(2L);
        beer.setName("Buttface Amber Ale");
        beerService.create(beer);
     
        beer = new Beer();
        beer.setId(3L);
        beer.setName("Yellow Snow");
        beerService.create(beer);
        
    }

    @RequestMapping(method = RequestMethod.POST, value = "beer", consumes = "application/json")
    public String create(RedirectAttributes redirectAttributes, @RequestBody Beer beer) {
        beer = beerService.create(beer);
        redirectAttributes.addAttribute("beerId", beer.getId());
        return "redirect:beer/{beerId}";
    }

    @RequestMapping(method = RequestMethod.GET, value = "beer/{beerId}", produces="application/json")
    @ResponseBody
    public Beer read(@PathVariable Long beerId) {
        return beerService.read(beerId);
    }

    @RequestMapping(method = RequestMethod.PUT, value = "beer/{beerId}", consumes="application/json")
    public String update(RedirectAttributes redirectAttributes, @RequestBody Beer beer, 
                         @PathVariable Long beerId) {
        beer = beerService.update(beerId, beer);
        redirectAttributes.addAttribute("beerId", beer.getId());
        return "redirect:beer/{beerId}";
    }

    @RequestMapping(method = RequestMethod.DELETE, value = "beer/{beerId}")
    public String delete(@PathVariable Long beerId) {
        beerService.delete(beerId);
        return "redirect:/beer";
    }

    @RequestMapping(method = RequestMethod.GET, value = "beer", produces="application/json")
    @ResponseBody
    public List&lt;Beer&gt; list() {
        return beerService.list();
    }
}
</pre>

<!-- 

REST

  * polkujen nimentä
  * resurssiajattelu (osoitteet identifioivat resurssin)
  * pyyntötyypit, GET, PUT, POST, DELETE
    * ja jokaisen operaation spesifi tarkoitus
  
  TEHT: sovellus, joka käyttää REST-rajapintaa (KASPER)
     -> .1 testaa curlilla
        .2 luo lomake, aseta spring-formin vaatima filtteri
  
 
  * JSON
    * responsebody
    * requestbody

  TEHT: REST + JSON (KASPER)
-->




<div class="tehtavat">

  <h3>RESTgull Service</h3>
  
  <p>Tietojenkäsittelytieteen laitos on erikoistunut muiden erikoisalueidensa lisäksi <a href="http://fi.wikipedia.org/wiki/Lokit" target="_blank">lokkien</a> bongaamiseen. Erästä TKTL:llä yhä kehitettävää järjestelmää käytetään lintubongausten hallinnointiin mm. museoviraston toimesta. Tässä tehtävässä toteutetaan REST-tyyppinen JSON-dataa käsittelevä rajapinta lokkibongausten käsittelyyn.</p>


  <p>Sovelluksessa on toteutettuna kaikki muut luokat paitsi luokka <code>GullSightingController</code>. Toteuta luokkaan seuraava toiminnallisuus:</p>

  <p>
    <ul>
      <li>GET-pyyntö osoitteeseen <code>gull</code> palauttaa JSON-muotoisen listan tietokannassa olevista havainnoista. Käytä GullSightingService-rajapintaa havaintojen noutamiseen.<br/><br/></li>
      <li>GET-pyyntö osoitteeseen <code>gull/{tunnus}</code> palauttaa JSON-muotoisen esityksen <code>tunnus</code>-polkumuuttujan identifioimasta havainnosta. Käytä olemassaolevaa GullSightingService-rajapintaa havainnon noutamiseen.<br/><br/></li>     
      <li>JSON-dataa sisältävä POST-pyyntö osoitteeseen <code>gull</code> tallentaa uuden <code>GullSighting</code>-olion GullSightingService-rajapinnan avulla. Pyynnön voi ohjata esimerkiksi osoitteeseen <code>gull/{juuriLuodunHavainnonId}</code><br/><br/></li>
      <li>DELETE-pyyntö osoitteeseen <code>gull/{tunnus}</code> poistaa <code>tunnus</code>-merkkijonon identifioiman havainnon. Ohjaa pyyntö poiston jälkeen osoitteeseen <code>/gull</code>.<br/><br/></li>
    </ul>
  </p>


  <p>Voit testata toteuttamasi palvelun toimimintaa <code>curl</code>-komentorivityökalun avulla. Tämän tehtävän testit ovat poikkeuksellisesti vain TMC-palvelimella, etkä saa testeiltä palautetta paikallisesti.</p>

</div>



<h2>SOA</h2>

        <p><em>Jeff Bezos @ Amazon: Anyone who doesn't do this will be fired.</em></p>
    

        <p>SOA (<em>Service Oriented Architecture</em>), eli palvelukeskeinen arkkitehtuuri, on suunnittelutapa, jossa eri sovelluksen komponentit on suunniteltu toimimaan itsenäisinä avoimen rajapinnan tarjoavina palveluina. Pilkkomalla sovellukset erillisiin palveluihin pyritään luomaan tilanne, jossa palveluita voidaan käyttää myös tulevaisuudessa kehitettävien sovellusten toimesta. Avoimet rajapinnat helpottavat huomattavasti palveluihin integroitumista.</p>

        <p>SOA-palveluita käyttävät esimerkiksi toiset palvelut tai selainohjelmistot. Esimerkiksi web-sivustot voivat hakea JSON-muotoista dataa Javascriptin avulla ilman tarvetta omalle palvelinkomponentille. SOA-arkkitehtuuri helpottaa myös ikääntyvien sovellusten jatkokäyttöä: ikääntyvät sovellukset voidaan kapseloida esimerkiksi REST-rajapinnan taakse, jonka kautta sovelluksen käyttö onnistuu myös jatkossa. </p>

        <p>Rakentamalla palvelut avoimia rajapintoja käyttäen, palveluiden käyttäjän ei tarvitse välittää palvelun toteutuksessa käytetystä ohjelmointikielestä. Niin pitkään kun palvelun tuottama data seuraa avointa standardia, esimerkiksi JSON-dataa tuottavaa REST-tyyliä, ei palveluiden taustalla olevilla ohjelmointikielillä ole väliä. Oleellista kuitenkin on, että kun palvelua kehitetään, sitä käyttävien sovellusten toiminnan ei tule rikkoutua.</p>
    
        <p>Oikeastaan, olemme jo toteuttaneet SOA-arkkitehtuuriin perustuvia sovelluksia. Esimerkiksi aiemmin toteutettu RESTGull Service toimii palveluna, jota muut voivat käyttää.</p>
        


<div class="tehtavat">
  <h3>Pastebin</h3>

  <p>Tässä tehtävässä toteutetaan <a href="http://pastebin.com/">Pastebin</a>-palvelua (jopa nimeltään) muistuttava sovellus. Sovellusta käytetään siis lyhyiden teksti- tai koodipätkien (<em>snippet</em>) tallettamiseen ja tarkasteluun.</p>

  <p>Tehtäväpohjan mukana tulee valmiina palvelun käyttöliittymä, jossa on seuraavat toiminnot:
    <ul>
      <li>kaikkien snippetien listaus</li>
      <li>snippetien listaus käyttäjän perusteella</li>
      <li>yksittäisen snippetin tarkastelu</li>
      <li>uuden snippetin lisäys</li>
      </ul></p>
  <p>Lisäksi käyttöliittymässä on automaattinen <em>syntax highlight</em> lukuisille eri ohjelmointikielille.</p>

  <p>Jokaiseen sovelluksen tallettamaan snippetiin liittyy käyttäjän nimi, jonka perusteella tietyllä nimellä talletettuja snippetejä voi listata.</p>

  <h4>Domain-luokat</h4>

  <p>Luo pakkaukseen <code>wad.pastebin.data</code> luokka <code>JpaUser</code>, joka toteuttaa samassa pakkauksessa olevan rajapinnan <code>User</code>. Tee luokasta entiteetti ja määritä sille tietokantataulun nimi <code>User</code>.</p>

  <p>Entiteetillä <code>JpaUser</code> tulee olla rajapinnan määrittämät attribuutit:
    <ul>
      <li><code>id</code> (automaattisesti generoitu numeerinen avain, käytä annotaatiota <code>@GeneratedValue</code> strategialla <code>AUTO</code>)</li>
      <li><code>nickname</code> (käyttäjän nimimerkki)</li>
      </ul></p>

  <p>Luo pakkaukseen <code>wad.pastebin.data</code> luokka <code>JpaSnippet</code>, joka toteuttaa samassa pakkauksessa olevan rajapinnan <code>Snippet</code>. Tee luokasta entiteetti ja määritä sille tietokantataulun nimi <code>Snippet</code>.</p>

  <p>Entiteetillä <code>JpaSnippet</code> tulee olla rajapinnan määrittämät attribuutit:
    <ul>
      <li><code>id</code> (automaattisesti generoitava numeerinen avain, käytä annotaatiota <code>@GeneratedValue</code> strategialla <code>AUTO</code>)</li>
      <li><code>user</code> (<code>@ManyToOne</code>-viittaus snippetin lähettäneeseen käyttäjään, eli entiteettiin <code>JpaUser</code>)</li>
      <li><code>timestamp</code> - snippetin talletusajankohta</li>
      <li><code>content</code> - snippetin tekstisisältö -- määrittele sarakkeen maksimipituudeksi yli 30000 merkkiä <code>@Column</code>-annotaation <code>length</code>-parametrilla, jotta sarakkeeseen mahtuu paljon tekstiä, ja käytä <code>@Lob</code>-annotaatiota, sillä se mahdollistaa suurien tekstimäärien talletuksen tietokantaan</li>
    </ul></p>

  <h4>Repository-rajapinnat ja omien kyselyjen toteuttaminen</h4>

  <p>Tee kummallekin entiteetille oma repository-rajapinta käyttäen Spring Data JPA:n rajapintaa <code>org.springframework.data.jpa.repository.JpaRepository</code>, joka toimii samalla tavoin kuin aiemmin käytetty <code>CrudRepository</code>, mutta siinä on enemmän toimintoja mm. tulosten järjestämiseen liittyen. Rajapintojen nimet tulee olla: <code>wad.pastebin.repository.JpaUserRepository</code> ja <code>wad.pastebin.repository.JpaSnippetRepository</code>.</p>

  <p>Jotta sovelluksessa voitaisiin etsiä käyttäjiä nimimerkin perusteella tai listata tietyn käyttäjän snippetit, täytyy sitä varten luoda mukautettuja kyselyitä. Onneksi Spring Data JPA tekee uusien kyselyjen määrittelemisestä helppoa, sillä kyselyn toteuttamiseen täytyy ainoastaan lisätä sopivan niminen metodi repository-rajapintaan.</p>

  <p>Metodien nimeäminen tapahtuu seuraavien sääntöjen mukaisesti:
    <ul>
      <li>metodin paluuarvoksi tulee entiteetin luokka, jos halutaan yksittäinen vastaus, tai <code>List&lt;T<&gt;</code>-olio, jossa <code>T</code> on entiteetin luokka, jos tarkoitus on saada useampia vastauksia -- esim. <code>JpaUser</code>, jos halutaan tuloksen yksittäinen käyttäjä</li>
      <li>metodin nimi on muotoa <code>findByX</code>, jossa <code>X</code> on entiteetin attribuutin nimi (alkukirjain isolla), johon haku kohdistuu -- esim. <code>findByNickname</code>, jos halutaan tehdä haku nimimerkin perusteella</li>
      <li>metodin parametreiksi tulee kyselyn parametrit, esim. <code>String nickname</code>, kun haetaan tiettyä nimimerkkiä</li>
      </ul></p>

  <p>Sovelluksessa tarvitaan seuraavat kyselyt:
  <ul>
    <li><code>JpaUserRepository</code>-rajapintaan tulee lisätä metodi <strong>yksittäisen</strong> käyttäjän hakemiseen nimimerkin perusteella</li>
    <li><code>JpaSnippetRepository</code>-rajapintaa tulee lisätä metodi <strong>kaikkien</strong> tietyn käyttäjän snippetien hakemiseen (käyttäjän perusteella) -- lisäksi metodille tulee antaa parametrina järjestämiseen käytettävä olio, joka on tyyppiä <code>org.springframework.data.domain.Sort</code></li>
  </ul></p>

  <h4>Palvelukerros</h4>

  <p>Luo palveluluokka <code>wad.pastebin.service.JpaUserService</code>, joka toteuttaa samassa pakkauksessa olevan rajapinnan <code>UserService</code>. Palveluluokassa tulee määritellä transaktio jokaiselle metodille erikseen ja luokan tulee käyttää <code>JpaUserRepository</code>-rajapintaa tietokantaoperaatioihin. Palveluluokan metodien tulee toimia CRUD-metodien osalta normaalisti (kuten aiemmissa tehtävissä) ja muiden metodien osalta seuraavasti:
    <ul>
      <li><code>findAll()</code> metodin tulee listata kaikki käyttäjät</li>
      <li><code>findByNickname(String nickname)</code> metodin tulee hakea yksittäinen käyttäjä nimimerkin perusteella (mikä on jo toteutettu repository-tasolla)</code></li>
    </ul></p>

  <p>Luo palveluluokka <code>wad.pastebin.service.JpaSnippetService</code>, joka toteuttaa rajapinnan <code>SnippetService</code>. Toteuta luokka edellisen palveluluokan ohjeiden mukaisesti seuraavin poikkeuksin:
    <ul>
      <li><code>findAll()</code> metodin tulee listata kaikki snippetit</li>
      <li><code>findByUser(User user)</code> metodin tulee listata kaikki tietyn käyttäjän snippetit</li>
    </ul></p>

  <h4>Tulosten järjestäminen</h4>

  <p>Tavallisesti tietokannasta haetut tulokset eivät ole missään ennalta määritellyssä järjestyksessä ja järjestys saattaa jopa vaihdella eri kyselyiden välillä. Sovelluksessa talletettavien snippetien kannalta kiinnostavimpia ovat usein uusimmat snippetit, joten haetut snippetit täytyy järjestää ajan mukaan. Spring Data JPA:n rajapinta <code>JpaRepository</code> mahdollistaa tulosten järjestämisen tietokantatasolla (jolloin se on tehokasta) metodin <code>findAll(Sort sort)</code> avulla. Esimerkiksi nimimerkin mukaan järjestäminen tapahtuisi näin:</p>

<pre class="sh_java">
jpaUserRepository.findAll(new Sort(Sort.Direction.ASC, "nickname"));
</pre>

  <p>Luokkan <code>Sort</code> konstruktorin ensimmäinen parametri on järjestyksen suunta: <code>Sort.Direction.ASC</code> järjestää pienimmästä suurimpaan (esim. 1..9, A..Z) ja <code>Sort.Direction.DESC</code> suurimmasta pienimpään (9..1, Z..A), toinen on entiteetin attribuutin nimi.</p>

  <p>Järjestä seuraavien palvelukerroksen metodikutsujen tulokset:
    <ul>
      <li><code>JpaUserService.findAll()</code> metodin tulee palauttaa käyttäjät aakkosjärjestyksessä</li>
      <li><code>JpaSnippetService.findAll()</code> metodin tulee palauttaa snippetit <strong>käänteisessä</strong> aikajärjestyksessä, uusin ensin</li>
      <li><code>JpaSnippetService.findByUser(User user)</code> metodin tulee palauttaa snippetit <strong>käänteisessä</strong> aikajärjestyksessä, uusin ensin</li>
      </ul>
    </p>
  
  <h4>PastebinController</h4>

  <p><strong>Huom!</strong> Tässä vaiheessa kannattaa alkaa testata ohjelmaa selaimella, jotta saat varmistettua, että kontrollerin metodit toimivat oikein.</p>

  <p>Luo luokka <code>wad.pastebin.controller.PastebinController</code>, joka toteuttaa rajapinnan <code>PastebinControllerInterface</code>. Luokan metodien tulee toimia seuraavalla tavalla:
    <ul>
      <li><code>createSnippet(String nickname, String content)</code>
        <ol>
          <li>vastaa POST-pyyntöihin osoitteessa <code>snippets</code></li>
          <li>hakee nimimerkin ja snippetin sisällön POST-pyynnön parametreista <code>nickname</code> ja <code>content</code></li>
          <li>hakee palvelukerroksen avulla <code>JpaUser</code> käyttäjän annetulle nimimerkille -- jos vastaavaa käyttäjää ei löydy, luo metodi uuden käyttäjän annetulla nimimerkillä</li>
          <li>luo ja tallettaa nimimerkkiä vastaavalle käyttäjälle uuden snippetin, jonka aikaleima on nykyhetki ja jonka sisältö on käsitelty HTML-injektion estämiseksi <code>StringEscapeUtils.escapeHtml4</code>-metodin avulla</li>
          <li>uudelleenohjaa pyynnön näkymään osoitteessa <code>snippets/[id]</code>, jossa näytetään kyseinen snippet -- <code>[id]</code> tulee olla juuri luodun snippetin numeerinen avain</li>
        </ol>
      </li>
      <li><code>listSnippets(Model model)</code>
        <ol>
          <li>vastaa GET-pyyntöihin osoitteessa <code>snippets</code></li>
          <li>hakee listan kaikista snippeteistä ja tallettaa sen <code>model</code>-instanssiin avaimella <code>snippets</code></li>
          <li>näyttää näkymän <code>list-snippets</code></li>
        </ol>
      </li>
      <li><code>viewSnippet(Model model, Long snippetId)</code>
        <ol>
          <li>vastaa GET-pyyntöihin osoitteessa <code>snippets/{snippetId}</code>, jossa <code>{snippetId}</code> on haettavan snippetin numeerinen avain</li>
          <li>hakee annetun avaimen mukaisen snippetin -- jos avaimella ei löydy snippetiä, uudelleenohjataan pyyntö osoitteeseen <code>snippets</code></li>
          <li>tallettaa snippetin <code>model</code>-instanssiin avaimella <code>snippet</code></li>
          <li>näyttää näkymän <code>view-snippet</code></li>
        </ol>
      </li>
      <li><code>listSnippetsByUser(Model model, String nickname)</code>
        <ol>
          <li>vastaa GET-pyyntöihin osoitteessa <code>users/{nickname}/snippets</code>, jossa <code>{nickname}</code> on haettavan käyttäjän nimimerkki</li>
          <li>hakee annettua nimimerkkiä vastaavan käyttäjän -- jos avaimella ei löydy käyttäjää, uudelleenohjataan pyyntö osoitteeseen <code>users</code></li>
          <li>hakee listan käyttäjän kaikista snippeteistä</li>
          <li>tallettaa käyttäjän <code>model</code>-instanssiin avaimella <code>user</code></li>
          <li>tallettaa snippet-listan <code>model</code>-instanssiin avaimella <code>snippets</code></li>
          <li>näyttää näkymän <code>list-snippets-by-user</code></li>
        </ol>
      </li>
      <li><code>listUsers(Model model)</code>
        <ol>
          <li>vastaa GET-pyyntöihin osoitteessa <code>users</code></li>
          <li>hakee listan kaikista käyttäjistä ja tallettaa sen <code>model</code>-instanssiin avaimella <code>users</code></li>
          <li>näyttää näkymän <code>list-users</code></li>
        </ol>
      </li>
    </ul>
  </p>

</div>

        
<div class="extra">
   <p>Tutustu artikkeliin <a href="http://paidcontent.org/2011/10/13/419-the-biggest-thing-amazon-got-right-the-platform/" target="_blank">The Biggest Thing Amazon Got Right: The Platform</a>.</p>
   
   <p>Uskotko että Amazonin ohjelmistokehittäjät olisivat lähteneet SOA-muutokseen ilman Jeff Bezosin viestin kohtaa nro 6?</p>
   <p>Seuraako juuri toteuttamasi Pastebin-sovellus SOA-arkkitehtuurityyliä? Jos ei, mitä muutoksia siihen tulisi tehdä?</p>
</div>



<h3>Asynkroniset palvelut</h3>

  <p>Tähän mennessä toteuttamissamme sovelluksissa pyynnön suorittaminen on tapahtunut seuraavasti:</p>

  
  <p>
    <ol>
      <li>Pyyntö lähetetään palvelimelle</li>
      <li>Palvelin vastaanottaa pyynnön ja ohjaa pyynnön oikealle kontrollerille</li>
      <li>Kontrolleri vastaanottaa pyynnön ja ohjaa pyynnön oikealle palvelulle</li>
      <li>Palvelu vastaanottaa pyynnön, suorittaa pyyntöön liittyvät operaatiot mahdollisesti muiden palveluiden kanssa, ja palauttaa vastauksen kontrollerille</li>
      <li>Kontrolleri ohjaa pyynnön sopivalle näkymälle, joka palautetaan käyttäjälle.</li>
    </ol>
  </p>

  <p>Tietokantaoperaation tai palvelukutsun valmistumisen odottaminen ei aina ole käyttäjäystävällistä. Jos sovelluksemme suorittaa esimerkiksi raskaampaa laskentaa tai on muista palveluista johtuen hidas, kannattaa pyyntö suorittaa asynkronisesti.</p>


  <p>Asynkroniset metodikutsut tapahtuvat seuraavasti:</p>

  <p>
    <ol>
      <li>Pyyntö lähetetään palvelimelle</li>
      <li>Palvelin vastaanottaa pyynnön ja ohjaa pyynnön oikealle kontrollerille</li>
      <li>Kontrolleri vastaanottaa pyynnön ja ohjaa pyynnön oikealle palvelulle</li>
      <li>Palvelu asettaa pyynnön suoritusjonoon ja palvelukutsusta palataan heti (palvelun tyyppi on void)</li>
      <li>Kontrolleri ohjaa pyynnön sopivalle näkymälle, joka palautetaan käyttäjälle.</li>
    </ol>
  </p>

  <p>Käytännössä asynkroniset metodikutsut toteutetaan luomalla palvelukutsusta erillinen säie, jossa pyyntöä käsitellään. Tämäkin on toteutettu usean sovelluskehyksen puolesta automaattisesti. Asynkronisten metodikutsujen käyttöön saaminen vaatii taas pienen määrän konfiguraatiota. Lisää ensin Springin konfiguraatiotiedostoon nimiavaruusmäärittely <code>spring-task</code>-nimiavaruudelle.</p>

<pre class="sh_xml">
<strong>...</strong>
    <strong>xmlns:task="http://www.springframework.org/schema/task"</strong>
    xsi:schemaLocation="
        <strong>...
        http://www.springframework.org/schema/task
        http://www.springframework.org/schema/task/spring-task-3.1.xsd
        ...</strong>"&gt;

<strong>...</strong>
</pre>

  <p>Kun nimiavaruus on konfiguroitu, lisätään konfiguraatiotiedostoon rivi, jolla sanomme että tehtävien hallinta hoidetaan annotaatioiden avulla.</p>

<pre class="sh_xml">
    &lt;task:annotation-driven /&gt;
</pre>

  <p>Kun konfiguraatio on paikallaan, voimme toteuttaa palvelutason metodeja asynkronisesti. Jotta palvelutason metodi olisi asynkroninen, sen tulee olla <code>void</code>-tyyppinen, sekä sillä tulee olla annotaatio <code>@Async</code>.</p>


  <p>Tutkitaan kahta erilaista tapausta, jossa tallennetaan <code>Item</code>-olioita. Item-olion sisäinen muoto ei ole niin tärkeä. Ensimmäisessä tapauksessa <code>Item</code>-olion tunnuksen generoinnin vastuu on tietokannalla. Kun tietokanta on generoinut tunnuksen ja tallentanut olion tietokantaan, palautetaan siihen viite.</p>

<pre class="sh_java">
    @RequestMapping(method = RequestMethod.POST, value = "item")
    public String create(RedirectAttributes redirectAttributes,
            @Valid @ModelAttribute Item item, BindingResult bindingResult) {
        if (bindingResult.hasErrors()) {
            return "form";
        }

        item = itemService.create(item);
        
        redirectAttributes.addAttribute("itemId", item.getId());
        return "redirect:item/{itemId}";
    }
</pre>

  <p>Palvelutason metodi <code>create</code> palauttaa ylläolevassa tapauksessa viitteen luotavaan olioon. Tarkastellaan toisenlaista tapausta, jossa <code>Item</code>-oliolle generoidaan viite kontrollerimetodissa. Palvelutason metodi on <code>void</code>-tyyppinen, eikä tallennuksen tapahtumisen ajankohta ole niin oleellinen.</p>

<pre class="sh_java">
    @RequestMapping(method = RequestMethod.POST, value = "item")
    public String create(RedirectAttributes redirectAttributes,
            @Valid @ModelAttribute Item item, BindingResult bindingResult) {
        if (bindingResult.hasErrors()) {
            return "form";
        }

        item.setId(UUID.randomUUID().toString());
        itemService.create(item);
        
        redirectAttributes.addAttribute("itemId", item.getId());
        return "redirect:item/{itemId}";
    }
</pre>

  <p>Kahden yllä esitetyn kontrollerimetodin ero on hyvin pieni, mutta vain toisessa palvelutason toteutus asynkronisesti on mahdollista.</p>

  <p>Oletetaan että <code>ItemService</code>-olion metodi <code>create</code> on void-tyyppinen, ja näyttää seuraavalta:</p>

<pre class="sh_java">
    public void create(Item item) {
        itemRepository.save(item);
    }
</pre>

  <p>Metodin muuttaminen asynkroniseksi vaatii <code>@Async</code>-annotaation.</p>

<pre class="sh_java">
    @Async
    public void create(Item item) {
        itemRepository.save(item);
    }
</pre>

  <p>Voila! Käytännössä asynkroniset metodikutsut toteutetaan asettamalla metodikutsu suoritusjonoon, josta se suoritetaan kun sovelluksella on siihen mahdollisuus. Yleensä tämä tapahtuu erittäin nopeasti.</p>



<div class="tehtavat">
  <h3>Heavy Calculations</h3>

  <p>Kumpulan kampuksella sijaitseva sisennyksen tutkimusyksikkö SIIT on kehittänyt tutkimussiivessään mullistavan merkkijonoalgoritmin ja haluavat demonstroida sen toiminnallisuutta web-sivulla. Muutaman yrityksen jälkeen he ovat huomanneet, että algoritmi on hieman hitaahko. Tehtävänäsi on tässä tehtävässä muuttaa demoamiseen käytettävää sovellusta siten, että algoritmin prosessointi tehdään taustalla. Älä kuitenkaan muuta itse algoritmin toimintaa.</p>

  <p>Lisää sovellukselle konfiguraatio asynkronisten metodien suorittamiseen ohjelmallisesti, sekä muuta algoritmin sisältävää palveluluokkaa <code>InMemoryDataProcessor</code> siten, että prosessoinnin sisältävä metodi <code>sendForProcessing</code> suoritetaan asynkronisesti. Älä muuta metodin <code>sendForProcessing</code> sisältöä!</p>

</div>


<h4>Toistuvat metodikutsut</h4>


  <p>Springin <code>task</code>-toiminnallisuuden avulla voimme myös toteuttaa palveluita, joihin kytketyt toiminnallisuudet suoritetaan tietyin aikavälein. Voisimme esimerkiksi haluta RSS-lukijan, joka hakee uusimmat uutiset kerran minuutissa. Annotaatio <code>@Scheduled</code> mahdollistaa tietyin aikavälein tapahtuvat pyynnöt. Sille voidaan määritellä ajastuksia esimerkiksi <a href="http://fi.wikipedia.org/wiki/Cron">cron</a>-formaatissa. Seuraavan komponenttiluokan metodi <code>executeOnceInAMinute</code> suoritetaan kerran minuutissa.</p>

<pre class="sh_java">
@Component
public class CronService {

    @Scheduled(cron = "1 * * * * *")
    public void executeOnceInAMinute() {
        // ...
    }
}
</pre>

  <p>Lisää Springin Async- ja Scheduled-annotaatioista mm. <a href="http://static.springsource.org/spring/docs/current/spring-framework-reference/html/scheduling.html" target="_blank">Springin dokumentaatiosta</a>.</p>


  
  <h3>Case: Sovellus binääritiedostojen tallentaminen</h3>


  <p>Tyypillinen sovelluskehittäjien jossain vaiheessa kohtaama vaatimus on palvelu käyttäjän tiedostojen vastaanottamiseen ja tallentamiseen. Toteutetaan tässä palvelu, johon voi lähettää tiedostoja. Tiedostot tallennetaan tietokantaan, josta ne voi listata.</p>

  <p>Jotta tiedostojen lähettäminen palvelimelle olisi mahdollista, tarvitsemme Apache Commons-projektin fileupload-komponentin käyttöömme. Fileupload-komponentti tarvitsee käyttöönsä commons-io -projektin, joten lisätään molemmat <code>pom.xml</code>-tiedostoomme:</p>

<pre class="sh_xml">
    &lt;dependency&gt;
        &lt;groupId&gt;commons-fileupload&lt;/groupId&gt;
        &lt;artifactId&gt;commons-fileupload&lt;/artifactId&gt;
        &lt;version&gt;1.2.2&lt;/version&gt;
    &lt;/dependency&gt;
    &lt;dependency&gt;
        &lt;groupId&gt;commons-io&lt;/groupId&gt;
        &lt;artifactId&gt;commons-io&lt;/artifactId&gt;
        &lt;version&gt;2.4&lt;/version&gt;
    &lt;/dependency&gt; 
</pre>

  <p>Tämän lisäksi lisätään <code>front-controller-servlet.xml</code>-tiedostoon erillinen Apache Commonsia käyttävä <code>bean</code>, jonka tehtävänä on käsitellä tiedostoja sisältävät pyynnöt.</p>

<pre class="sh_xml">
    &lt;bean id="multipartResolver"
        class="org.springframework.web.multipart.commons.CommonsMultipartResolver"&gt;
        &lt;!-- hyväksytään korkeintaan megatavun kokoiset tiedostot --&gt;
        &lt;property name="maxUploadSize" value="1000000"/&gt;
    &lt;/bean&gt;
</pre>


  <p>Toteutetaan ensin tiedoston lähettämiseen soveltuva lomake ja kontrolleriluokka.</p>

<pre class="sh_xml">
    &lt;form action="${pageContext.request.contextPath}/app/data" method="POST" enctype="multipart/form-data"&gt;
        Name:&lt;br/&gt;
        &lt;input type="text" name="name"/&gt;&lt;br/&gt;
        Description:&lt;br/&gt;
        &lt;textarea name="description"&gt;
        &lt;/textarea&gt;&lt;br/&gt;
        File:&lt;br/&gt;
        &lt;input type="file" name="file"/&gt;&lt;br/&gt;
        &lt;input type="submit"/&gt;
    &lt;/form&gt;
</pre>

<pre class="sh_java">
// pakkaus

import java.io.IOException;
import org.springframework.stereotype.Controller;
import org.springframework.ui.Model;
import org.springframework.web.bind.annotation.RequestMapping;
import org.springframework.web.bind.annotation.RequestMethod;
import org.springframework.web.bind.annotation.RequestParam;
import org.springframework.web.multipart.MultipartFile;

@Controller
public class BinaryDataController {

    @RequestMapping(method = RequestMethod.GET, value = "data")
    public String view(Model model) {
        return "form";
    }

    @RequestMapping(method = RequestMethod.POST, value = "data")
    public String post(@RequestParam("name") String name,
            @RequestParam("description") String description,
            @RequestParam("file") MultipartFile file) throws IOException {

        System.out.println("Name: " + name);
        System.out.println("Description: " + description);
        System.out.println("File length: " + file.getBytes().length);

        return "redirect:data";
    }
}
</pre>


  <p>Sovellusta testatessamme törmäämme uudestaan ja uudestaan HTTP-statuskoodiin 400. Sovelluksen koodia läpikäydessä emme löydä konkreettista virhettä, ja lähdemme etsimään virheen aiheuttajaa muualta. GlassFishin versioon 3.1.2 on päässyt <a href="http://java.net/jira/browse/GLASSFISH-18444" target="_blank">bugi</a>, joka aiheuttaa ongelmia tiedostojen käsittelyssä. Ongelman voi onneksi kiertää vaihtamalla palvelimen vanhempaan versioon.</p>


  <p>Kun lähetämme lomakkeen, palvelimen logeissa näkyy lomakkeella lähetetyt arvot.</p>


  <p>Seuraava askel on tiedostoja tallentavan olion suunnittelu. Luodaan entiteetti <code>DataObject</code>, sekä palvelu <code>DataService</code>. Tallennetaan entiteettiin data oliomuuttujaan <code>content</code>, joka on byte-taulukko, ja jolla on <code>@Lob</code>-annotaatio. Tällä ilmoitamme kentän sisältävän binääridataa. Oliomuuttujaan liittyvään <code>@Column</code>-annotaatioon lisätään myös tallennettavan tiedon koko (<code>length</code>).  Koska tiedostoja ladattaessa palvelimen tulee pystyä kertomaan ladattavan tiedoston tyyppi ja, otamme tiedoston mediatyypin (<code>mimetype</code>) ja nimen talteen. Loput kentät lienevät tuttuja.</p>


<pre class="sh_java">
// pakkaus ja importit

@Entity(name = "DataObject")
@Table(name = "DataObject")
public class DataObject implements Serializable {

    @Id
    @GeneratedValue(strategy = GenerationType.AUTO)
    @Column(name = "id")
    private Long id;

    @Column(name = "name")
    private String name;

    @Column(name = "filename")
    private String filename;

    @Column(name = "description")
    private String description;

    @Lob
    @Column(name = "data", length = 1000000)
    private byte[] content;

    @Column(name = "mimetype")
    private String mimetype;


    // getterit ja setterit
</pre>


  <p>Luodaan seuraavaksi palvelurajapinta tiedostojen tallentamiselle. Rajapinta <code>DataStorageService</code> tarjoaa perus CRUD-toiminnallisuuden sekä listauksen. Huomaa, että rajapinta on itseasiassa hyvin tuttu. Huomattava osa web-sovelluksista perustuvat CRUD-toiminnallisuuteen.</p>


<pre class="sh_java">
public interface DataStorageService {
    DataObject create(DataObject object);
    DataObject read(Long identifier);
    DataObject update(Long identifier, DataObject object);
    void delete(Long identifier);

    List&lt;DataObject&gt; list();
}
</pre>


  <p>Käytämme tietokantaan tallennukseen Spring Data JPA:ta, joten tietokantatoiminnallisuutemme on käytännössä hyvin kevyt.</p>


<pre class="sh_java">
public interface DataStorageRepository extends JpaRepository&lt;DataObject, Long&gt; {
}
</pre>


  <p>Palvelukerrokselle toteutetaan transaktiot, sekä tiedostojen tallennus. Palvelun toteutus jätetään lukijalle. Lisätään vielä kontrolleriin toiminnallisuus, jossa data lähetetään palvelutasolle, sekä ylimääräinen view-metodi, jossa näytetään yksittäisen tiedoston tiedot.</p>


<pre class="sh_java">
// pakkaus

import java.io.IOException;
import org.springframework.stereotype.Controller;
import org.springframework.ui.Model;
import org.springframework.web.bind.annotation.PathVariable;
import org.springframework.web.bind.annotation.RequestMapping;
import org.springframework.web.bind.annotation.RequestMethod;
import org.springframework.web.bind.annotation.RequestParam;
import org.springframework.web.multipart.MultipartFile;
import org.springframework.web.servlet.mvc.support.RedirectAttributes;

@Controller
public class BinaryDataController {
    @Autowired
    private DataStorageService dataStorageService;
    
    @RequestMapping(method = RequestMethod.GET, value = "data/{objectId}")
    public String view(Model model, @PathVariable Long objectId) {
        model.addAttribute("dataObject", dataStorageService.read(objectId));
        return "view";
    }
    
    @RequestMapping(method = RequestMethod.GET, value = "data")
    public String view() {
        return "form";
    }

    @RequestMapping(method = RequestMethod.POST, value = "data")
    public String post(
            RedirectAttributes redirectAttributes,
            @RequestParam("name") String name,
            @RequestParam("description") String description,
            @RequestParam("file") MultipartFile file) throws IOException {

        // mahdollinen validointi, datan voi kytkeä myös olioon suoraan
        
        DataObject dataObject = new DataObject();
        dataObject.setName(name);
        dataObject.setDescription(description);
        dataObject.setMimetype(file.getContentType());
        dataObject.setContent(file.getBytes());
        dataObject.setFilename(file.getOriginalFilename());
        
        dataObject = dataStorageService.create(dataObject);
        
        redirectAttributes.addAttribute("objectId", dataObject.getId());
        return "redirect:data/{objectId}";
    }
}
</pre>

  <p>Toiminnallisuus datan lähettämiseen ja katsomiseen on nyt kunnossa. Toteutetaan vielä erillinen kontrolleri dataobjektien lataamiseen palvelimelta. Ensimmäinen versio, <code>DownloadController</code>-luokassa oleva metodi <code>download</code>, kuuntelee pyyntöjä osoitteeseen <code>download/{objectId}</code>. Pyynnön polussa tulevan tunnuksen perusteella tietokannasta haetaan haluttu olio. Oliosta haetaan siihen liittyvä data, ja lisätään se osaksi vastausta. Vastaukseen lisätään myös tiedot vastauksen sisällöstä (<code>content type</code>), pituudesta (<code>content length</code>), ja pakotetaan selain lataamaan tiedosto asettamalla otsake <code>Content-Disposition</code>. Tämän jälkeen data kopioidaan käyttäjälle vastaukseksi. </p>

<pre class="sh_java">
// pakkaus ja importit

@Controller
public class DownloadController {

    @Autowired
    private DataStorageService dataStorageService;

    @RequestMapping(method = RequestMethod.GET, value = "download/{objectId}")
    public void download(@PathVariable Long objectId, HttpServletResponse response) throws Exception {
        DataObject object = dataStorageService.read(objectId);
        if (object == null) {
            response.setStatus(HttpServletResponse.SC_NOT_FOUND);
            return;
        }

        byte[] content = object.getContent();
        
        response.setContentType(object.getMimetype());
        response.setContentLength(content.length);
        response.setHeader("Content-Disposition", "attachment; filename=" + object.getFilename());
        
        InputStream inputStream = new ByteArrayInputStream(content);
        OutputStream outputStream = response.getOutputStream();
        IOUtils.copy(inputStream, outputStream);
        response.flushBuffer();
    }

// ...
</pre>


  <p>Tyylikkäämpi tapa juuri toteutetun tiedoston lataamisen toteuttamiseen on <code><a href="http://static.springsource.org/spring/docs/current/javadoc-api/org/springframework/http/ResponseEntity.html" target="_blank">ResponseEntity</a></code>-luokan käyttäminen. <code>ResponseEntity</code>-luokan luominen on käytännössä eriyttänyt HTTP-vastauksen sisältämän datan erilliseksi single responsibility principle-periaatetta seuraavaksi luokaksi.</p>

<pre class="sh_java">
    // ...

    @RequestMapping(method = RequestMethod.GET, value = "download/{objectId}")
    @ResponseBody
    public ResponseEntity&lt;byte[]&gt; download(@PathVariable Long objectId) throws Exception {
        DataObject object = dataStorageService.read(objectId);
        if (object == null) {
            return new ResponseEntity&lt;byte[]&gt;(HttpStatus.NOT_FOUND);
        }

        byte[] content = object.getContent();
        
        // otsakkeiden luonti
        HttpHeaders headers = new HttpHeaders();
        headers.setContentType(MediaType.parseMediaType(object.getMimetype()));
        headers.setContentLength(content.length);
        headers.set("Content-Disposition", "attachment; filename=\"" + object.getFilename() + "\"");

        // datan palautus
        return new ResponseEntity&lt;byte[]&gt;(content, headers, HttpStatus.OK);
    }

    // ...
</pre>




<div class="tehtavat">
  <h3>Family Album</h3>

  <p>Pelkän tekstimuotoisen tiedon esittäminen ei aina riitä. Koska olemme jo tutustuneet hieman tiedostojen lähettämiseen ja lataamiseen, tehdään seuraavaksi verkkopalvelu, jonne voi koota kuvista oman albumin. Jokaiselle kuvalle voi tallettaa myös tekstikommentin.</p>

  <p>Tehtäväpohjan mukana tulee yksinkertainen käyttöliittymä, jonka avulla voi lähettää palveluun uusia kuvia sekä selata aiemmin lähetettyjä kuvia. Tehtäväpohjassa on myös valmis Spring-peruskonfiguraatio.</p>

  <p><strong>Huom!</strong> Tämä tehtävä on avoin tehtävä, eikä sen mukana tule ainuttakaan toteutukseen liittyvää luokkaa. Pääset siis koodaamaan ohjelman täysin itsenäisesti, ja ohjelman täytyy vain toteuttaa vaadittu HTTP-rajapinta.</p>

  <p>Projekti on konfiguroitu siten, että Spring Data JPA-luokkia haetaan oletuksena pakkauksesta <code>wad.familyalbum.repository</code>, lähdekooditiedostojen oletetaan olevan pakkauksessa <code>wad</code> tai sen alipakkauksissa.</p>

  <h4>Kuvatiedoston vastaanottaminen selaimelta ja lähettäminen selaimelle</h4>

  <p>Sovelluksen varastoimilla kuvilla (eli kuvan entiteetillä) tulee olla seuraavat attribuutit:
    <ul>
      <li><code>id</code> - numeerinen avain</li>
      <li><code>description</code> - käyttäjän antama tekstimuotoinen kuvaus</li>
      <li><code>contentType</code> - kuvatiedoston mediatyyppi</li>
      <li><code>fileName</code> - kuvatiedoston alkuperäinen nimi</li>
      <li><code>timestamp</code> - aikaleima, jolloin kuvatiedosto on talletettu</li>
      <li>Kuvan varsinainen binääridata, jonka attribuutin nimellä ei ole väliä</li>
    </ul>
  </p>

  <p>Tallenna kuvat tietokantaan. Huom! Joudut konfiguroimaan tiedostojen vastaanottamiseen käytettävän <code>multipartResolver</code>-beanin itse.</p>

  <p>Tehtäväpohjan mukana annetun käyttöliittymän tulee toimia osoitteessa <code>/app/album</code>. Tämän sivun avulla voit testata ohjelmaasi.</p>

  <p>Sovelluksen tulee toteuttaa seuraavat HTTP-pyynnöt:
    <ul>
      <li><code>GET /app/album</code> asettaa <code>Model</code>-instanssiin attribuutin <code>images</code>, joka sisältää listan kaikista kuvista, ja näyttää näkymän <code>album</code>.<br/><br/></li>
      <li><code>POST /app/images</code> vastaanottaa yksittäisen tiedoston ja sen tekstikuvauksen HTTP <code>multipart/form-data</code> muodossa. Tiedoston parametrin nimi on <code>file</code> ja kuvauksen <code>description</code>. Sovelluksen tulee tallettaa tiedoston kuvaus, mediatyyppi sekä alkuperäinen tiedostonimi. Tiedostolla tulee olla numeerinen avain ja uudelle tiedostolle annettu avain täytyy palauttaa HTTP-vasteen otsakkeessa <code>X-Image-Id</code>, jotta asiakasohjelmisto tietää mikä on uuden kuvan avain. Pyyntö tulee lopuksi uudelleenohjata osoitteeseen <code>/app/album</code>.<br/><br/></li>
      <li><code>GET /app/images/{imageId}/download</code> lähettää numeerisella avaimella <code>imageId</code> löytyvän tiedoston asiakasohjelmistolle. HTTP-vasteeseen tulee asettaa tiedoston mediatyyppi (<code>Content-Type</code>) sekä tiedoston koko tavuina (<code>Content-Length</code>), jotta asiakasohjelmisto, kuten selain, osaa tulkita tiedoston sisällön oikein.</li>
    </ul>
  </p>

  <p>Tässä vaiheessa kuvien lähettämisen ja selaamisen pitäisi onnistua mukana tulevan käyttöliittymän avulla. Download-linkit eivät vielä toimi, keskitymme niihin seuraavaksi.</p>

  <h4>Kuvatiedoston lähettäminen selaimelle liitetiedostona</h4>

  <p>Käyttöliittymässä listattavia kuvia voi tarkastella yksitellen klikkaamalla kuvaa. Tällä tavoin näytettävän kuvatiedoston tallentaminen selaimella tietokoneelle ei kuitenkaan ole suoraviivaista, vaan vaatii mm. tiedoston nimeämisen, sillä selain ei tiedä tiedoston nimeä.</p>

  <p>Selain voidaan "pakottaa" tallentamaan tiedosto palvelimen tarjoamalla nimellä asettamalla HTTP-vasteeseen otsake <code>Content-Disposition</code>. Otsaketiedossa tiedoston nimi tulee lainausmerkkien sisälle, eli lainausmerkit kuuluvat otsakkeeseen:</p>

<pre>
Content-Disposition: attachment; filename="image.jpg"
</pre>

  <p>Laajenna sovellusta siten seuraavalla HTTP-pyynnöllä:
    <ul>
      <li><code>GET /app/images/{imageId}/download/attachment</code> toimii muutoin samalla tavalla kuin edellisen kohdan tiedoston lähetys asiakasohjelmistolle, mutta HTTP-vasteeseen tulee asettaa otsake <code>Content-Disposition</code> edellämainittujen ohjeiden mukaisesti.</li>
    </ul>
  </p>

  <p>Nyt voit kokeilla ladata tiedostoja käyttöliittymän Download-linkkien avulla.</p>

  <h4>JSON-rajapinta kuvien tietojen lukemiseen</h4>

  <p>Jotta kuvien tekstimuotoisia kuvauksia ja muita tietoja voisi käyttää asiakasohjelmissa, täytyy sovelluksen tarjota pääsy näihin tietoihin esim. JSON-muotoisen tiedon avulla.</p>

  <p><strong>Huom!</strong> Spring (tai oikeastaan JSON-kirjasto <a href="http://jackson.codehaus.org/">Jackson</a>) muodostaa JSON-muotoisen HTTP-vasteen domain-olioista (tässä tapauksessa kuvan entiteetistä) sen getter-metodien perusteella, joten kuvan binääridata päätyy myös JSON-vasteeseen, koska binääridatallekin on luonnollisesti oltava getter-metodi. Emme kuitenkaan halua binääridataa JSON-vasteeseen, koska kuvan sisältö on tarkoitettu ladattavaksi erillisestä osoitteesta. Yksittäisen getterin sulkeminen pois JSON-vasteesta onnistuu getter-metodille asetettavan annotaation <code>org.codehaus.jackson.annotate.JsonIgnore</code> avulla.</p>

  <p><code>@JsonIgnore</code>-annotaatiota käytetään esimerkiksi näin:</p>

<pre class="sh_java">
@JsonIgnore
public byte[] getData() {
    return data;
}
</pre>

  <p>Laajenna vielä sovellusta siten, että se palauttaa JSON-muotoisia vastauksia seuraaville HTTP-pyynnöille:
    <ul>
      <li><code>GET /app/images/{imageId}</code> palauttaa yksittäisen kuvan JSON tiedot <strong>ilman</strong> kuvan varsinaista binääridataa</li>
      <li><code>GET /app/images</code> palauttaa JSON-listan, jossa on kaikkien talletettujen kuvien tiedot <strong>ilman</strong> binääridataa</li>
    </ul>
  </p>

  <p>Yksittäisen kuvan JSON-esitys tulisi näyttää esimerkiksi tältä (sisennykset ja rivinvaihdot on lisätty selkeyden vuoksi):</p>

<pre>
{
  "id": 42,
  "description": "Red sunset",
  "contentType": "image/png",
  "fileName": "red-sunset.png",
  "timestamp": 13728372938
}
</pre>

  <p>Lista kuvista puolestaan näyttää esimerkiksi tällaiselta:</p>

<pre>
[
  {
    "id": 7,
    "description": "Red sunset",
    "contentType": "image/png",
    "fileName": "red-sunset.png",
    "timestamp": 13728372938
  },
  {
    "id": 8,
    "description": "Blue moon",
    "contentType": "image/jpeg",
    "fileName": "bluemoon.jpg",
    "timestamp": 13728374643
  }
]
</pre>

</div>




<!--

SOA

  * palvelut voi myös olla samalla koneella. ollaan itseasiassa tehty tätä jo jonkin verran
    TEHT: peruswebasofta (pastebin) (MIKKE)

  * hitaiden kyselyiden nopeat vastaukset, prosessointi jätetään palvelimelle
    * async
    TEHT: joku prosessointi palvelimella (AV)

TEHT: AVOIN TEHTÄVÄ (MIKKE)

-->



<!-- 

VK5:

SOA jatkuu
  REST clientin teko
    TEHTÄVÄ: oma rest client, joka käyttää palvelua - injektoidaan osoite
-->

<h3>Olemassaolevien palveluiden käyttö</h3>

  <p>Huomattava osa sovelluskehityksestä sisältää integroitumista olemassaoleviin ohjelmistokomponentteihin. Olemassaolevat komponentit tarjoavat jonkinlaisen rajapinnan, jota sovelluskehittäjät voivat käyttää integroitumiseen. Integraatio ei ole aina helppoa: joissain tapauksissa komponenttiin tulee rakentaa erillinen integraatiorajapinta ennenkuin komponenttia voi käyttää.</p>

  <p>Monoliittiset "minä sisällän kaiken mahdollisen" -sovellukset ovat usein vaikeita ylläpitää, sillä uuden toiminnallisuuden lisääminen vaatii olemassaolevan sovelluksen muokkaamista. Sovellus voi olla kirjoitettu nykyään hyvin vähäisesssä käytössä olevalla kielellä (vrt. pankkijärjestelmät ja COBOL), ja sovellukset sisältävät harvoin muokkausta tukevia automaattisia testejä.</p>

  <p>Rakentamalla tarvittu sovellus alusta lähtien palveluorientoituneesti, eli siten, että se koostuu erillisistä palveluista, saadaan jatkokehitys ja ylläpito huomattavasti helpommaksi. Jokainen palvelu kapseloi oman yksittäisen toimintansa, jonka se tekee erittäin hyvin -- yksikään palvelu ei yritä tehdä kaikkea. Konkreettinen sovellus, joka tarjotaan asiakkaalle, toimii palveluita käyttävänä kapelimestarina, jonka tehtävänä on koordinoida palveluiden välistä toimintaa sopivasti.</p>

  <p>Esimerkiksi jos palvelu tarjoaa valmiin REST-rajapinnan, on siihen integroituminen helpohkoa. Käytännössä palvelua käyttävän sovelluksen omat palvelut ottavat yhteyden REST-rajapinnan tarjoamaan palveluun, ja hakee sieltä tarvittavaa tietoa.</p>

  <p>Periaatteessa REST-palveluita käyttävien sovellusten tekeminen ei poikkea millään tavalla verkkosovelluksia käsittelevien sovellusten tekemisestä. Yksinkertaisimmillaan GET-pyynnön voi toteuttaa Javalla <code><a href="http://docs.oracle.com/javase/6/docs/api/java/net/URL.html" target="_blank">URL</a></code>- ja <code><a href="http://docs.oracle.com/javase/6/docs/api/java/net/HttpURLConnection.html" target="_blank">HttpURLConnection</a></code>-luokkia käyttämällä seuraavasti.</p>

<pre class="sh_java">
    URL url = new URL("http://palvelun-osoite.net/resurssi");
    HttpURLConnection connection = (HttpURLConnection) url.openConnection();
    if (connection.getResponseCode() != 200) {
        System.out.println("Response code was not ok! :(");
        return;
    }

    Scanner sc = new Scanner(connection.getInputStream());
    while(sc.hasNextLine()) {
        System.out.println(sc.nextLine());
    }

    connection.disconnect();
</pre>


  <p>Jos vastaus sisältää JSON-muotoista dataa, on se osana vastauksen runkoa. Käytännössä Javan valmiita luokkia käytetään harvemmin verkkokyselyjen tekemiseen. Apache Software Foundation-projekti <a href="http://hc.apache.org/" target="_blank">HTTP Components</a> tarjoaa valmiin toiminnallisuuden esimerkiksi pyynnön palauttaman rungon hakemiseen. Esimerkiksi ylläolevan sovelluksen toiminnallisuuden saa toteutettua HttpComponentsin tarjoaman <a href="http://hc.apache.org/httpcomponents-client-ga/fluent-hc/apidocs/index.html" target="_blank">Fluent-APIn avulla</a> seuraavasti.</p>

<pre class="sh_java">
    Content content = Request.Get("http://palvelun-osoite.net/resurssi").execute().returnContent();

    System.out.println(content.asString());
</pre>

<div class="extra">
  <p><strong>Huom!</strong> Ohjelmien ja koodin vertailu rivimäärien perusteella on lähinnä naurettavaa. Tärkeämpää on ymmärrettävyys, ylläpidettävyys, sekä luonnollisesti jatkokehitysmahdollisuudet myös muiden sovelluskehittäjien toimesta.</p>
  <p>&nbsp;</p>
  <p>&nbsp;</p>
</div>
 
  <h4>JSON-dataa tarjoavan REST-palvelun käyttö</h4>

  <p>Aiemmin näkemäämme <a href="http://jackson.codehaus.org/" target="_blank">Jackson JSON</a>-kirjastoa voi käyttää tekstimuotoisen datan muuttamiseen olioiksi. Aiemmin näkemämme <code>ObjectMapper</code>-luokka tarjoaa olioiden JSON-dataksi muuntamisen lisäksi myös käännöksen toiseen suuntaan. Esimerkiksi jos käytössämme on aiemmin nähty <code>Beer</code>-luokka, on tekstimuotoisen datan muuttaminen olueksi helppoa.</p>

<pre class="sh_java">
public class Beer {
    private Long id;
    private String name;

    public Long getId() {
        return id;
    }

    public void setId(Long id) {
        this.id = id;
    }

    public String getName() {
        return name;
    }

    public void setName(String name) {
        this.name = name;
    }
}
</pre> 

<pre class="sh_java">
    String data = "{\"id\":1,\"name\":\"Buttface Amber Ale\"}";
    
    // Olio, joka muuttaa JSON-datan olioksi
    ObjectMapper mapper = new ObjectMapper();

    // luetaan olut merkkijonosta
    Beer beer = mapper.readValue(data, Beer.class);

    // valmista!
</pre>

          <p>Yhdistämällä kaksi edellistä esimerkkiä, voimme luoda oman REST-asiakasohjelmiston. Emme kuitenkaan halua tehdä sitä, sillä ylläoleva(kin) on toteutettu valmiiksi huomattavassa osassa sovelluskehyksiä. Esimerkiksi Spring tarjoaa oman <code><a href="http://static.springsource.org/spring/docs/current/javadoc-api/org/springframework/web/client/RestTemplate.html" target="_blank">RestTemplate</a></code>-luokan, jonka avulla REST-rajapinnan tarjoavien sovellusten käyttäminen on helpohkoa (<a href="http://static.springsource.org/spring/docs/current/spring-framework-reference/htmlsingle/spring-framework-reference.html#rest-resttemplate" target="_blank">dokumentaatio</a>).</p>

          <p>RestTemplate-oliolle tulee konfiguroida käytettävä viestikäsittelijä, joka määrittelee millaista dataa käsitellään (esim. JSON, XML). Konfiguraation voi tehdä ohjelmallisesti, tai RestTemplate-olion voi luoda osana sovelluksen käynnistystä. Alla on esimerkki, jossa ensin luodaan RestTemplate-olio, jolle asetetaan JSON-muotoista dataa käsittelevä <code>MappingJacksonHttpMessageConverter</code>-olio, jonka jälkeen tehdään kaksi pyyntöä. Ensimmäisessä pyynnössä haetaan yksittäinen tunnuksella <code>1</code> määritelty <code>Aircraft</code>-tyyppinen olio, toisessa haetaan lista <code>Aircraft</code>-olioita.</p>

<pre class="sh_java">
    String uri = "http://palvelu-ja-sen-osoite/aircrafts";
    RestTemplate restTemplate = new RestTemplate();
    List&lt;HttpMessageConverter&lt;?&gt;&gt; converters = new ArrayList&lt;HttpMessageConverter&lt;?&gt;&gt;();
    converters.add(new MappingJacksonHttpMessageConverter());

    restTemplate.setMessageConverters(converters);
    
    Aircraft aircraft = restTemplate.getForEntity(uri + "/1", Aircraft.class).getBody();
    List&lt;Aircraft&gt; aircrafts = restTemplate.getForObject(uri, List.class);
</pre>


 
<div class="tehtavat">
<NEXTWEEK></NEXTWEEK>

<h3>Beers Done Right</h3>

<p>Materiaalissa on aiemmin nähty oluiden tallentamiseen tarkoitettu palvelu. Tämän tehtävän mukana tulee JSON-muotoista olutdataa tuottava REST-palvelu. Sinun tulee luoda REST-asiakassovellus, joka keskustelee REST-palvelun kanssa. Palvelua varten on määritelty pakkauksessa <code>wad.beers.client</code> oleva rajapinta <code>BeerRestService</code>.</p>

<p>Luo pakkaukseen <code>wad.beers.client</code> luokka <code>BeerRestClient</code>, joka toteuttaa rajapinnan <code>BeerRestService</code>. Lisää luokalle annotaatio <code>@Service</code>, ja toteuta luokan metodit siten, että ne käyttävät JSON-muotoista dataa tuottavaa REST-palvelua. Pakkauksessa <code>wad.beers.client</code> oleva kontrolleriluokka <code>BeerController</code> asettaa luomallesi luokalle käytettävän REST-palvelun juuriosoitteen sovelluksen käynnistyessä.</p>

<p>Käytä luokan <code>BeerRestClient</code> toteutuksessa Springin tarjoamaa luokkaa <code>RestTemplate</code>. Luo RestTemplate-olio <code>BeerRestClient</code>-luokan konstruktorissa.</p>

<p>Huom! Tässä tehtävässä sinun tarvitsee koskea vain itse luomaasi luokkaan <code>BeerRestClient</code>.</p>

</div>


<h4>Palveluiden aggregointi</h4>


          <p>Palveluiden aggregointi, eli useamman palvelun datan yhdistäminen, on usein tarpeellista sovelluksia tehdessä. Pohditaan esimerkkiä, jossa tavoitteena on luoda sovellus, jossa henkilöitä asetetaan työhuoneisiin. Käytössämme on REST-api henkilöiden ja huoneiden käsittelyyn. Henkilöiden käsittelyyn tarkoitettu API on määritelty seuraavasti.</p>

          <p>
            <ul>
              <li>GET osoitteeseen <em>/persons</em> palauttaa kaikki henkilöt.</li>
              <li>GET osoitteeseen <em>/persons/{id}</em> palauttaa yksittäisen henkilön tiedot.</li>              <li>PUT osoitteeseen <em>/persons/{id}</em> muokkaa henkilön tietoja tietyllä tunnuksella. Jos tunnusta {id} ei löydy, vastauksena palautetaan virhe. Henkilön tiedot lähetetään pyynnön rungossa.</li>
              <li>DELETE osoitteeseen <em>/persons/{id}</em> poistaa henkilön tietyllä tunnuksella.</li>
              <li>POST osoitteeseen <em>/persons</em> luo uuden henkilön pyynnössä lähetettävän datan pohjalta. Palvelun vastuulla on päättää henkilölle tunnus.</li>
            </ul>
          </p>

          <p>Huoneiden käsittelyssä käytetty API on lähes samanlainen.</p>

          <p>
            <ul>
              <li>GET osoitteeseen <em>/rooms</em> palauttaa kaikki huoneet.</li>
              <li>GET osoitteeseen <em>/rooms/{id}</em> palauttaa yksittäisen huoneen tiedot.</li>
              <li>PUT osoitteeseen <em>/rooms/{id}</em> muokkaa huoneen tietoja tietyllä tunnuksella. Jos tunnusta {id} ei löydy, vastauksena palautetaan virhe. Huoneen tiedot lähetetään pyynnön rungossa.</li>
              <li>DELETE osoitteeseen <em>/rooms/{id}</em> poistaa huoneen tietyllä tunnuksella.</li>
              <li>POST osoitteeseen <em>/rooms</em> luo uuden huoneen pyynnössä lähetettävän datan pohjalta. Palvelun vastuulla on päättää huoneelle tunnus.</li>
            </ul>
          </p>

          <p>Entä kun haluamme tietää tietyssä huoneessa olevat henkilöt? Tai henkilölle asetettu huone?</p>


          <p><strong>Huoneessa olevat henkilöt</strong></p>


          <p>Yksi vaihtoehto huoneessa olevien henkilöiden listaamiseksi on muokata huonepalvelun apia siten, että se palauttaa myös huoneeseen liittyvät henkilöt. Tämä ei kuitenkaan ole kovin mielekästä, tai edes järkevää. Huoneista vastaavan palvelun tulee hoitaa vain huoneisiin liittyviä asioita, ei henkilöiden listaamista.</p>

          <p>Parempi vaihtoehto on määritellä huoneeseen liittyville henkilöille oma kyselyosoite, joka aggregoi huoneiden ja henkilöiden tiedot yhteen. Määritellään uusi REST-tyyppinen rajapinta huoneen kautta tapahtuvien henkilöiden käsittelyyn.</p>

          <p>
            <ul>
              <li>GET osoitteeseen <em>/rooms/{roomId}/persons</em> palauttaa kaikki henkilöt tietyssä huoneessa. (Yksittäisten henkilöiden tiedot saa haettua henkilöitä hallinnoivalta palvelulta)</li>
              <li>DELETE osoitteeseen <em>/rooms/{roomId}/persons/{personId}</em> poistaa huoneesta {roomId} henkilön, jonka tunnus on {personId}.</li>
              <li>POST osoitteeseen <em>/rooms/{roomId}/persons/{personId}</em> lisää huoneeseen {roomId} henkilön, jonka tunnus on {personId}.</li>
            </ul>
          </p>


          <p><strong>Henkilön huone</strong></p>

          <p>Kuten edellä, yksi vaihtoehto olisi muokata henkilöpalvelua siten, että se palauttaisi myös henkilön huoneen tiedot. Tämä ei kuitenkaan ole mielekästä, sillä henkilöitä käytetään todennäköisesti myös muuhunkin: huonetietojen listaus jokaisella kyselyllä on turhaa.</p>

          <p>Määritellään erillinen rajapinta henkilöiden huoneiden käsittelyyn.</p>

          <p>
            <ul>
              <li>GET osoitteeseen <em>/persons/{personId}/rooms</em> palauttaa kaikki henkilöön liittyvät huoneet. (Yksittäisten huoneiden tiedot saa haettua huoneita hallinnoivalta palvelulta)</li>
              <li>DELETE osoitteeseen <em>/persons/{personId}/rooms/{roomId}</em> poistaa henkilöltä {personId} huoneen, jonka tunnus on {roomId}.</li>
              <li>POST osoitteeseen <em>/persons/{personId}/rooms/{roomId}</em> lisää henkilölle {personId} huoneen, jonka tunnus on {roomId}.</li>
            </ul>
          </p>



          <p>Käytännössä palveluita yhdistelevien osoitteiden määrittelyyn ei ole sovittu yhtä oikeaa lähestymistapaa, vaan sovelluskehittäjän tulee itse suunnitella mahdollisimman kuvaavat osoitteet.</p>

          <p>Yllä olevissa aggregaattipalveluissa on tarkoituksella jätetty pois henkilöiden ja huoneiden muokkaaminen. Ongelman muodostaa jo usein se, että esimerkiksi huoneisiin liittyvien henkilöiden listaaja ei pakosti esitä henkilöistä samoja tietoja kuin henkilöpalvelu. Oikeastaan henkilöiden ja huoneiden muokkaaminen ei edes kuulu yllä määritellyt rajapinnat toteuttavan palvelun vastuulle.</p>

          <p><em>Suunnitellaan palvelut siten, että ne toteuttavat oman vastuualueensa hyvin, ja jättävät muut tehtävät muille.</em></p>
  

<!--

  sovellus, joka käyttää useampia palveluita
    TEHTÄVÄ: SOA 1. luodaan palvelu
    TEHTÄVÄ: SOA 2. luodaan toinen palvelu, käytetään tätä ja edellistä REST-clientillä - injektoidaan osoite
-->

<div class="tehtavat">
  <h3>High Five!</h3>

  <p>Tehtävät <em>High Five!</em> ja <em>Hot or Not</em> kuuluvat samaan tehtäväsarjaan, joissa toteutetaan palvelu pelitulosten ja -arvostelujen säilyttämiseen. Ensimmäinen osa <em>High Five!</em> keskittyy pelien ja tulosten tallentamiseen, mikä toteutetaan erillisenä palveluna.</p>

  <p>Pelitulospalvelu tarjoaa REST-rajapinnan pelien ja tuloksien käsittelyyn. Rajapinnan kaikki syötteet ja vasteet ovat JSON-muotoisia. Tehtäväpohjassa on toteutettu valmiiksi entiteetit <code>Game</code> ja <code>Score</code>, sekä tarvittavat palvelut niiden käsittelyyn ja tallettamiseen tietokantaan.</p>

  <p><strong>Huom!</strong> Tämä tehtävä on osittain avoin siten, että joudut tutkimaan tehtäväpohjassa annettua koodia, jotta voit hyödyntää sitä.</p>

  <h4>GameController</h4>

  <p>Pelejä käsitellään entiteetin <code>Game</code> avulla.</p>

  <p>Toteuta luokka <code>wad.highfive.controller.GameController</code>, joka tarjoaa REST-rajapinnan pelien käsittelyyn:
    <ul>
      <li><code>POST /app/games</code> luo uuden pelin sille annetulla <strong>nimellä</strong> ja palauttaa luodun pelin tiedot - ainoan vastaanotettavan attribuutin nimi on <code>name</code>. (Huom. vieläkin! Kaikki syötteet ja vastaukset ovat JSON-muotoisia)</li>
      <li><code>GET /app/games</code> listaa kaikki talletetut pelit</li>
      <li><code>GET /app/games/[name]</code> palauttaa yksittäisen pelin tiedot <strong>pelin nimen perusteella</strong></li>
      <li><code>DELETE /app/games/[name]</code> poistaa nimen mukaisen pelin</li>
    </ul>
  </p>

  <h4>ScoreController</h4>

  <p>Jokaiselle pelille voidaan tallettaa pelikohtaisia tuloksia entiteetin <code>Score</code> avulla, eli jokainen pistetulos kuuluu tietylle pelille. Tulokseen liittyy aina pistetulos <code>points</code> numerona, pelaajan nimimerkki <code>nickname</code> ja <strong>toteuttamasi palvelun itsensä tuottama aikaleima</strong> <code>timestamp</code>.</p>

  <p>Toteuta luokka <code>wad.highfive.controller.ScoreController</code>, joka tarjoaa REST-rajapinnan tuloksien käsittelyyn:
    <ul>
      <li><code>POST /app/games/[name]/scores</code> luo uuden tuloksen pelille <code>name</code> - vastaanotettavat attribuutit ovat <code>points</code> ja <code>nickname</code></li>
      <li><code>GET /app/games/[name]/scores</code> listaa talletetut tulokset pelille <code>name</code></li>
      <li><code>GET /app/games/[name]/scores/[id]</code> palauttaa yksittäisen tulokset tiedot pelin nimen <code>name</code> ja tuloksen avaimen <code>id</code> perusteella</li>
      <li><code>DELETE /app/games/[name]/scores/[id]</code> poistaa avaimen <code>id</code> mukaisen tuloksen</li>
    </ul>
  </p>

  <h3>Hot or Not</h3>

  <p>Palvelu <em>Hot or Not</em> lisää edellisen tehtävän pelitulospalveluun mahdollisuuden arvostella yksittäisiä pelejä antamalla niille numeroarvosanan 0-5.</p>

  <p><em>Hot or Not</em>-palvelun tulee käyttää <em>High Five!</em>-palvelun REST-rajapintaa, jonka avulla se tarjoaa samanlaisen rajapinnan pelien ja tulosten käsittelyyn. Ainoastaan pelien arvostelut käsitellään ja talletetaan tässä palvelussa! Arvosteluihin käytettävä entiteetti <code>Rating</code> ja siihen liittyvät palveluluokat on valmiina tehtäväpohjassa.</p>

  <p><strong>Huom!</strong> Edellisen tehtävän tavoin tämäkin tehtävä on osittain avoin siten, että joudut tutkimaan tehtäväpohjassa annettua koodia, jotta voit hyödyntää sitä. Joudut myös lukemaan tehtävän <em>High Five!</em> kuvausta tämän tehtävän toteutuksessa.</p>
 
  <p><strong>Huom!</strong> Valmis <em>High Five!</em>-palvelu löytyy osoitteesta <code>http://high-five.herokuapp.com/app/games</code>, joten voit tehdä tämän tehtävän täysin riippumatta edellisestä tehtävästä. Valmis palvelu on jokseenkin hidas, ja se ei ole aina päällä. Jos huomaat että testisi eivät mene läpi esimerkiksi timeoutin takia, suorita testit uudestaan. Vaihtoehtoisesti voit käyttää osoitetta <code>http://t-avihavai.users.cs.helsinki.fi/highfive/app/games</code>.</p>

  <h4>GameRestClient ja GameController</h4>

  <p>Tee luokka <code>wad.hotornot.service.GameRestClient</code>, joka toteuttaa rajapinnan <code>GameService</code>. Luokan tulee käyttää <em>High Five!</em>-palvelua kaikissa rajapinnan määrittelemissä toiminnoissa. REST-rajapinnan käyttö onnistuu Springin <code>RestTemplate</code>-luokan avulla vastaavalla tavalla kuin tehtävässä <em>Beers Done Right</em>.</p>

  <p><strong>Huom!</strong> <code>GameRestClient</code>-luokan <code>setUri</code>-metodi ottaa parametriksi yllä annetun URL-osoitteen valmiiseen <em>High Five!</em>-palveluun.</p>

  <p>Luo luokka <code>wad.hotornot.controller.GameController</code>, joka tarjoaa <strong>täsmälleen samanlaisen</strong> JSON/REST-rajapinnan kuin <em>High Five!</em>-palvelun <code>GameController</code>, mutta siten, että jokainen toiminto käyttää valmista <em>High Five!</em>-palvelua rajapinnan <code>GameService</code> kautta.</p>

  <p><strong>Huom!</strong> Muista asettaa <code>GameService</code>-rajapinnan kautta URL-osoite valmiiseen <em>High Five!</em>-palveluun ohjelman käynnistyessä, esimerkiksi controller-luokan <code>@PostConstruct</code>-metodissa.</p>

  <h4>ScoreRestClient ja ScoreController</h4>

  <p>Tee luokka <code>wad.hotornot.service.ScoreRestClient</code>, joka toteuttaa rajapinnan <code>ScoreService</code>. Luokan tulee käyttää <em>High Five!</em>-palvelua kaikissa rajapinnan määrittelemissä toiminnoissa. REST-rajapinnan käyttö onnistuu Springin <code>RestTemplate</code>-luokan avulla vastaavalla tavalla kuin tehtävässä <em>Beers Done Right</em>.</p>

  <p><strong>Huom!</strong> <code>ScoreRestClient</code>-luokan <code>setUri</code>-metodi ottaa parametriksi yllä annetun URL-osoitteen valmiiseen <em>High Five!</em>-palveluun.</p>

  <p>Luo luokka <code>wad.hotornot.controller.ScoreController</code>, joka tarjoaa <strong>täsmälleen samanlaisen</strong> JSON/REST-rajapinnan kuin <em>High Five!</em>-palvelun <code>ScoreController</code>, mutta siten, että jokainen toiminto käyttää valmista <em>High Five!</em>-palvelua rajapinnan <code>ScoreService</code> kautta.</p>

  <p><strong>Huom!</strong> Muista asettaa <code>ScoreService</code>-rajapinnan kautta URL-osoite valmiiseen <em>High Five!</em>-palveluun ohjelman käynnistyessä, esimerkiksi controller-luokan <code>@PostConstruct</code>-metodissa.</p>

  <h4>RatingController</h4>

  <p>Jokaiselle pelille voidaan tallettaa lisäksi pelikohtaisia arvosteluja entiteetin <code>Rating</code> avulla. Arvosteluun liittyy numeroarvosana <code>rating</code> (0-5) ja <strong>toteuttamasi palvelun itsensä tuottama aikaleima</strong> <code>timestamp</code>.</p>

  <p>Arvostelut liittyvät peleihin, jotka on talletettu eri palveluun, joten entiteetin <code>Rating</code> viittaus peliin täytyy tallettaa suoraan avaimena. Koska peleihin viitataan REST-rajapinnassa pelin nimellä, talletetaan jokaiseen <code>Rating</code>-entiteettiin pelin nimi attribuuttiin <code>gameName</code>. Tämän attribuutin avulla voidaan siis löytää arvosteluja pelin nimen perusteella.</p>

  <p>Toteuta luokka <code>wad.hotornot.controller.RatingController</code>, joka tarjoaa REST-rajapinnan arvostelujen käsittelyyn:
    <ul>
      <li><code>POST /app/games/[name]/ratings</code> luo uuden arvostelun pelille <code>name</code> - anoa vastaanotettava attribuutti on <code>rating</code></li>
      <li><code>GET /app/games/[name]/ratings</code> listaa talletetut arvostelut pelille <code>name</code></li>
      <li><code>GET /app/games/[name]/ratings/[id]</code> palauttaa yksittäisen arvostelun tiedot pelin nimen <code>name</code> ja avaimen <code>id</code> perusteella</li>
      <li><code>DELETE /app/games/[name]/ratings/[id]</code> poistaa avaimen <code>id</code> mukaisen arvostelun</li>
    </ul>
  </p>

</div>



<!--


<div class="extra">
  <p>Olemme käyttäneet esimerkeissä resurssien tunnuksena sekä numeerisia automaattisesti generoituvia tunnuksia, että satunnaisesti (esim UUID-luokan avulla) generoituja merkkijonotunnuksia. Merkkijonotunnusten ongelmana on kuitenkin niiden löydettävyys: Jos merkkijonotunnusta käyttää osana osoitetta, resurssien löytäminen ei ole helppoa. Käytännössä vain asiakassovellus, joka loi dataa tietäisi missä osoitteessa resurssi on.</p>
</div>

  palvelujen skaalautuvuus, prosessoinnin siirtäminen muille palvelimille
  viestijonot
    TEHTÄVÄ: viestijono, työt tallennettuna tietokantaan, tila myös tietokannassa, 
             kysely paikkaan x, case instagram
-->


<h3>Palveluiden skaalautuvuus</h3>


          <p>Käyttäjien määrän kasvaessa palveluiden tulee pystyä skaalautua mukana. Palveluiden ja sovellusten skaalautumiseen on käytännössä kaksi vaihtoehtoa: resurssien kasvattaminen (vertikaalinen skaalautuminen), sekä palvelinmäärän kasvattaminen (horisontaalinen skaalautuminen). Resurssien kasvattamiseen sisältyy lisämuistin hankinta, algoritmien optimointi ym, kun taas palvelinmäärän kasvattamisessa sovelluskehittäjän tulee luoda mahdollisuus pyyntöjen jakamiseen palvelinten välillä.</p>

          <p>Sovellukset eivät skaalaannu lineaarisesti, ja skaalautumiseen liittyy paljon muutakin kuin resurssien lisääminen. Jos yksiytimisellä prosessorilla varustettu palvelin pystyy käsittelemään sata pyyntöä sekunnissa, emme voi laskea, että kahdeksanytiminen prosessori pystyy käsittelemään kahdeksansataa pyyntöä sekunnissa. Skaalautuminen ei ole vain palvelun tehon lisäämistä. Aivan kuten raketin lisääminen autoon vauhdin lisäämiseksi ei pakosti tuota hyvää lopputulosta, yksittäinen tehokas komponentti sovelluksessa ei takaa sovelluksen tehokkuutta.</p>

          <p>Käytännössä skaalautumisesta puhuttaessa puhutaan horisontaalisesta skaalautumisesta, jossa käyttöön hankitaan lisää tietyntyyppisiä resursseja (esim. palvelimia). Vertikaalinen skaalautumisen harkinta on mahdollista tietyissä tapauksissa, esimerkiksi tietokantapalvelimen toimintaa suunniteltaessa, mutta yleisesti ottaen horisontaalinen skaalautuminen on kustannustehokkaampaa. (vrt. kahden miestyökuukauden käyttö algoritmin optimointiin, joka aiheuttaa algoritmin 10% tehoparannuksen, vs. ylimääräisen palvelimen hankkiminen, josta saa saman hyödyn.)</p> 


          <h4>Horisontaalinen skaalautuminen</h4>


          <p>Pyyntöjen määrän kasvaessa yksi ratkaisu on palvelinmäärän kasvattaminen. Tällöin pyyntöjen jakaminen palvelinten kesken hoidetaan erillisellä kuormantasaajalla (<em>load balancer</em>), joka ohjaa pyyntöjä palvelimille.</p>


          <p>Jos sovellukseen ei liity tilaa, kuormantasaaja voi ohjata pyyntöjä käytössä oleville palvelimille round-robin -tekniikalla. Jos sovellukseen liittyy tila, tulee tietyn asiakkaan tekemät pyynnöt ohjata aina samalle palvelimelle. Tämän voi toteuttaa esimerkiksi siten, että kuormantasaaja lisää pyyntöön evästeen, jonka avulla käyttäjä identifioidaan ja ohjataan oikealle palvelimelle. Tätä lähestymistapaa kutsutaan usein termillä (<em>sticky session</em>).</p>


          <p>Pelkkä palvelinmäärän kasvattaminen ja kuormantasaus ei kuitenkaan ole aina tarpeeksi. Kuormantasaus helpottaa verkon kuormaa, mutta ei ota kantaa palvelinten kuormaan. Jos yksittäinen palvelin käsittelee pitkään kestävää laskentaintensiivistä kyselyä, voi kuormantasaaja ohjata tälle palvelimelle lisää kyselyjä "koska eihän se ole vähään aikaan saanut mitään töitä".  Käytännössä tällöin kuormantasaaja lisää kuormaa entisestään paljon laskentaa tekevälle palvelimelle. On mahdollista käyttää kuormantasaajaa, joka pitää kirjaa palvelinten tilasta, mutta käytännössä palvelinten kuorma vaihtuu hyvin nopeasti, ja reagointi kuorman vaihtumiseen ei aina ole nopeaa.</p>

          <p>Parempi ratkaisu palvelinmäärän kasvattamiselle on palvelinmäärän kasvattaminen <em>ja</em> sovelluksen suunnittelu siten, että laskentaintensiiviset operaatiot käsitellään erillisillä palvelimilla. Käytännössä lähestymistavassa käytetään erillistä laskentaklusteria aikaa vievien laskentaoperaatioiden käsittelyyn, jolloin käyttäjän pyyntöjä kuuntelevan palvelimen kuorma pysyy alhaisena.</p>

          <p>Riippuen pyyntöjen määrästä, palvelinkonfiguraatio voidaan toteuttaa jopa siten, että staattiset tiedostot (esim. kuvat) löytyvät erillisiltä palvelimilta, GET-pyynnöt käsitellään asiakkaan pyyntöjä vastaanottavilla palvelimilla, ja datan muokkaamista tai prosessointia vaativat kyselyt (esim POST) ohjataan asiakkaan pyyntöjä vastaanottavien palvelinten toimesta laskentaklusterille.</p>


          <h4>Viestijonot</h4>


          <p>Kun palvelinohjelmistoja skaalataan siten, että osa laskennasta siirretään erillisille palvelimille, on oleellista että palveluiden välillä kulkevat viestit (pyynnöt ja vastaukset) säilyvät. Eniten käytetty lähestymistapa viestien säilymisen varmentamiseen on viestijonot (<em>messaging</em>, <em>message queues</em>), joiden tehtävänä on toimia viestien väliaikaisena säilytyspisteenä. Käytännössä viestijonot ovat erillisiä palveluita, joihin viestien tuottajat (<em>producer</em>) voivat lisätä viestejä, joita viestejä käyttävät palvelut kuluttavat (<em>consumer</em>).</p>


          <p>Viestijonoja käyttävät sovellukset kommunikoivat viestijonon välityksellä. Tuottaja lisää viestejä viestijonoon, josta käyttäjä niitä hakee. Kun viestin sisältämän datan käsittely on valmis, prosessoija lähettää viestin takaisin. Viestijonoissa on yleensä varmistustoiminnallisuus: jos viestille ei ole vastaanottajaa, jää viesti viestijonoon ja se tallennetaan esimerkiksi viestijonopalvelimen levykkeelle. Viestijonojen konkreettinen toiminnallisuus riippuu viestijonon toteuttajasta.</p>

          <p>Viestijonosovelluksia on useita, esimerkiksi <a href="http://activemq.apache.org/" target="_blank">ActiveMQ</a> ja <a href="http://www.rabbitmq.com/" target="_blank">RabbitMQ</a>. Viestijonoille on myös useita standardeja, joilla pyritään varmistamaan sovellusten yhteensopivuus. Esimerkiksi Javan melko pitkään käytössä ollut <a href="http://en.wikipedia.org/wiki/Java_Message_Service" target="_blank">JMS</a>-standardi määrittelee viestijonoille APIn, jonka viestijonosovelluksen tarjoajat voivat toteuttaa (vrt. JDBC). Nykyään myös <a href="http://www.amqp.org/" target="_blank">AMQP</a>-protokolla on kasvattanut suosiotaan.</p>

          <p>Aivan kuten esimerkiksi REST-tyylisen rajapinnan käyttö osana palveluorientoitunutta arkkitehtuuria, myös viestijonot mahdollistavat eri sovellusten helpon integroimisen. Viestejä tuottava sovellus voi olla toteutettu esimerkiksi COBOLilla, kun taas viestejä vastaanottava sovellus voidaan toteuttaa esimerkiksi Perlillä.</p>

          <p><strong>JMS ja ActiveMQ</strong></p>

          <p>Tutustutaan seuraavaksi hieman tarkemmin JMS-rajapintaan ja sen käyttöön. Käytetään JMS-rajapinnan toteutuksena ActiveMQ-toteutusta. ActiveMQ:n käyttöön tarvittavat kirjastot saa käyttöön lisäämällä projektiin liittyvään <code>pom.xml</code>-tiedostoon seuraavan riippuvuuden.</p>

<pre class="sh_xml">
        &lt;dependency&gt;
            &lt;groupId&gt;org.apache.activemq&lt;/groupId&gt;
            &lt;artifactId&gt;activemq-core&lt;/artifactId&gt;
            &lt;version&gt;5.5.1&lt;/version&gt;
        &lt;/dependency&gt;
</pre>


          <p>ActiveMQ-palvelimen saa lataamalla sen ActiveMQ:n kotisivuilta <a href="http://activemq.apache.org" target="_blank">http://activemq.apache.org</a>. Yleinen *nix-versio käy hyvin. Kun ActiveMQ on ladattu, se puretaan sopivaan kansioon. ActiveMQ käynnistyy sen alikansiossa <code>bin</code> olevan <code>activemq</code>-tiedoston avulla seuraavasti:</p>

<pre>
apache-activemq $ ./bin/activemq start
</pre>

          <p>Komento <code>start</code> käytännössä tämä käynnistää viestijonopalvelimen oletuksena paikallisen koneen porttiin <code>61616</code> (osoite "tcp://localhost:61616"). Viestijonopalvelin on erillinen sovellus, joka sisältää joukon viestijonoja. Jokaiseen viestijonoon voi sekä asettaa viestejä, että niistä voi hakea viestejä. Luodaan seuraavaksi sovellus viestien lisäämiseksi viestijonoon. Lisätään viestijonoon nimeltä <code>"messages"</code> <code>TextMessage</code>-tyyppisiä olioita, jotka sisältävät tekstiä.</p>

<pre class="sh_java">
        // avataan yhteys
        ConnectionFactory connectionFactory = new ActiveMQConnectionFactory("tcp://localhost:61616");
        Connection connection = connectionFactory.createConnection();
        connection.start();

        // luodaan sessio viestien lähettämiseen, ei käytetä transaktioita
        Session session = connection.createSession(false, Session.AUTO_ACKNOWLEDGE);

        // haetaan viestijono nimeltä "messages"
        Destination destination = session.createQueue("messages");
        
        // luodaan messageproducer-olio, jota käytetään viestien lähetykseen
        MessageProducer producer = session.createProducer(destination);

        // luodaan lähetettävä viesti, viesti sisältää merkkijonon "Hello World!"
        TextMessage message = session.createTextMessage("Hello World!");

        // lähetetään viesti
        producer.send(message);

        // suljetaan yhteys
        connection.close();
</pre>

          <p>Luodaan seuraavaksi sovellus, joka vastaanottaa viestejä.</p>

<pre class="sh_java">
        // avataan yhteys
        ConnectionFactory connectionFactory = new ActiveMQConnectionFactory("tcp://localhost:61616");
        Connection connection = connectionFactory.createConnection();
        connection.start();

        // luodaan sessio viestien vastaanottamiseen, ei käytetä transaktioita
        Session session = connection.createSession(false, Session.AUTO_ACKNOWLEDGE);

        // haetaan viestijono nimeltä "messages"
        Destination destination = session.createQueue("messages");

        // luodaan messageconsumer-olio, jota käytetään viestien lukemiseen
        MessageConsumer consumer = session.createConsumer(destination);
        
        // haetaan viesti jonosta -- jos viestiä ei ole, jäädään odottamaan
        // kaikille viestityypeille on yhteinen <code>Message</code>-rajapinta, joka 
        // tulee muuttaa halutuksi tyypiksi
        Message message = consumer.receive();

        // tulostetaan viestin sisältö
        TextMessage textMessage = (TextMessage) message;
        System.out.println(textMessage.getText());

        // suljetaan yhteys
        connection.close();
</pre>

<pre>
Hello World!
</pre>

          <p>Viestinjonon saa sammutettua komennolla <code>stop</code>.</p>

<pre>
apache-activemq $ ./bin/activemq stop
</pre>

          <p>Käytännössä viestien lähettäjän ja vastaanottajan vastuulla on yhteyden luominen, viestijonon valinta, viestin luominen tai hakeminen ja yhteyden sulkeminen. Huomattava osa koodista on kuitenkin toisteista, ja viestien prosessoinnin helpottamiseksi on kehitetty muutamia apuvälineitä. Esimerkiksi Spring tarjoaa oman JMS-tukikirjaston. Saamme sen käyttöön lisäämällä projektimme <code>pom.xml</code>-tiedostoon seuraavan riippuvuuden.</p>

<pre class="sh_xml">
        &lt;dependency&gt;
            &lt;groupId&gt;org.springframework&lt;/groupId&gt;
            &lt;artifactId&gt;spring-jms&lt;/artifactId&gt;
            &lt;version&gt;3.1.2.RELEASE&lt;/version&gt;
        &lt;/dependency&gt;
</pre>


          <p>Spring JMS tarjoaa käyttöömme muunmuassa <a href="http://static.springsource.org/spring/docs/current/javadoc-api/org/springframework/jms/core/JmsTemplate.html" target="_blank">JmsTemplate</a> luokan. JmsTemplate tarjoaa apuvälineitä JMS-pyyntöjen tekemiseen. JmsTemplate hoitaa muunmuassa yhteyden avaamisen ja sulkemisen, ja sen voi konfiguroida osana sovelluksen konfiguraatiota. Automaattisesti injektoitavan <code>JmsTemplate</code>-beanin voi luoda sovellukseen määrittelemällä beanin osana <code>front-controller-servlet.xml</code>-konfiguraatiota.</p>

<pre class="sh_xml">
    &lt;!-- ... --&gt;

    &lt;!-- viestijono "messages" --&gt;
    &lt;bean id="destination" class="org.activemq.message.ActiveMQQueue"&gt;
        &lt;constructor-arg value="messages" /&gt;
    &lt;/bean&gt;

    &lt;!-- yhteyden luomiseen tarvittu tehdas --&gt;
    &lt;bean id="connectionFactory" class="org.activemq.ActiveMQConnectionFactory"&gt;
        &lt;property name="brokerURL" value="tcp://localhost:61616" /&gt;
    &lt;/bean&gt;

    &lt;!-- JmsTemplate, joka käyttää viestijonoa ja aiemmin määriteltyä yhteystehdasta --&gt;
    &lt;bean id="jmsTemplate" class="org.springframework.jms.core.JmsTemplate"&gt;
        &lt;property name="connectionFactory" ref="connectionFactory" /&gt;
        &lt;property name="defaultDestination" ref="messages" /&gt;
    &lt;/bean&gt;
    
    &lt;!-- ... --&gt;
</pre>

          <p>Nyt aiemmin esitetyn viestin lähetyksen voi hoitaa helpommin. Oletetaan että käytössämme on rajapinta <code>MessageSender</code>:</p>

<pre class="sh_java">
public interface MessageSender {
    void enqueue(final String message);
}
</pre>

          <p>Rajapinnan toteuttaa luokka JmsMessageSender:</p>

<pre class="sh_java">
@Service
public class JmsMessageSender implements MessageSender {
    @Autowired
    private JmsTemplate jmsTemplate;

    @Override
    @Async
    public void enqueue(final String message) {
        jmsTemplate.send(new MessageCreator() {
            @Override
            public Message createMessage(Session session) throws JMSException {
                return session.createTextMessage(message);
            }
        });
    }
}
</pre>

          <p>Vastaavasti aiemmin esitetyn viestin vastaanottamisen voi toteuttaa myös hieman helpommin. Oletetaan että käytössämme on rajapinta <code>MessageReceiver</code>:</p>

<pre class="sh_java">
public interface MessageReceiver {
    String dequeue();
}
</pre>

          <p>Rajapinnan toteuttaa luokka JmsMessageReceiver:</p>

<pre class="sh_java">
@Service
public class JmsMessageReceiver implements MessageReceiver {
    @Autowired
    private JmsTemplate jmsTemplate;

    @Override
    public String dequeue() {
        TextMessage textMessage = (TextMessage) jmsTemplate.receive();
        return textMessage.getText();
    }
}
</pre>


          <p>Kummankin ylläolevista luokista voi injektoida automaattisesti palveluksi esimerkiksi kontrolleriluokkaan. Oikeastaan fiksumpi tapa viestin vastaanottamiseen olisi toteuttaa <code>MessageListener</code>-rajapinta, jolloin Spring kutsuu vastaanottajan metodia aina tarvittaessa. Luodaan toinen versio luokasta <code>JmsMessageReceiver</code>: </p>

<pre class="sh_java">
@Component
public class JmsMessageReceiver implements MessageListener {

    // ...

    @Override
    public void onMessage(Message message) {
        TextMessage textMessage = (TextMessage) message;

        // tee jotain vastaanotetulla viestillä, esimerkiksi
        // lähetys erilliseen (injektoituun) palveluun tai tietokantaan
    }
}
</pre>

          <p>MessageListener-toteutukset tulee konfiguroida Springiin. Jotta ylläoleva luokka toimisi, tulee <code>front-controller-servlet.xml</code>-tiedostoon erillinen varasto viestien kuuntelijoille.</p>

<pre class="sh_xml">
    &lt;bean class="org.springframework.jms.listener.DefaultMessageListenerContainer"&gt;
        &lt;property name="connectionFactory" ref="connectionFactory" /&gt;
        &lt;property name="destination" ref="destination" /&gt;
        &lt;property name="messageListener" ref="jmsMessageReceiver"/&gt;
    &lt;/bean&gt;
</pre>



<div class="tehtavat">

  <h3>InstantGram</h3>

  <p>InstantGram on viime viikolla tehtyä perhealbumia soveltava sovellus. Sovelluksessa käyttäjä voi lisätä palveluun kuvan, joka filtteröidään hieman erinäköiseksi. Koska Kumpulan SIIT-siiven kuvankäsittelytaidot ovat heikot, käytössä on vain Sepia-filtteri.</p>

  <p>Kuvien prosessointi web-sovelluksen sisältämällä palvelimella ei ole mielekästä, joten <em>simuloidaan</em> tässä tehtävässä kuvien siirtämistä erilliselle koneelle prosessointia varten. Sovelluksessa tulee mukana <code>ActiveMQ</code>-viestijono, jossa olevaan jonoon kuvat lisätään prosessointia varten. Kun prosessointi on valmis, palautetaan kuvat takaisin toista tallennusta varten.</p>

  <p>Huom! Tässä tehtävässä viestijonon käyttöä simuloidaan, oikeasti viestijono tulee asentaa erilliselle koneelle, tai ainakin palvelinsovelluksesta erilliseen sovellukseen. Pakkauksessa <code>wad.instantgram.backend</code> olevat lähdekooditiedostot sijaitsisivat oikeasti erillisellä palvelimella, samoin viestijonototeutus. Viestijono käyttää paikallisen koneen porttia <code>46420</code>. <em>Sovelluksen viestijonon käynnistystoteutuksesta ei kannata juurikaan ottaa mallia.</em></p>

  <p>Tässä tehtävässä tutustut hieman viestijonon käyttämiseen.</p>

  <h4>Viestin lähetys</h4>

  <p>Toteuta pakkauksessa <code>wad.instantgram.frontend.queue</code> olevaan luokkaan <code>ActiveMQImageSender</code> viestin lähetys. Viesti tulee lähettää osoitteessa <code>tcp://localhost:46420</code> olevan viestijonopalvelimen jonoon <code>ImagesToProcessingQueue</code>. Käytä viestityyppiä <code>javax.jms.ObjectMessage</code>, jonka olioksi asetat lähetettävän kuvan.</p>

  <p>Käytä apuna luokan <code>ActiveMQImageSender</code> perimän luokan <code>AbstractMessageQueueService</code> tarjoamia toiminnallisuuksia: Metodilla <code>getJmsTemplate()</code> pääset käsiksi JmsTemplate-olioon. Kun käytät sen send-metodia, käytä versiota jolle annetaan käytettävän viestijonon nimi merkkijonona.</p>

  <p>Lisää myös viestin lähetys luokkaan <code>ImageController</code>. Viesti tulee asettaa viestijonoon sen jälkeen kun se on lisätty <code>imageService</code>-oliolle. Käytä kontrollerissa <code>ImageSender</code>-rajapintaa, jonka luokka <code>ActiveMQImageSender</code> toteuttaa.</p>

  <p>Kun olet valmis, voit testata viestin lähetyksen toimimista sovelluksella. Näet palvelimen logeista viestin kun backend-palvelin vastaanottaa kuvan.</p>


  <h4>Viestin vastaanotto</h4>

  <p>Toteuta pakkauksessa <code>wad.instantgram.frontend.queue</code> olevaan luokkaan <code>ActiveMQProcessedImageReceiver</code> viestin vastaanotto. Viesti tulee vastaanottaa osoitteessa <code>tcp://localhost:46420</code> olevan viestijonopalvelimen jonosta <code>ProcessedImageQueue</code>. Vastaanotettavat viestit ovat tyyppiä <code>javax.jms.ObjectMessage</code>, jonka olioksi vastaanotettava kuva on asetettu.</p>

  <p>Käytä apuna luokan <code>ActiveMQProcessedImageReceiver</code> perimän luokan <code>AbstractMessageQueueService</code> tarjoamia toiminnallisuuksia: Metodilla <code>getJmsTemplate()</code> pääset käsiksi JmsTemplate-olioon. Kun käytät sen receive-metodia, käytä versiota jolle annetaan käytettävän viestijonon nimi merkkijonona.</p>

  <p>Kun olet valmis, voit testata sovelluksen toimintaa. Alussa testata viestin lähetyksen toimimista sovelluksella. Näet palvelimen logeista viestin kun backend-palvelin vastaanottaa kuvan.</p>
</div>




<div class="extra">

  <p>&nbsp;</p>

  <p><em>Viestijonojen käyttö monimutkaistaa yksinkertaista sovellusta ja yksinkertaistaa monimutkaista sovellusta.</em> -- mikke</p>

  <p>&nbsp;</p>
</div>

<!--

YLEISTÄ SOVELLUSKEHITYKSESTÄ

  devauskone, integraatiopalvelin, tuotantopalvelin

  profiilit 
    TEHTÄVÄ: erillisen devaus- ja tuotantoprofiilin konffaus 
             (testaus: hae profiilin datasource, ja katso osoite)
-->

<h2>Yleistä sovelluskehityksestä</h2>


          <p>Web-sovelluskehityksessä nopeasta kehityssyklistä on huomattavasti hyötyä. Työkaluja valittaessa tarkoituksena on välttää nurkkaan ajautumista: työkaluista tulee pystyä myös pääsemään eroon. On paljon hyödyllisempää miettiä asiaa päivä ja käyttää muutama päivä prototyypin tekemiseen, koska prototyyppiä voidaan parantaa kuukausia, kuin miettiä kuukausi ja sitouttaa itsensä kuukauden aikana luotuun suunnitelmaan. Mitä nopeammin toiminnallisuutta on olemassa, sitä nopeammin siitä saa palautetta.  Mitä vähemmän käytämme aikaa yksittäisen toiminnallisuuden toteuttamiseen -- <a href="http://en.wikipedia.org/wiki/KISS_principle" target="_blank">KISS</a> -- sitä helpommin siitä voi tarpeen vaatiessa hankkiutua eroon.</p>

          <p>Vaikka olemme nähneet tähän mennessä paljon esimerkkejä mm. SOA-arkkitehtuurista, voi ohjelmiston prototyyppin tehdä ensin "yksinkertaiseksi" kerrosarkkitehtuuria noudattavaksi sovellukseksi. Kun prototyypin toiminta on varmistettu, voidaan sovellusta lähteä kehittämään paremmaksi -- skaalautumisen tarve selvenee projektin myötä. Prototyypin kehitys ei missään nimessä tarkoita hyvien ohjelmointikäytänteiden tai järkevän arkkitehtuurin unohtamista. Päinvastoin, prototyypit päätyvät usein tuotantokäyttöön ja jatkokehitykseen. Järkevä arkkitehtuuri ja rajapintojen käyttö mahdollistaa sovelluksen pilkkomisen erillisiin SOA-arkkitehtuuria mukaileviin palveluihin ilman että sovelluksen ulkopuolinen toiminta muuttuu. Rajapintojen alla olevat toteutukset toki muuttuvat.</p>

          <p>Jotta sovelluskehitys olisi nopeaa, tulee ohjelmistokehitystiimillä olla käytössä yhteiset työkalut ja käytänteet. Olemme kurssin alusta käyttäneet Mavenia, joka helpottaa sovelluksen riippuvuuksien hallintaa. Tutustutaan tässä muutamaan hyödylliseen käytänteeseen.</p>


          <h3>Kehitys, Integraatio, QA, Tuotanto</h3>


          <p>Perinteisesti sovelluksia kehitettäessä sovellusta suoritetaan neljässä eri paikassa. (1) Jokaisella ohjelmistokehittäjällä on oma "hiekkalaatikko", jossa koodiin voi tehdä muutoksia vaikuttamatta muiden tekemään työhön. Jokaisella ohjelmistokehittäjällä on yleensä samat tai samankaltaiset työkalut (ohjelmointiympäristö, ...), mikä helpottaa muiden kehittäjien auttamista. Aina kun sovelluskehittäjä on saanut tehtävän valmiiksi, tehtävään liittyvä koodi ja muutokset lähetetään integraatiopalvelimelle esim. git-versionhallintaa käyttäen. (2) Integraatiopalvelimen tehtävänä on yhdistää ohjelmistokehitystiimin lähdekoodit ja suorittaa niihin liittyvät testit jokaisen muutoksen yhteydessä. Integraatiopalvelin kuuntelee käytännössä versionhallintajärjestelmässä tapahtuvia muutoksia, ja hakee uusimman lähdekoodiversion muutoksen yhteydessä. Integraatiopalvelimella on käytössä osajoukko tuotantopalvelimen käyttämästä datasta validointitarkoituksiin.</p>

          <p>(3) QA-ympäristö (Staging-palvelin) on lähes identtinen ympäristö tuotantoympäristöön verrattuna. QA-ympäristöön kopioidaan ajoittain tuotantoympäristön data, ja se toimii viimeisenä testaus- ja validointipaikkana (Quality assurance) ennen tuotantoon siirtoa. QA-ympäristöä käytetään myös demo- ja harjoitteluympäristönä. Kun QA-ympäristössä oleva sovellus on päätetty toimivaksi, siirretään sovellus tuotantoympäristöön. (4) Tuotantoympäristö voi olla yksittäinen palvelin, tai se saattaa olla joukko palvelimia, joihin uusin muutos propagoidaan hiljalleen. Tuotantoympäristön tulee olla erillinen ympäristö muista ympäristöistä.</p>


<!--
  continuous integration
    turpaan tulee jos testit ei mene läpi
    jenkins
-->

<h4>Integraatiopalvelin ja Continuous Integration</h4>


          <p>Jatkuvassa integroinnissa (<em><a href="http://www.extremeprogramming.org/rules/integrateoften.html" target="_blank">Continuous integration</a></em>) jokainen ohjelmistoprojektin jäsen lisää päivittäiset muutoksensa olemassaolevaan kokonaisuuteen. Tämä vähentää virheiden löytämiseen ja korjaamiseen kuluvaa aikaa, koska virheet löytyvät jo varhaisessa vaiheessa. Kun virheet löytyvät aikaisin ovat muutokset vielä kehittäjillä mielessä, ja syiden etsiminen vie huomattavasti vähemmän aikaa kuin integraatioita harvemmin tehtäessä.</p>
          
          <p>Jatkuvaa integrointia seuraten ohjelmistokehittäjä hakee kehityksen alla olevan version versionhallinnasta aloittaessaan työn. Hän toteuttaa uuden pienen ominaisuuden testeineen, testaten uutta toiminnallisuutta jatkuvasti. Kun ohjelmistokehittäjä on saanut muutoksen tehtyä, ja kaikki testit menevät läpi hänen paikallisella työasemalla, hän lähettää muutokset versionhallintaan. Kun versionhallintaan tulee muutos, jatkuvaa integrointia suorittava työkalu hakee uusimman version ja suorittaa sille sekä yksikkö- että integraatiotestit.</p>
          
          <p>Testejä sekä paikallisella kehityskoneella että erillisellä integraatiokoneella ajettaessa ohjelmistotiimi mahdollisesti huomaa virheet, jotka ovat piilossa kehittäjän paikallisen konfiguraation johdosta. Kehittäjä ei aina ota koko ohjelmistoa omalle koneelleen -- ohjelmisto voi koostua useista komponenteista --  jolloin kaikkien vaikutusten testaaminen paikallisesti on mahdotonta. Jos käännös ei mene läpi integraatiokoneella, kehittäjän tulee tehdä korjaukset mahdollisimman nopeasti.</p>

          <p>Työkaluja automaattiseen kääntämiseen ja jatkuvaan integrointiin ovat muunmuassa <a href="http://jenkins-ci.org/" target="_blank">Jenkins</a>, <a href="http://continuum.apache.org/" target="_blank">Apache Continuum</a> ja <a href="http://cruisecontrol.sourceforge.net/" target="_blank">CruiseControl</a>. TKTL:llä on opiskelijoiden käyttöön suunnattu Jenkins-asennus osoitteessa <a href="http://jenkins.staff.cs.helsinki.fi/" target="_blank">http://jenkins.staff.cs.helsinki.fi/</a>.</p>


          <h3>Konfiguraatioprofiilit</h3>


          <p>Jos sovellusta ei ole rakennettu kunnolla, on sen siirtäminen eri ympäristöjen välillä tuskaa. Hyvin rakennetussa sovelluksessa ympäristön vaihtaminen ei aiheuta muutoksia sovelluksen lähdekoodiin. Käytännössä sovellusten hallinta tapahtuu profiilien avulla. Spring tarjoaa profiileille oman konfiguraatiotyylin. Luodaan seuraavaksi sovellus, jossa on erillinen tuotanto- ja kehitysympäristö. Kehitysympäristössä käytössä on muistiin ladattava H2-tietokanta, tuotantoympäristössä PostgreSQL-tietokantaa (oletetaan että pom.xml:ssä) on molempien tarvitsemat riippuvuudet.</p>

          <p>Luodaan ensin <code>persistence.xml</code>-tiedostoon kaksi erillistä <code>persistence-unit</code>-konfiguraatiota. Toinen on tuotannolle, toinen kehitysympäristölle. Oleellisin ero konfiguraatioissa on se, että tuotantoympäristössä tietokantatauluja <em>ei</em> tuhota aina sovelluksen käynnistyessä.</p>

<pre class="sh_xml">
&lt;?xml version="1.0" encoding="UTF-8"?&gt;
&lt;persistence version="2.0" xmlns="http://java.sun.com/xml/ns/persistence" 
                              xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" 
                              xsi:schemaLocation="http://java.sun.com/xml/ns/persistence
                                 http://java.sun.com/xml/ns/persistence/persistence_2_0.xsd"&gt;
    &lt;persistence-unit name="persistenceUnitDev" transaction-type="RESOURCE_LOCAL"&gt;
        &lt;properties&gt;
            &lt;property name="showSql" value="true"/&gt;
            &lt;property name="eclipselink.ddl-generation" value="drop-and-create-tables"/&gt;
            &lt;property name="eclipselink.ddl-generation.output-mode" value="database"/&gt;
            &lt;property name="eclipselink.weaving" value="false"/&gt;
            &lt;property name="eclipselink.logging.level" value="FINE"/&gt;
        &lt;/properties&gt;
    &lt;/persistence-unit&gt;
    
    &lt;persistence-unit name="persistenceUnitProduction" transaction-type="RESOURCE_LOCAL"&gt;
        &lt;properties&gt;
            &lt;property name="eclipselink.ddl-generation" value="create-tables"/&gt;
            &lt;property name="eclipselink.ddl-generation.output-mode" value="database"/&gt;
            &lt;property name="eclipselink.weaving" value="false"/&gt;
            &lt;property name="eclipselink.logging.level" value="SEVERE"/&gt;
        &lt;/properties&gt;
    &lt;/persistence-unit&gt;
&lt;/persistence&gt;
</pre>

          <p>Muokataan tämän jälkeen sovelluksen tietokantakonfiguraatiota. Konfiguraatioon määritellään profiilit "production" ja "dev,default", jotka sisältävät profiiliin liittyvän konfiguraation. Profiili "dev,default" sisältää käytännössä kaksi profiilia: profiili "dev" ja oletusprofiili "default". Profiilissa "production" asetetaan muuttujan <code>persistenceUnitName</code> arvoksi <code>persistenceUnitProduction</code>, luetaan konfiguraatiotiedosto <code>production.properties</code>, ja luodaan konfiguraatiotiedostosta luettujen parametrien pohjalta <code>DataSource</code>-olio. Profiilissa "dev,default" asetetaan muuttujan <code>persistenceUnitName</code> arvoksi <code>persistenceUnitDev</code>, luetaan konfiguraatiotiedosto <code>development.properties</code>, ja luodaan muistiin ladattava tietokanta.</p>

<pre class="sh_xml">
    &lt;!-- ... --&gt;
    &lt;bean id="entityManagerFactory" class="org.springframework.orm.jpa.LocalContainerEntityManagerFactoryBean"&gt;
        &lt;property name="persistenceUnitName" value="${persistence.unit}" /&gt; 
        &lt;property name="dataSource" ref="dataSource" /&gt;
        &lt;property name="jpaVendorAdapter"&gt;
            &lt;bean class="org.springframework.orm.jpa.vendor.EclipseLinkJpaVendorAdapter"/&gt;
        &lt;/property&gt;
    &lt;/bean&gt;

    &lt;!-- ... --&gt;

    &lt;!-- tuotantoympäristön konfiguraatio --&gt;
    &lt;beans profile="production"&gt;
        &lt;!-- ympäristöön liittyvä konfiguraatiotiedosto --&gt;
        &lt;context:property-placeholder location="classpath:production.properties"/&gt;

        &lt;!-- luodaan tietokantakonfiguraatio luetun konfiguraatiotiedoston perusteella --&gt;
        &lt;bean id="dataSource" class="org.springframework.jdbc.datasource.DriverManagerDataSource"&gt;
            &lt;property name="driverClassName" value="org.postgresql.Driver"/&gt;
            &lt;property name="url" value="${database.url}"/&gt;
            &lt;property name="username" value="${database.username}"/&gt;
            &lt;property name="password" value="${database.password}"/&gt;
        &lt;/bean&gt;
    &lt;/beans&gt;
    
    &lt;!-- oletuskonfiguraatio --&gt;
    &lt;beans profile="dev,default"&gt;
        &lt;!-- ympäristöön liittyvä konfiguraatiotiedosto --&gt;
        &lt;context:property-placeholder location="classpath:development.properties"/&gt;

        &lt;!-- muistiin ladattava tietokanta --&gt;
        &lt;jdbc:embedded-database id="dataSource" type="H2"/&gt; 
    &lt;/beans&gt;
    &lt;!-- ... --&gt;
</pre>

              <p>Tiedosto <code>production.properties</code> sisältää tietokantakonfiguraation, erillisen <code>deployment.location</code>-parametrin sekä käytettävän persistenceunit-konfiguraation nimen. Tiedostot kansiossa <code>src/main/resources</code> kopioidaan osaksi classpath-polkua sovellusta paketoitaessa.</pre>

<pre>
deployment.location=PRODUCTION
database.url=jdbc:postgresql://localhost/superapp
database.username=supermies
database.password=rul44
persistence.unit=persistenceUnitProduction
</pre>

              <p>Tiedosto <code>development.properties</code> sisältää vain parametrin <code>deployment.location</code>.</p>

<pre>
deployment.location=DEVELOPMENT
persistence.unit=persistenceUnitDev
</pre>


              <p>Nyt kun sovellusta käynnistetään ilman erillisiä konfiguraatioita, on sovelluksessa käytössä muistiin ladattava tietokanta sekä tiedostosta <code>development.properties</code> ladatut konfiguraatiot. Konfiguraatioparametrit voi injektoida myös suoraan sovellukseen.</p>

<pre class="sh_java">
// ..
@Controller
public class DefaultController {

    @Value("${deployment.location}")
    private String location;
// ...
</pre> 


          <p>Käytännössä profiilien hallinta kannattaa toteuttaa esimerkiksi niin, että integraatio-, qa- ja tuotantoympäristöön määritellään ympäristömuuttuja, joka kertoo käytettävän profiilin. Springiä käytettäessä ympäristömuuttuja on <code>SPRING_PROFILES_ACTIVE</code> tai <code>spring.profiles.active</code>.</p>

          <p>Ympäristömuuttujan asetus tapahtuu *nix-koneilla <code>export</code>-komennolla.</p>

<pre>
export SPRING_PROFILES_ACTIVE=production
</pre>

<div class="tehtavat">
  
  <h3>Hello, I am...</h3>

  <p>Tässä projektissa saat valmiin sovelluspohjan. Sovelluksessa voi kuvailla itseään adjektiiveilla. Haluamme konfiguroida projektiin kolme profiilia: <code>dev,default</code> (sekä default että dev profiili), <code>ci</code> ja <code>production</code>.
  
  <p>Yrityksissä joissa sovelluskehittäjät pääsevät käsiksi eri ympäristöihin, on erittäin hyödyllistä nähdä aktiivinen profiilin sovelluksesta. Tämä helpottaa debuggaamista ja estää tuotantopalvelimen tapaturmaista käyttöä. Sovelluksen näkymä <code>hello.jsp</code> on tehty niin, että selaimen oikeaan yläreunaan tulee punaisella profiilin nimi. Profiilin nimet on konfiguroitu property-tiedostoihin <code>default.properties</code>, <code>ci.properties</code> ja <code>production.properties</code> avaimella <code>profile.name</code>. Löydät tiedostot Netbeansistä Other Sources:in alta kansiosta src/main/resources/properties.</p>
  
  <p>Muokkaa konfiguraatiotiedostoa <code>database.xml</code>. Luo sinne edellä mainitut kolme profiilia. Haluamme käyttää jokaisessa profiilissa erillistä muistista ladattavaa H2 tietokantaa. Käytä <code>jdbc:embedded-database</code>-elementtiä tietokantojen luomiseen. Käytä <code>id</code>:nä <code>dataSource</code>.</p>

  <p>Haluamme myös jokaisessa profiilissä luoda <a href="http://static.springsource.org/spring/docs/current/javadoc-api/org/springframework/beans/factory/config/PropertyPlaceholderConfigurer.html" target="_blank">PropertyPlaceholderConfigurer</a>:n, jotta voimme noutaa tässä tapauksessa profiilin nimen sitä vastaavasta property-tiedostosta. Tämä onnistuu konfiguraatiolla:</p>
  
<pre class="sh_xml">
    &lt;context:property-placeholder location="classpath:properties/TIEDOSTON_NIMI.properties" /&gt;
</pre>

  <p>Nyt voimme esimerkiksi noutaa profiilin nimen käyttäen annotaatiota <code>@Value</code> kuten alla.</p>
  
<pre class="sh_java">
    @Value("${profile.name}")
    private String name;
</pre>

  <p>Kun ajat sovelluksen Netbeansillä käytetään automaattisesti profiilia <code>default</code> (joka on kehitysprofiili). Voit testata muita profiileja Jetty:n avulla. Aseta ensiksi aktiivinen profiili asettamalla komentoriviltä ympäristömuuttuja komennolla <code>export SPRING_PROFILES_DEFAULT=PROFIILIN_NIMI</code>. Aja tämän jälkeen projekti komennolla <code>mvn jetty:start</code> projektin juuressa. Aktiivisen profiilin tulisi muuttua ja kyseisen profiilin nimi näkyä näkymässä.</p>
</div>



<!--
  
  testaaminen

    yksikkötestaus

    black-box -testaus
      spring test mvc
      selenium

    TEHTÄVÄ: selenium-testien luominen
-->


<h3>Testaaminen</h3>

  <p>Web-sovellusten testaamiseen kuuluu yksikkötestaus, integraatiotestaus ja systeemitestaus. Yksikkötestauksessa testataan sovellukseen kuuluvia yksittäisiä komponentteja ja varmistetaan että niiden tarjoamat rajapinnat toimivat kuten pitäisi. Integraatiotestauksessa testataan että komponentit toimivat yhdessä kuten niiden pitäisi, ja systeemitestauksessa sovellusta testataan ulkopuolelta esim. selaimella.</p>


  <h4>Yksikkötestaus</h4>


  <p>Yksikkötestauksella tarkoitetaan lähdekoodiin kuuluvien yksittäisten osien testaamista. Termi yksikkö viittaa ohjelman pienimpiin mahdollisiin testattaviin toiminnallisuuksiin, kuten olion tarjoamiin metodeihin. Single responsibility principlen mukaisesti haluamme pilkkoa ohjelmiston pieniin yksittäisen vastuun omaaviin yksikköihin, joiden testaaminen on helppoa: niillä on vain yksi vastuu. Testaus tapahtuu yleensä testausohjelmistokehyksen avulla, jolloin luodut testit voidaan suorittaa automaattisesti. Yleisin Javalla käytettävä testauskehys on JUnit. JUnit-kirjaston saa käyttöön lisäämällä siihen liittyvän riippuvuuden pom.xml-tiedostoon.</p>

<pre class="sh_xml">
        &lt;dependency&gt;
            &lt;groupId&gt;junit&lt;/groupId&gt;  
            &lt;artifactId&gt;junit&lt;/artifactId&gt;  
            &lt;version&gt;4.10&lt;/version&gt;  
            &lt;scope&gt;test&lt;/scope&gt;
        &lt;/dependency&gt;
</pre>

  <p>Yksittäisen riippuvuuden määre <code>scope</code> kertoo milloin riippuvuutta tarvitaan. Määrittelemällä <code>scope</code>-elementin arvoksi <code>test</code> on riippuvuudet käytössä vain testejä ajettaessa. Uusia testiluokkia voi luoda NetBeansissa valitsemalla New -> Other -> JUnit -> JUnit Test. Tämän jälkeen NetBeans kysyy testiluokalle nimeä ja pakkausta. Huomaa että lähdekoodit ja testikoodit päätyvät erillisiin kansioihin -- juurin näin sen pitääkin olla. Kun testiluokka on luotu, on projektin rakenne kutakuinkin seuraavanlainen.</p>

<pre>
.
|-- pom.xml
`-- src
    |-- main
    |   |-- java
    |   |   `-- wad
    |   |       `-- ... oman projektin koodit
    |   |-- resources
    |   |       `-- ... resurssit
    |   `-- webapp
    |           `-- ... jsp-tiedostot ja konfiguraatiotiedostot
    `-- test
        `-- java
            `-- wad
                `-- ... testikoodit!
</pre>




  <p>Testejä kirjoitetaan usein iteratiivisesti samaan aikaan sovellusta kehitettäessä. Paljon suosiota saanut TDD-menetelmä perustuu siihen, että sovellusta kehitetään kirjoittamalla siihen liittyviä testejä ensin. Tällöin sovellus on pakko pilkkoa pieniin osiin heti alusta.</p>


  <p>TDD-sykli tarkemmin: (1) Luo uusi testi joka testaa ei-olemassaolevaa toiminnallisuutta. (2) Aja olemassaolevat testit ja varmista että uusi testi ei mene läpi. Jos testi menee läpi testi on viallinen tai toivottu toiminnallisuus on jo toteutettu. (3) Kirjoita uutta toiminnallisuutta varten yksinkertaisin mahdollinen toteutus, joka läpäisee testin. Uuden toiminnallisuuden tulee olla toteutettu siten, että se läpäisee juuri kirjoitetun testin  ei muuta. (4) Suorita olemassaolevat testit ja varmista että ne menevät läpi. Jos testit eivät mene läpi, tarkista uuden toiminnallisuuden aiheuttamat muutokset. (6) Refaktoroi eli siisti koodia. Esimerkiksi toistuva koodi tulee siirtää omaan metodiinsa. (7) Palaa kohtaan (1)</p>

  <p>Yksinkertainen Laskin-esimerkki (ohjelmistojen mallintaminen, kesä 2011):</p>

  <p>Ensimmäinen testi: Halutaan että Laskin-olion voi luoda</p>

<pre class="sh_java">
import org.junit.Test;
public class LaskinTest {
    @Test
    public void testLaskimenLuonti() {
        Laskin laskin = new Laskin();
    }
}
</pre>

  <p>Luodaan toiminnallisuus joka läpäisee testin</p>

<pre class="sh_java">
public class Laskin {
}
</pre>

  <p>Testit ajetaan ja kaikki menevät läpi. Huomaa että testiluokan tulee olla samannimisessä pakkauksessa (joskin eri sijainnissa) kuin testattavan luokan. Tällöin testiluokka ei tarvitse erillistä import-käskyä testattavalle luokalle. Seuraava testi: Halutaan että laskin voi laskea laskun 1+1</p>

<pre class="sh_java">
import org.junit.Assert;
import org.junit.Test;
public class LaskinTest {

    @Test
    public void testLaskimenLuonti() {
        Laskin laskin = new Laskin();
    }

    @Test
    public void testYksiPlusYksi() {
        Laskin laskin = new Laskin();
        Assert.assertEquals(2, laskin.plus(1, 1));
    }
}
</pre>


  <p>Toteutetaan toiminnallisuus joka läpäisee testin. Huomaa että toiminnallisuuden tulee vain toteuttaa testin vaatima 
toiminnallisuus. Yksi plus yksi testille riittää hyvin toteutus joka palauttaa aina arvon 2.</p>

<pre class="sh_java">
public class Laskin {
    public int plus(int ekaluku, int tokaluku) {
        return 2;
    }
}
</pre>

<p>Kun testit suoritetaan, ne menevät läpi. Seuraava testi: Halutaan että laskin voi laskea laskun 1+2</p>

<pre class="sh_java">
import org.junit.Assert;
import org.junit.Test;
public class LaskinTest {
    @Test
    public void testLaskimenLuonti() {
        Laskin laskin = new Laskin();
    }
    @Test
    public void testYksiPlusYksi() {
        Laskin laskin = new Laskin();
        Assert.assertEquals(2, laskin.plus(1, 1));
    }
    
    @Test
    public void testYksiPlusKaksi() {
        Laskin laskin = new Laskin();
        Assert.assertEquals(3, laskin.plus(1, 2));
    }
}
</pre>

  <p>Toteutetaan toiminnallisuus joka läpäisee uuden testin. Jos plusmetodin toiminnallisuutta muutetaan siten, että se palauttaa aina luvun kolme, aikaisempi testi ei enää mene läpi. On mahdollista toteuttaa toiminnallisuus myös ehtolauseen avulla ("jos ekaluku on yksi, ja tokaluku on kaksi, palauta 3")  mutta myöhemmin joutuisimme refaktoroimaan koodin testit läpäiseväksi.</p>

<pre class="sh_java">
public class Laskin {

    public int plus(int ekaluku, int tokaluku) {
        return ekaluku + tokaluku;
    }
}
</pre>

  <p>Kun testit suoritetaan, ne menevät läpi  ja sykli jatkuu kunnes toiminnallisuus on valmis.</p>


  <p>Testit ovat erittäin oleellisia sovelluksen ylläpitovaiheessa. Käytännössä uuden sovelluskehittäjän liittyessä ohjelmistotiimiin, on olemassaolevan sovelluksen muokkaus erittäin vaikeaa ilman testejä. Yksi muutos voi rikkoa useampia toiminnallisuuksia, joiden rikkoutumisesta olemassaolevat testit ilmoittavat.</p>


<h4>Integraatiotestaus</h4>


  <p>Spring tarjoaa JUnit-kirjastolle tuen, jonka avulla saamme Autowired-annotaatiot toimimaan. Lisätään Spring-test -riippuvuus projektimme pom.xml-tiedostoon.</p>


<pre class="sh_xml">
        &lt;dependency&gt;
          &lt;groupId&gt;org.springframework&lt;/groupId&gt;
          &lt;artifactId&gt;spring-test&lt;/artifactId&gt;
          &lt;version&gt;3.1.2.RELEASE&lt;/version&gt;
          &lt;scope&gt;test&lt;/scope&gt;
        &lt;/dependency&gt;
</pre>

  <p>Springin oliokontekstia käyttävät yksikkötestit tarvitsevat kaksi annotaatiota alkuun. Annotaatio <code>@RunWith(SpringJUnit4ClassRunner.class)</code> kertoo että käytämme Springiä yksikkötestien ajamiseen ja annotaatiolle <code>@ContextConfiguration(locations = {".."})</code> annetaan käytettävien konfiguraatioiden sijainnit. Testiluokan alku näyttää esimerkiksi seuraavalta:</p>

<pre class="sh_java">
@RunWith(SpringJUnit4ClassRunner.class)
@ContextConfiguration(locations = {"file:src/main/webapp/WEB-INF/front-controller-servlet.xml"})
public class MyTest {
    @Autowired
    private MyService myService;

    // ... testit jne
</pre>

  <p>Ylläolevan konfiguraatiomäärittelyn avulla Spring pyrkii lataamaan oliokontekstin, ja asettamaan halutut oliot testiluokkiin, jossa niiden toiminnallisuutta voidaan testata.</p>


<h4>Systeemitestaus</h4>


  <p>Systeemitestaukseen on monenlaisia työkaluja, joista eräs on Selenium. Selenium on web-testauskehys, joka antaa sovelluskehittäjälle mahdollisuuden käydä läpi sovelluksen käyttöliittymää ohjelmallisesti samalla varmistaen että sivuilla on toivotut asiat. Se simuloi myös Javascript-komponenttien toiminnallisuutta, minkä avulla käyttöliittymän testaus helpottuu huomattavasti. Selenium on erittäin hyödyllinen esimerkiksi käyttötapausten läpikäynnissä. Saamme Seleniumin käyttöön lisäämällä sen osaksi <code>pom.xml</code>-tiedostoa.</p>

<pre class="sh_xml">
        &lt;dependency&gt;
            &lt;groupId&gt;org.seleniumhq.selenium&lt;/groupId&gt;
            &lt;artifactId&gt;selenium-java&lt;/artifactId&gt;
            &lt;version&gt;2.13.0&lt;/version&gt; 
            &lt;scope&gt;test&lt;/scope&gt; 
        &lt;/dependency&gt;
</pre>

  <p>Ajatellaan käyttötapausta jossa käyttäjä haluaa syöttää tunnuksen lomakekenttään ja päätyä toisenlaiselle sivulle. Haluamme löytää lomakekentän nimeltä "name". Kun kenttään asetetaan arvo "Bob" ja kenttään liittyvä lomake lähetetään, tulee sivulla olla lomakekenttä nimeltä "age".</p>

<pre class="sh_java">
public class SeleniumTest {
    private WebDriver driver;
    private String baseAddress;    
 
    @Before
    public void setUp() {
        this.driver = new HtmlUnitDriver();
        this.baseAddress = "...";
    }

    @Test
    public void onceBobSubmittedElementAgeIsAvailable() {
        // haetaan haluttu osoite (aiemmin määritelty muuttuja)
        driver.get(osoite);

        // haetaan kenttä nimeltä tunnus
        WebElement element = driver.findElement(By.name("name"));

        // asetetaan kenttään arvo
        element.sendKeys("Bob");

        // lähetetään lomake
        element.submit();
        
        // haetaan kenttä nimeltä "age"
        element = driver.findElement(By.name("age"));
        
        Assert.assertNotNull("Element \"age\" not found.", element);
    }
</pre>

  <p>Yllä käytämme HtmlUnitDriver-oliota html-sivun läpikäyntiin. Haemme ensin määritellyn osoitteen, eli surffaamme haluttuun osoitteeseen. Haemme osoitteesta saadusta lähdekoodista kentän name-attribuutilla "name", ja lisäämme kenttään arvon "Bob". Tämän jälkeen lomake lähetetään. Kun lomake on lähetetty, haetaan kenttää jolla attribuutin name arvona on "age". Jos kenttää ei löydy (eli palautettu arvo on null), testi epäonnistuu ja käyttäjä näkee viestin "Element "age" not found.".</p>



<div class="tehtavat">
  <h3>CAS 7782-49-2 (Selenium)</h3>

  <p>Tehtäväpohjan mukana tulee testiluokka <code>BeerSeleniumTest</code>, joka alustaa Seleniumin <code>WebDriver</code>-olion. Tehtävänäsi on tässä lisätä luokalle kaksi testimetodia. Tässä tehtävässä ei ole paikallisia testejä. Huom! Seuraa ohjeita tarkasti. Jos olet varma että testisi ovat oikein, mutta TMC:ltä tuleva vastaus ilmoittaa virheen, lähetä vastauksesi TMC:lle vielä muutaman kerran -- testien testaus tapahtuu erillisten säikeiden avulla, jotka voivat toimia epädeterministisesti.</p>

  <p>Kun testaat sovellusta, varmista että käytät sovelluksen juuriosoitetta testaamiseen -- testaamiseen käytetty jetty toimii (yleensä omassa tapauksessamme) osoitteessa <code>http://localhost:8090/</code>. Glassfishille tyypillinen erillinen sovelluksen juuriosoite <code>http://localhost:8090/W5-W5E06...</code> ei siis ole käytössä.</p>

  <p>Huom! Suosittelemme että tutustut tässä välissä Mozilla Firefoxille saatavilla olevaan <a href="http://seleniumhq.org/docs/02_selenium_ide.html" target="_blank">Selenium IDE-projektiin</a>.</p>

  <h4>submitAndVerify</h4>

  <p>Toteuta testimetodi <code>public void submitAndVerify()</code>, joka ensin menee sovelluksen sivulle ja tarkistaa ettei sivuilla ole olutta <code>"Up Up Down Down Left Right Left Right BA Select"</code>. Tämän jälkeen olut <code>"Up Up Down Down Left Right Left Right BA Select"</code> lisätään kenttään, jonka tunnus on <code>name</code>, ja lomake lähetetään. Tämän jälkeen sinun tulee varmistaa, että olut on olemassa.</p>

  <p>Huom! Toteuta varmistukset <code>junit</code>-sovelluskehyksen Assert-luokan tarjoamilla staattisilla metodeilla.</p>

  <h4>submitThreeAndVerify</h4>

  <p>Toteuta testimetodi <code>public void submitThreeAndVerify()</code>, joka ensin menee sovelluksen sivulle ja tarkastaa ettei sivuilla ole oluita <code>"Gargamel Ale"</code>, <code>"Crazy Ivan"</code> ja <code>"Hoptimus Prime"</code>. Tämän jälkeen oluet <code>"Gargamel Ale"</code>, <code>"Crazy Ivan"</code> ja <code>"Hoptimus Prime"</code> lisätään sivulle sivun lomaketta käyttäen. Lopulta testi testaa että lisätyt kolme olutta ovat list-sivulla.</p>
</div>



<!--

SKAALAUTUMINEN ja PILVI
  tietokantaprofiilit, iso osa kyselyistä käytännössä readeja
    muutoksia vain vähän
-->


<h2>Skaalautuminen ja pilvipalvelut</h2>


  <p>Jatketaan sovellusten skaalautumisen pohdintaa vielä hieman. Olemme aiemmin pohtineet vertikaalista ja horisontaalista skaalautumista sekä viestijonojen käyttöä vastauksena käyttäjien määrän lisääntymiseen. Aiemmin esitetyt lähestymistavat auttavat ongelmissamme, mutta voimme vielä parantaa tilannetta.</p>

  <p>Sovelluksen suorituskykyä ja toiminnallisuutta mitattaessa oleelliseen rooliin nousee sovelluksen profilointi. Esimerkiksi NetBeans sisältää valmiin sovelluksen profiloijan, jonka avulla voi tutkia eri sovelluksen osissa käytettyä aikaa. Profiloijan käyttäminen yhdessä kuormitustestaustyökalun kanssa (esim. <a href="http://jmeter.apache.org/">Apache JMeter</a> tai <a href="http://grinder.sourceforge.net/">The Grinder</a>) auttaa kyselyiden simuloinnissa, jolloin ongelmakohdat löytyvät helposti. </p>

  <p>Kuormitustestauksessa tulee ottaa huomioon sovellukseen tulevien kyselyiden todellinen profiili. Sovelluksen profilointituloksissa on huomattavia eroja riippuen pyyntöprofiileista. Jos 99% sovellukseen kohdistuvista pyynnöistä on GET-tyyppisiä pyyntöjä, ei kuormitustestaustyökalun tule testata 50% POST, 50% GET -tyyppisellä profiililla.</p>


<div class="extra">
  <p><strong>Spring Insight</strong></p>

  <p>Spring tarjoaa sovelluskehittäjille Spring Insight-sovelluksen, jonka avulla sovelluksen suorituskyvyn analysointi helpottuu huomattavasti. Se kiinnittyy sovelluksessa tapahtuviin suorituspolkuihin, jotka alkavat esimerkiksi HTTP-pyynnöistä. Jokaisessa suorituspolussa on joukko operaatioita, jotka kuvaavat merkittäviä tapahtumia suorituspolussa. Operaatiot ovat esimerkiksi tietokantakyselyitä tai transaktioiden tallennuksia.</p>
  
  <p>Spring Insight generoi suorituspolkudatasta automaattisia yhteenvetoja, joiden perustella sovelluksen toimintaa voi analysoida melko tarkasti. Tämä mahdollistaa muunmuassa ongelmakohtien löytämisen, jonka avulla sovelluksen suoritustehoa voi parantaa. Lue lisää <a href="http://www.springsource.org/insight" target="_blank">täältä...</a></p>

</div>

<!--
  cachen käyttö (ehcache, jsr-107)
    cache käytännössä mappi
    cachetetaan palvelujen tuloksia

    TEHTÄVÄ: palvelu, jossa tulokset cachetetaan, tehtävänä konffaus
-->


<h3>Cache</h3>


  <p>Käytännössä huomattava osa web-palvelinohjelmistoille tulevista kyselyistä on GET-tyyppisiä pyyntöjä. GET-tyyppiset pyynnöt eivät muokkaa palvelimella olevaa dataa, vaan pyytävät vain tietoa. Esimerkiksi tietokannasta dataa hakevat GET-tyyppiset pyynnöt luovat aina yhteyden erilliseen tietokantasovellukseen, josta ne hakevat dataa pyynnön perusteella. Sovellusten skaalautumista pohtiva sovelluskehittäjä alkaakin miettimään että eikö uudestaan ja uudestaan haettavaa dataa voisi tallentaa välimuistiin.</p>

  <p>Ovela ohjelmoija hyödyntää Javan valmista kalustoa välimuistin toteuttamiseen. Esimerkiksi Javan luokka <code><a href="http://docs.oracle.com/javase/6/docs/api/java/util/LinkedHashMap.html" target="_blank">LinkedHashMap</a></code> tarjoaa mainion pohjan oman välimuistin toteutukseen. Luokan metodia <code>removeEldestEntry</code> kutsutaan aina uuttaa arvoa lisättäessä. Käytännössä välimuistin voi luoda perimällä luokan <code>LinkedHashMap</code>, ja korvaamalla metodin <code>removeEldestEntry</code> siten, että huomioon otetaan välimuistille määriteltävä parametrin <code>cacheSize</code>, joka määrittelee välimuistin koon.</p>

<pre class="sh_java">
public class SimpleCache&lt;K, V&gt; extends LinkedHashMap&lt;K, V&gt; {
    private int cacheSize;

    public SimpleCache(int cacheSize) {
        super();
        this.cacheSize = cacheSize;
    }
        
    @Override
    public boolean removeEldestEntry(Map.Entry eldest) {
        return size() > cacheSize;
    }   
}
</pre> 


  <p>Yllä olevan toteutuksen voi lisätä osaksi palveluluokkien metodeja. Pohditaan seuraavaa <code>BeerService</code>-rajapintaa, joka on tullut jo tutuksi. Luodaan sille seuraavaksi erillinen palvelu, joka käyttää Spring Data JPA:ta. Repository-luokkaa ei näytetä erikseen.</p>

<pre class="sh_java">
public interface BeerService {
    
    Beer create(Beer beer);
    Beer read(Long identifier);
    // ...
</pre>

<pre class="sh_java">
public class JpaBeerService implements BeerService {

    @Autowired
    private BeerRepository beerRepository;

    private SimpleCache&lt;Long, Beer&gt; beerCache;

    public JpaBeerService() {
        // luodaan cache, johon voi varastoida 1000 oluen tiedot
        this.beerCache = new SimpleCache&lt;Long, Beer&gt;(1000);
    }

    @Override
    @Transactional(readOnly = false)
    public Beer create(Beer beer) {
        // tallennetaan cacheen vasta kun olut haetaan
        return beerRepository.save(beer);
    }

    @Override
    @Transactional(readOnly = true)
    public Beer read(Long identifier) {
        // jos olut on cachessa, palautetaan se sieltä
        if(beerCache.containsKey(identifier)) {
            return beerCache.get(identifier);
        }

        // muuten haetaan olut tietokannasta, ja tallennetaan se
        // cacheen
        Beer beer = beerRepository.findOne(identifier);
        beerCache.put(identifier, beer);
        return beer;
    }
    // ...
</pre>

  <p><em>Melko ovelaa, eikö?</em></p>

  <p>Ovelaa kyllä, muttei fiksua. Keksimme vahingossa taas pyörän uudestaan.</p>

  <h4>EHcache</h4>

  <p>Maailmalla on huomattava määrä valmiita cache-toteutuksia, joista yksi on <a href="http://ehcache.org/" target="_blank">EHcache</a>. Vaikka tässä tutustumme EHcacheen vain pikaisesti, tarjoaa se toiminnallisuuden muunmuassa hajautettujen välimuistien toteutukseen ja ns. big data -skaalan sovellusten tukemiseen.</p>

  <p>Koska käytössämme on Spring, konfiguroidaan EHcache Springille. Spring tarjoaa erilaisten <a href="http://static.springsource.org/spring/docs/current/spring-framework-reference/html/cache.html" target="_blank">välimuistitoteutusten abstraktion</a>. Lisätään ensin EHcacheen liittyvä riippuvuus pom.xml-tiedostoomme.</p>

<pre class="sh_xml">
        &lt;dependency&gt;
            &lt;groupId&gt;net.sf.ehcache&lt;/groupId&gt;
            &lt;artifactId&gt;ehcache-core&lt;/artifactId&gt;
            &lt;version&gt;2.6.0&lt;/version&gt;
        &lt;/dependency&gt;
</pre>


  <p>Olemme jo tykästyneet annotaatioihin, joten otetaan käyttöön välimuistin hallinnointi annotaatioilla. Huomaa että Springin cache-abstraktio ei ota kantaa välimuistin konfiguraatioon, joten se tulee luoda erikseen. Luodaan EHCachelle yksinkertainen konfiguraatio, joka määrittelee muistissa käytettävän cachen. Erillisen konfiguraatiotiedoston käyttäminen on kätevää, sillä voimme kehityskoneilla käyttää yksinkertaista cachea, kun taas tuotantokoneilla cachekonfiguraatio voi olla täysin erilainen. Luodaan kansioon <code>src/main/resources</code>, eli Other Sources, tiedosto <code>ehcache-dev.xml</code>, johon lisätään seuraava konfiguraatio. Tarkemmin konfiguraatiosta löytyy mm. EHcachen omasta <a href="http://ehcache.org/documentation" target="_blank">dokumentaatiosta</a>.</p>

<pre class="sh_xml">
&lt;ehcache maxBytesLocalHeap="10M"&gt;
    &lt;defaultCache maxElementsInMemory="1000" eternal="true"
                  overflowToDisk="false" memoryStoreEvictionPolicy="LFU" /&gt;
    &lt;-- käytössämme on cache nimeltä beers --&gt;
    &lt;cache name="beers"/&gt;
&lt;/ehcache&gt;
</pre>

  <p>Lisätään seuraavaksi Spring-konfiguraatioomme (esim. <code>front-controller-servlet.xml</code>) seuraava konfiguraatio. Haluamme hallinnoida välimuistia annotaatioilla, ja käyttää EHcachea välimuistin toteuttajana. EHcachen konfiguraatiotiedostona on yllä määritelty <code>ehcache-dev.xml</code>-tiedosto.</p>

<pre class="sh_xml">
    &lt;!-- ... --&gt;
    xmlns:cache="http://www.springframework.org/schema/cache"
                            http://www.springframework.org/schema/cache 
                            http://www.springframework.org/schema/cache/spring-cache-3.1.xsd
    &lt;!-- ... --&gt;

    &lt;!-- annotaatioilla hallittava cache --&gt;
    &lt;cache:annotation-driven /&gt;
    &lt;bean id="cacheManager" class="org.springframework.cache.ehcache.EhCacheCacheManager"&gt;
        &lt;property name="cacheManager" ref="ehcache" /&gt;
    &lt;/bean&gt;

    &lt;!-- käytetään EHcachea cachena --&gt;
    &lt;bean id="ehcache" class="org.springframework.cache.ehcache.EhCacheManagerFactoryBean" &gt;
        &lt;!-- konfiguraatio löytyy kansiosta src/main/resources, 
        joka kopioidaan classpathiin sovelluksen käynnistyessä --&gt;
        &lt;property name="configLocation" value="classpath:ehcache-dev.xml" /&gt;
    &lt;/bean&gt;

    &lt;!-- ... --&gt;
</pre>


  <p>Kun olemme konfiguroineet välimuistin, voimme toteuttaa välimuistin hieman eritavalla kuin aiemmin. Spring tarjoaa käyttöömme mm. <code>@Cacheable</code>- ja <code>@CacheEvict</code>-annotaatiot, joiden avulla voidaan määritellä välimuistin käyttö ja tyhjennys metodeille. Yllä olevan <code>JpaBeerService</code>-luokan toteutus hoituisi nyt seuraavasti.</p>

<pre class="sh_java">
public class JpaBeerService implements BeerService {

    @Autowired
    private BeerRepository beerRepository;

    @Override
    @Transactional(readOnly = false)
    @Cacheable(value="beers", key="#beer.id")
    public Beer create(Beer beer) {
        return beerRepository.save(beer);
    }

    @Override
    @Transactional(readOnly = true)
    @Cacheable("beers")
    public Beer read(Long id) {
        return beerRepository.findOne(id);
    }
    // ...
</pre>


  <p>Käytännössä metodille <code>read</code> luodaan proxy-metodi, joka ensin tarkistaa onko haettavaa tulosta välimuistissa. Välimuistina käytetään välimuistia nimeltä <code>"beers"</code>, joka on aiemmin konfiguroitu tiedostossa <code>ehcache-dev.xml</code>. Jos tulos on välimuistissa, palautetaan se sieltä, muuten tulos haetaan tietokannasta ja tallennetaan välimuistiin. Oleellisinta tässä lähestymistavassa on se, että välimuistin konfiguraatiota voi muuttaa käytettävien profiilien avulla. Aiemmin toteutettu ohjelmallisesti tehty välimuisti ei skaalaudu, kun taas valmista cache-komponenttia käyttävä sovellus skaalautuu konfiguraatiosta riippuen.</p>


  <p>Välimuistia voi käyttää myös kontrolleritasolla, esimerkiksi JSON-muotoista olutdataa palauttavan kontrollerimetodin tuloksen saa välimuistiin seuraavasti.</p>


<pre class="sh_java">
@Controller
public class BeerController {

    @Autowired
    private BeerService beerService;

    // ...

    @Cacheable("beers")
    @RequestMapping(method = RequestMethod.GET, value = "beer/{beerId}", produces="application/json")
    @ResponseBody
    public Beer read(@PathVariable Long beerId) {
        return beerService.read(beerId);
    }
    // ...
</pre>


  <p><strong>Huom!</strong> Spring tai EHcache ei tarkista muuttuuko cachen takana oleva data. Dataa muuttavat metodit tulee annotoida sopivasti annotaatiolla <code>@CacheEvict</code>, jotta välimuistista poistetaan muuttuneet tiedot.</p>


<div class="tehtavat">
  <h3>Cached calculations</h3>

  <p>Ovela kaverisi on koodannut pelitietojen hakemiseen tarkoitettuun sovellukseen oman <code>GameCache</code>-toteutuksensa, joka tallentaa erilliseltä REST-palvelulta saatavia tuloksia paikalliseen välimuistiin. Refaktoroi sovellusta ja erityisesti <code>GameRestClient</code>-luokkaa siten, että heivaat kaverisi toteutuksen mäkeen, ja alat käyttämään Springin valmiiksi tarjoamaa Cache-abstraktiota. Fiksumpi kaverisi on konfiguroinut sovellukseen valmiiksi EHcachen.</p>

  <p>Käytä annotaatiota <code>@CacheEvict</code> välimuistin tyhjentämiseen niissä tapauksissa, kun se tulee tyhjentää. Huomaa, että myös metodin <code>findAll()</code> tulokset tulee tallentaa välimuistiin. Tyhjennä <code>findAll</code>-metodin tuloslista välimuistista kun tallennettua tietoa muutetaan.</p>

  <p>Lisää tietoa Springin cache-abstraktiosta löytyy Springin <a href="http://static.springsource.org/spring/docs/current/spring-framework-reference/html/cache.html" target="_blank">dokumentaatiosta</a>.</p>
</div>


<!--

  pilvi: iaas, paas, saas
    he-ro-kuu!
    case: herokuun deployment
-->


<h3>Pilvipalvelut</h3>


  <p>Pilvipalvelut ovat verkossa toimivia palveluita. Pilvipalveluissa maksetaan vain käytetyistä resursseista -- sovelluksesta (SaaS, <em>Software as a Service</em>), alustasta (PaaS, <em>Platform as a Service</em>) tai laskentakapasiteetista (IaaS, <em>Infrastructure as a Service</em>). Pilvipalveluille ominaista on skaalautuvuus, palveluita käytetään vain kun on tarve. Jos käyttäjiä on paljon, käytössä olevien resurssien määrää voi dynaamisesti lisätä -- jos käyttäjiä on vähän, resurssien määrää voidaan laskea.</p>


  <p>Sovellusalustaa palveluna (PaaS, <em>Platform as a Service</em>) tarjoavat yritykset mahdollistavat järjestelmän nopeamman kehittämisen -- sovelluskehittäjän ei tarvitse välittää alustasta sillä se on jo valmiina. Kustannusten arviointi on helpompaa sillä pilvipalveluiden laskutus tapahtuu käytön mukaan -- sovelluskehittäjä voi lisätä oman ylläpitokurstannuksen. Sovellusalustat piilottavat taustalla olevan infrastruktuurin, jolloin sovelluskehittäjän ei tarvitse välittää taustalla toimivasta palvelusta. Osa PaaS-tarjoajista toimii IaaS-tarjoajien tarjoamien palveluiden päällä: Esimerkiksi kohta tutuksi tuleva Heroku pyörii Amazonin päällä.</p>


<div class="tehtavat">

  <h3>Strato</h3>

  <p><em>Havaintopaikkojen ja säähavaintojen lisäys ja listaus</em>.</p>

  <p>Tämä tehtävä on avoin tehtävä jossa saat itse suunnitella huomattavan osan ohjelman sisäisestä rakenteesta. Osa sovelluksen toiminnallisuudesta on ohjelmoitu valmiiksi. Valmiina on mm. käyttöliittymä (jsp-sivut), domain-objektit, ja osa kontrollereiden toiminnallisuudesta. Myös ensimmäiseen osaan tarvittavat palveluluokat ja repository-luokat ovat valmiina.</p>

  <p>Käyttöliittymään on määritelty EL-kielellä attribuutit, joita käyttöliittymän tulee näyttää. Tehtäväpohjassa on myös valmis konfiguraatio spring-projektille.</p>

  <p>Tehtävästä on mahdollista saada yhteensä 4 pistettä.</p>

  <p>Luo tehtävässä sovellus, joka toimii kuten osoitteessa <a href="http://strato.herokuapp.com" target="_blank">http://strato.herokuapp.com</a> oleva sovellus. Sovelluksessasi ei tarvitse olla XSS-tarkastusta.</p>

  <p>Huom! Viestijonojen tai erillisten REST-rajapintaa käyttävien palveluiden käyttäminen ei liene tarpeellista tehtävässä.</p>


<p><strong>Pisteytys:</strong></p>


<ol style="list-style-type: none;">
  <li>+ 1p: Havaintopisteiden (<code>ObservationPoint</code>) lisääminen ja näyttäminen onnistuu. <br/><br/>Havaintopisteiden hallintasivulle tulee päästä aloitussivulla olevan linkin ("Observation points") kautta. Kun uusi havaintopiste on lisätty, se näytetään <code>Observation points</code>-linkin avaamalla sivulla. Käytä havaintopisteiden sivuna <code>points.jsp</code>-sivua.<br/><br/></li>
  
  <li>+ 1p: Havaintojen (<code>Observation</code>) lisääminen havaintopisteisiin ja niiden näyttäminen onnistuu. <br/><br/>Havaintojen lisäyssivulle tulee päästä aloitussivulla olevan linkin ("Observations") kautta. Kun uusi havainto on lisätty, se näytetään <code>Observation</code>-linkin avaamalla sivulla. Käytä havaintojen sivuna <code>observations.jsp</code>-sivua.<br/><br/></li>
  
  <li>+ 2p: Havaintojen sivuttaminen. Tällä hetkellä kaikki havainnot näytetään samalla sivulla. Olisi kuitenkin hyvä, että havainnot olisi sivutettu, jolloin sivulla näytetään vain tietty määrä havaintoja kerrallaan. Toteuta sovellukseen sivutus siten, että havaintoja näytetään kerrallaan maksimissaan 5, ja havainnot ovat järjestetty lisäysajan (<code>timestamp</code>) mukaan laskevasti (<code>DESC</code>).<br/><br/>JSP-sivulla <code>observations.jsp</code> on valmiina käyttöliittymän tarvitsema toiminnallisuus sivutukseen. Jotta sivutus toimisi, sinun tulee lisätä pyyntöön sivujen kokonaismäärää kuvaava attribuutti <code>totalPages</code>, nykyistä sivunumeroa kuvaava attribuutti <code>pageNumber</code>, sekä tietenkin kyseisellä sivulla näkyvät havainnot. Tarvitset myös pyynnöstä parametrin <code>pageNumber</code>, joka kuvaa käyttäjän haluamaa sivunumeroa.<br/><br/>Seuraavasta koodinpätkästä ja Spring Data JPA:sta saattaa olla hyötyä, googlettamalla löydät varmasti lisää apua.<br/>
<pre class="sh_java">
    public Page&lt;Observation&gt; listObservations(Integer pageNumber, Integer pageSize) {
        PageRequest request = new PageRequest(pageNumber - 1, pageSize,
                Sort.Direction.DESC, "timestamp");
        return observationRepository.findAll(request);
    }
</pre>
  </li>
</ol>

</div>

<div class="extra">
  <p><strong>Sovellus Herokuun!</strong></p>

  <p>Tässä esitellään askeleet ylläolevan sovelluksen siirtämiseen Herokuun. Jotta onnistut, sinun tulee rekisteröityä osoitteessa <a href="https://api.heroku.com/signup" target="_blank">https://api.heroku.com/signup</a> ja asentaa Heroku-työvälineet koneellesi. Työvälineet löytyy osoitteesta  <a href="https://toolbelt.heroku.com/" target=_"blank">https://toolbelt.heroku.com/</a>.</p>

  <p>Jotta sovellus toimisi Herokussa, tulee sitä muokata hieman. Ensimmäinen on <code>maven-dependency-plugin</code>-liitännäisen lisääminen <code>pom.xml</code>-tiedostoon. Heroku luo liitännäisen avulla sovelluksesta käynnistettävän ohjelman. Käytännössä <code>pom.xml</code>-tiedostoon tulee lisätä seuraavat rivit <code>plugins</code>-elementin sisälle.</p>


<pre class="sh_xml">
            &lt;plugin&gt;
                &lt;groupId&gt;org.apache.maven.plugins&lt;/groupId&gt;
                &lt;artifactId&gt;maven-dependency-plugin&lt;/artifactId&gt;
                &lt;version&gt;2.3&lt;/version&gt;
                &lt;executions&gt;
                    &lt;execution&gt;
                        &lt;phase&gt;package&lt;/phase&gt;
                        &lt;goals&gt;
                            &lt;goal&gt;copy&lt;/goal&gt;
                        &lt;/goals&gt;
                        &lt;configuration&gt;
                            &lt;artifactItems&gt;
                                &lt;artifactItem&gt;
                                    &lt;groupId&gt;org.mortbay.jetty&lt;/groupId&gt;
                                    &lt;artifactId&gt;jetty-runner&lt;/artifactId&gt;
                                    &lt;version&gt;7.5.4.v20111024&lt;/version&gt;
                                    &lt;destFileName&gt;jetty-runner.jar&lt;/destFileName&gt;
                                &lt;/artifactItem&gt;
                            &lt;/artifactItems&gt;
                        &lt;/configuration&gt;
                    &lt;/execution&gt;
                &lt;/executions&gt;
            &lt;/plugin&gt;
</pre>

  <p>Nyt heroku osaa luoda sovelluksestamme komentoriviltä käynnistettävän version. Tämän lisäksi sovelluksen juurikansioon tulee luoda tiedosto <code>Procfile</code>, joka sisältää sovelluksen käynnistämiseen tarvittavan komennon. Käytännössä sovellusta herokuun lisättäessä sovellus ensin paketoidaan herokun toimesta <code>mvn package</code>-komennolla, jonka jälkeen tiedoston <code>Procfile</code>-sisältö suoritetaan. Alla olevalla konfiguraatiolla käynnistetään Java-tyyppinen web-sovellus, jolle annetaan parametreina käytettävä profiili sekä Herokun valmiit java-konfiguraatiot ja sovelluksen portti.</p>

<pre>
web: java -Dspring.profiles.active=production $JAVA_OPTS -jar target/dependency/jetty-runner.jar --port $PORT target/*.war
</pre>

  <p>Kun sovelluksen konfiguraatio on valmis, lisätään se seuraavaksi herokuun. Oletamme tässä että olet sovelluksen juurikansiossa (tiedosto <code>pom.xml</code> on samassa kansiossa), ja että olet asentanut heroku-sovelluksen koneellesi. Oletamme myös, että käytössäsi on *nix-järjestelmä. Kirjaudutaan ensin heroku-palveluun, ja lisätään herokuun ssh-avain.</p>

<pre>
sovelluksen-nimi$ heroku login
Enter your Heroku credentials.
Email: <em>käyttäjätunnus (sähköpostiosoite)</em>
Password (typing will be hidden): <em>salasana</em>
Authentication successful.
sovelluksen-nimi$ heroku keys:add
</pre>

  <p>Tämän jälkeen suoritetaan komento <code>mvn clean</code>, joka poistaa <code>target-kansion</code>.</p>

<pre>
sovelluksen-nimi$ mvn clean
...
[INFO] BUILD SUCCESSFUL
sovelluksen-nimi$
</pre>

  <p>Alustetaan kansioon git-repo, lisätään kansiossa olevat tiedoston versionhallintaa, ja lopuksi commitataan muutokset.</p>

<pre>
sovelluksen-nimi$ git init
sovelluksen-nimi$ git add .
sovelluksen-nimi$ git commit -am "init"
</pre>

  <p>Luodaan heroku-kohde, johon lähdekoodeja voi lisätä. Heroku luo automaattisesti sovellukselle osoitteen, johon se käynnistyy.</p>

<pre>
sovelluksen-nimi$ heroku create
Creating still-taiga-8629... done, stack is cedar
http://still-taiga-8629.herokuapp.com/ | git@heroku.com:still-taiga-8629.git
sovelluksen-nimi$
</pre>

  <p>Pushataan versionhallinnassa olevat tiedostot lopulta herokuun. </p>


<pre>
sovelluksen-nimi$ git push heroku master
...
</pre>

  <p>Tämän jälkeen sovellus siirretään herokuun, ja heroku alkaa käynnistämään sitä aiemmin automaattisesti luotuun osoitteeseen. Kun käynnistyminen onnistuu, sovellus on nähtävillä luodussa osoitteessa.</p>

  <p>Jos sovelluksen polkua haluaa muuttaa, voi sen tehdä herokun hallintakäyttöliittymästä. Kirjaudu herokuun, valitse <code>Apps</code> -&gt; sovellus -&gt; Settings. Voit muuttaa sovelluksen nimeä vaihtamalla <code>name</code>-kohdassa olevan nimen ja klikkaamalla <code>rename</code>. Jos nimen vaihtaminen onnistuu (nimi ei esim. ole varattu), siirtää heroku sovelluksen uuteen paikkaan. Jos nimeksi valitaan esim <code>high-five</code>, tulee projektikansion <code>.git/config</code> -tiedostoa muokata siten, että se heroku-repo käyttää oikeaa osoitetta. Ylläolevassa esimerkissä config-tiedoston sisältö on aluksi seuraavanlainen. </p>

<pre>
[core]
        repositoryformatversion = 0
        filemode = true
        bare = false
        logallrefupdates = true
[remote "heroku"]
        url = git@heroku.com:still-taiga-8629.git
        fetch = +refs/heads/*:refs/remotes/heroku/*
</pre>

<p>Kun sovellus nimetään uudestaan, siirtyy myös sen osoite. Esimerkiksi <code>high-five</code>-sovelluksen osoite muuttuu muotoon <code>git@heroku.com:high-five.git</code>. Muunnetaan konfiguraatiota soveltuvasti.</p>

<pre>
[core]
        repositoryformatversion = 0
        filemode = true
        bare = false
        logallrefupdates = true
[remote "heroku"]
        url = git@heroku.com:high-five.git
        fetch = +refs/heads/*:refs/remotes/heroku/*
</pre>

<p>Nyt voimme lisätä muutoksia herokuun. Muutokset käynnistävät palvelimen automaattisesti uudestaan, jolloin uusin versio on aina näkyvillä loppukäyttäjälle.</p>
</div>

<!--
  skaalautuminen pilvessä
    sticky session
    automaattinen lisäsovellusten luonti
    cachet: tietokanta
-->

<!-- 
VK6
-->


<h4>Skaalautuminen pilvessä</h4>


          <p>Pilvipalveluiden käyttäminen mahdollistaa sovelluksen skaalautumisen tarpeen mukaan. Kun sovellus on hyvin aktiivisessa käytössä, voidaan siitä luoda useampia resursseja helposti. Toisaalta, jos sovelluksen käyttö pienenee, voidaan käytössä olevia resursseja vähentää. Pilvipalveluilla ei vielä ole yhtenäistä skaalautumismallia, mutta skaalautuminen perustuu samoihin periaatteisiin kuin "normaalien" sovellusten skaalautuminen.</p>

          <p>Kun pilvipalvelu huomaa resurssien lisätarpeen, se käynnistää uusia sovellusta pyörittäviä palvelimia. Uusien palvelimien käynnistyksen tulee olla helppoa ja selkeästi määriteltyä, esimerkiksi Herokulla uuden sovelluksen käynnistämisen vaativat komennot on määritelty erilliseen <code>Procfile</code>-nimiseen tiedostoon, jonka pohjalta uusia palvelimia käynnistetään. Kun uusi palvelin käynnistetään, lisätään se automaattisesti sovellukseen liittyvälle (ohjelmistopohjaiselle) reitittimelle, joka alkaa ohjaamaan pyyntöjä myös uudelle palvelimelle. Reititin tarjotaan käytännössä aina pilvipalvelun puolesta.</p>

          <p>Jos pyyntöjen määrä palvelulle vähenee, voidaan käynnissä olevia palvelimia ajaa alas. Esimerkiksi Heroku sammuttaa ylimääräisiä palvelimia jos niille ei ole ollut tarvetta viimeisen tunnin aikana. Maksullisissa pilvipalveluissa yksi palvelin on yleensä aina päällä, jolloin vasteajat ovat aina nopeita. Ilmaiset pilvipalvelut sammuttavat viimeisimmätkin palvelimet jos pyyntöjä ei tule vähään aikaan. Tällöin palvelin käynnistetään vain tarpeen vaatiessa.</p>

          <p>Useamman palvelimen pyörittäminen nostaa palvelun vikasietoisuutta. Käytännössä pilvipalveluissa palvelimet pyörivät erillisissa fyysisissä sijainneissa, jolloin vikatapaukset tietyssä koneessa eivät vaikuta koko sovelluksen toimintaan.</p>

          <p>Pilvipalvelut eivät ota kantaa sovelluksen sisäiseen rakenteeseen. Esimerkiksi sovelluksen arkkitehtuuria ei muuteta viestijonoja käyttäväksi tarvittaessa. Sovelluksen tehokas arkkitehtuurisuunnittelu on aina sovelluskehittäjän vastuulla. Jos palvelimia käynnistetään paljon sen takia, että sovelluksen suunnittelija ei ole ottanut huomioon erilaisia sovelluksen tarpeita (esim. raskaan prosessoinnin hoitaminen erillisellä palvelulla), tulee pilvipalvelun käyttämisen kustannukset myös olemaan korkeammat sillä palvelimia käynnistetään niiden kuorman perusteella. Raskas prosessointi kannattaa toteuttaa erillisellä palvelulla siten, että prosessointiin erikoistunut palvelu hakee työt erillisestä töitä varastoivasta viestijonosta. </p>


<div class="extra">

  <p>Kannattaa tutustua herokun skaalautumismalliin osoitteessa <a href="http://www.heroku.com/how/scale" target="_blank">http://www.heroku.com/how/scale</a>. Miten Herokun malli poikkeaa Amazon Beanstalkin mallista (<a href="http://media.amazonwebservices.com/AWS_Cloud_Best_Practices.pdf" target="_blank">Best practises</a>, <a href="http://docs.amazonwebservices.com/elasticbeanstalk/latest/dg/concepts.concepts.architecture.html" target="_blank">Architectural overview</a>)?.</p>
  <p>&nbsp;</p>
  <p>&nbsp;</p>
</div>



<h2>Autentikointi ja autorisointi</h2>



          <p>Autentikointi ja autorisointi. Autentikoinnilla tarkoitetaan sitä, että käyttäjän identiteetti varmistetaan. Autentikointi tapahtuu esimerkiksi käyttäjätunnuksen ja salasanan avulla. Autorisoinnilla taas tarkoitetaan sen varmistamista, että käyttäjä saa tehdä hänen yrittämiään asioita.</p>

          <p>HTTP-protokolla vaatii sen toteuttajilta kaksi autentikointitapaa: "Basic autentikoinnin" ja "digest autentikoinnin". Emme käsittele niitä tässä, lisätietoa niistä löytää <a href="http://unixpapa.com/auth/basic.html" target="_blank">täältä</a>.</p>


          <h3>Autentikointi</h3>

          <p>Autentikointi, eli käyttäjän identiteetin varmistaminen, on yksi web-sovellusten oleellisista ominaisuuksista. Käyttäjän identiteetti tarkistetaan yleisimmin käyttäjätunnus-salasana -parin avulla siten, että käyttäjä lähettää ne HTTP-yhteyden yli palvelimelle. Kiitettävä osa nykyaikaisista sovelluskehyksistä tarjoaa autentikointimekanismin osana tietoturvakomponenttiaan. Autentikointisovellukset toimivat yleensä erillisinä filttereinä tarkistaen sovellukselle tehtäviä pyyntöjä.</p>

          <p>Käyttäjän identiteetin varmistaminen vaatii käyttäjälistan, joka taas yleensä ottaen tarkoittaa käyttäjän rekisteröintiä palveluun. Käyttäjän rekisteröitymisen vaatiminen heti sovellusta käynnistettäessä voi rajoittaa käyttäjien määrää huomattavasti, joten rekisteröitymistä kannattaa pyytää vasta kun siihen on tarve.</p>

          <p>Erillinen rekisteröityminen ei ole aina tarpeen. Web-sovelluksille on käytössä useita kolmannen osapuolen tarjoamia keskitettyjä identiteetinhallintapalveluita. Esimerkiksi <a href="http://oauth.net/" target="_blank">OpenAuth</a>:n avulla sovelluskehittäjä voi antaa käyttäjilleen mahdollisuuden käyttää jo olemassaolevia tunnuksia.</p>


<div class="tehtavat">
  <NEXTWEEK></NEXTWEEK>

  <h3>Rite of Passage</h3>

  <p>Back to Basics. Yksinkertaisimmat pääsytarkistukset toteutetaan filtterinä, joka käsittelee pyynnöt ennen sovellukselle pääsyä. Tässä tehtävässä toteutat oman filtterin, joka varmistaa ettei sovellusta voi käyttää ilman käyttöoikeuksia. Autentikointi toteutetaan filtterin avulla, tieto varmistumisen onnistumisesta tallennetaan sessioon.</p>
 
  <p>Luo <code>javax.servlet.Filter</code>-rajapinnan toteuttava luokka <code>AccessControlFilter</code> pakkaukseen <code>wad.accesscontrol</code>. Konfiguroi <code>web.xml</code> siten, että kaikki <code>front-controller</code> servletille menevät pyynnöt menevät luokan <code>AccessControlFilter</code> kautta.</p>

  <p>Toteuta itse filtteri seuraavasti: Jos pyynnön osoitteessa <em>(metodi getRequestURI())</em> on merkkijono <code>"login"</code>, tulee pyynnöstä tarkistaa parametrit <code>username</code> ja <code>password</code>. Jos parametrin <code>username</code> arvo on <code>"username"</code> ja parametrin <code>password</code> arvo on <code>"password"</code>, tulee sessioon asettaa attribuutti nimeltä <code>"authenticated"</code> arvolla <code>true</code>. Tämän jälkeen pyyntö ohjataan osoitteeseen <code>{sovelluksen juuriosoite}/app/secret</code>.</p> 

  <p>Jos pyynnön osoitteessa ei ole merkkijonoa <code>"login"</code>, tulee sessiosta tarkistaa attribuutti <code>"authenticated"</code>. Jos attribuuttia <code>"authenticated"</code> ei ole asetettu, eli sen arvo on null, käyttäjä tulee ohjata osoitteeseen <code>{sovelluksen juuriosoite}/denied.jsp</code>. Jos attribuutti <code>"authenticated"</code> on asetettu, prosessointia jatketaan parametrina saadun <code>FilterChain</code>-olion avulla.</p>

  <p>Huom! Vaikka Filter-rajapinnan metodi <code>doFilter</code> saa parametrinaan <code>ServletRequest</code> ja <code>ServletResponse</code>-oliot, voit olettaa että ne ovat tyyppiä <code>HttpServletRequest</code> ja <code>HttpServletResponse</code>. Toteuta pyynnön uudelleenohjaukset <code>HttpServletResponse</code>-olion <code>sendRedirect</code>-metodilla, sovelluksen juuriosoitteen saat pyyntöön liittyvällä metodilla <code>getContextPath()</code>.</p>

  <p>Muista myös, että uudelleenohjauksen jälkeen metodin suoritus tulee lopettaa.</p>
</div>



          <h3>Autorisointi</h3>

          <p>Autentikoinnin lisäksi tulee varmistaa, että käyttäjät pääsevät käsiksi vain heille oikeutettuihin resursseihin. Käyttäjät määritellään yleensä joko yksilöllisesti tai roolien kautta. Yleisin lähestymistapa käyttöoikeuksien määrittelyyn on käyttöoikeuslistat (ACL, <em>Access Control List</em>), joiden avulla määritellään käyttäjien (tai käyttäjäroolien) pääsy resursseihin. Käytännössä käyttöoikeuslistat määritellään osoitteille tai metodeille.</p>



          <h3>Autentikaatio ja autorisointi Springissä</h3>


          <p>Spring tarjoaa erillisen tietoturvakomponentin, jota voi käyttää myös web-sovelluksissa. Koska Spring on komponenttipohjainen sovelluskehys, myös tietoturvaan liittyvät komponentit tulee lisätä käyttöä varten. Lisätään ensin <code>pom.xml</code>-tiedostoon tietoturvaan liittyvät riippuvuudet. Otamme tässä vaiheessa myös käyttöön muutamia myöhemmin tarvitsemiamme palasia. Koska Spring Securityn omaan konfiguraatioon on määritelty hieman vanhemmat Spring-riippuvuudet, pidämme sen riippuvuudet melko alhaalla <code>pom.xml</code>-tiedostoa. Tällöin aiemmin määritellty riippuvuudet hakevat nykyaikaiset versiot, ja vanhemmat versiot jäävät hakematta.</p>

<pre class="sh_xml">
        &lt;dependency&gt;
            &lt;groupId&gt;org.springframework.security&lt;/groupId&gt;
            &lt;artifactId&gt;spring-security-web&lt;/artifactId&gt;
            &lt;version&gt;3.1.2.RELEASE&lt;/version&gt;
        &lt;/dependency&gt;
        &lt;dependency&gt;
            &lt;groupId&gt;org.springframework.security&lt;/groupId&gt;
            &lt;artifactId&gt;spring-security-config&lt;/artifactId&gt;
            &lt;version&gt;3.1.2.RELEASE&lt;/version&gt;
        &lt;/dependency&gt;
        &lt;dependency&gt;
            &lt;groupId&gt;org.springframework.security&lt;/groupId&gt;
            &lt;artifactId&gt;spring-security-taglibs&lt;/artifactId&gt;
            &lt;version&gt;3.1.2.RELEASE&lt;/version&gt;
        &lt;/dependency&gt;
</pre>

          <p>Spring tarjoaa oman filtterin, joka on hieman kuten aiemmin itse luomamme filtteri. Konfiguroidaan se <code>web.xml</code>-tiedostoon. Jotta filtterille voidaan ladata tietoturvakonfiguraatio, tulee <code>web.xml</code>-tiedostoon määritellä myös konfiguraation sijainti sekä erillinen kuuntelija konfiguraation latausta varten. Käytännössä filtteri on erillinen muusta palvelinohjelmistosta, joten sitä ei konfiguroida osana <code>front-controller-servlet.xml</code>-tiedostoa.</p>

<pre class="sh_xml">
    &lt;!-- ... --&gt;    
    &lt;display-name&gt;sovelluksen-nimi&lt;/display-name&gt;  
    
    &lt;!-- Tietoturvafiltteri. Huom! Filtterin nimen tulee olla täsmälleen tämä. --&gt;
    &lt;filter&gt;
        &lt;filter-name&gt;springSecurityFilterChain&lt;/filter-name&gt;
        &lt;filter-class&gt;org.springframework.web.filter.DelegatingFilterProxy&lt;/filter-class&gt;
    &lt;/filter&gt;
    &lt;filter-mapping&gt;
        &lt;filter-name&gt;springSecurityFilterChain&lt;/filter-name&gt;
        &lt;url-pattern&gt;/*&lt;/url-pattern&gt;
    &lt;/filter-mapping&gt;
    
    &lt;!-- Ladataan konteksti ja tietoturvakonfiguraatio --&gt;
    &lt;listener&gt;
        &lt;listener-class&gt;org.springframework.web.context.ContextLoaderListener&lt;/listener-class&gt;
    &lt;/listener&gt;

    &lt;!-- kerrotaan tietoturvakonfiguraation sijainti yllä määritellylle kontekstin lataajalle. --&gt;
    &lt;context-param&gt;
        &lt;param-name&gt;contextConfigLocation&lt;/param-name&gt;
        &lt;param-value&gt;/WEB-INF/security.xml&lt;/param-value&gt;
    &lt;/context-param&gt;

    &lt;!-- Filtteri: Kaikki pyynnöt utf-8:ksi --&gt;
    &lt;!-- ... --&gt;    
</pre>


          <p>Tämän lisäksi tarvitsemme erillisen tietoturvakonfiguraation. Lisätään kansioon <code>WEB-INF</code> tiedosto <code>security.xml</code>, jossa on tietoturvakonfiguraatio. Alla olevassa konfiguraatiossa määrittelemme pääsynvalvonnan osoitteisiin, sekä käyttäjätunnusten hallinnan. Polkuun <code>pub</code> ja sen alipolkuihin on pääsy kaikilta, kun taas polku <code>hidden</code> ja sen alipolut vaativat autentikoitumista (<code>isAutenticated()</code>). Juuripolku on kaikille sallittu, ja loput poluista on kielletty kaikilta. Lisäksi määrittelemme että Spring security hoitaa kirjautumissivun ja logout-osoitteen. Kirjautumissivu on automaattinen, sovelluksesta voi poistua tekemällä (oletuksena) pyynnön osoitteeseen <code>http://osoite-ja-sovellus/j_spring_security_logout</code>.</p>


          <p>Tämän lisäksi tiedostossa määritellään kaksi käyttäjätunnusta, "el_barto" ja "turjakas" sekä niiden salasanat. Käyttäjätunnuksille määritellään lisäksi roolit <code>authorities</code>-attribuutilla. Esimerkiksi käyttäjätunnuksella <code>el_barto</code> on sekä <code>admin</code>-rooli, että <code>ope</code>-rooli. Polkuihin voi määritellä autentikoinnin lisäksi pääsyn myös roolien perusteella. Esimerkiksi <code>intercept-url</code>-elementille lisätty attribuutti <code>access="hasRole('admin')"</code> vaatii, että roolina on <code>admin</code>. Vastaavasti useita rooleja voi määritellä sanomalla <code>access="hasAnyRole('admin','ope')"</code>.</p>


<pre class="sh_xml">
&lt;?xml version="1.0" encoding="UTF-8"?&gt;
&lt;beans xmlns="http://www.springframework.org/schema/beans"
       xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"        
       xmlns:sec="http://www.springframework.org/schema/security"
       xsi:schemaLocation="http://www.springframework.org/schema/beans
                            http://www.springframework.org/schema/beans/spring-beans-3.1.xsd
                            http://www.springframework.org/schema/security 
                            http://www.springframework.org/schema/security/spring-security-3.1.xsd"&gt;
    
    &lt;sec:http use-expressions="true"&gt;
        &lt;sec:intercept-url pattern="/pub/**" access="permitAll" /&gt;
        &lt;sec:intercept-url pattern="/hidden/**" access="isAuthenticated()" /&gt;
        &lt;sec:intercept-url pattern="/" access="permitAll" /&gt;
        &lt;sec:intercept-url pattern="/**" access="denyAll" /&gt;
        &lt;sec:form-login /&gt;
        &lt;sec:logout /&gt;
    &lt;/sec:http&gt;

    &lt;sec:authentication-manager&gt;
        &lt;sec:authentication-provider&gt;
            &lt;sec:user-service&gt;
                &lt;sec:user name="el_barto" password="arto" authorities="admin,ope" /&gt;
                &lt;sec:user name="turjakas" password="mikke" authorities="ope" /&gt;
            &lt;/sec:user-service&gt;
        &lt;/sec:authentication-provider&gt;
    &lt;/sec:authentication-manager&gt;
&lt;/beans&gt;
</pre>


<div class="tehtavat">

  <h3>You Shall Not Pass!</h3>

  <p>Projektin pohjaan on konfiguroitu Spring Securityn vaatima filtteritoiminnallisuus. Kansion <code>WEB-INF</code> alla olevassa tiedostossa <code>security.xml</code> on määritelty pääsyrajaukset ja käyttäjätunnukset. Nykyisessä konfiguraatiossa sekä juuripolku että tiedosto <code>index.jsp</code> on sallittu kaikille. Tiedostossa on myös määritelty käyttäjä <code>mikael</code>, jonka salasana on <code>rendezvous</code>.</p>

  <p>Muokkaa konfiguraatiota siten, että aiemman konfiguraation lisäksi osoitteeseen <code>public</code> ja sen alipolkuihin on pääsy kaikilta. Osoitteiden <code>app</code> ja <code>secret</code> alipolkuihin vaaditaan käyttäjärooli <code>user</code>. Pääsy kaikkiin muihin polkuihin tulee kieltää.</p>

  <p>Lisää sovellukseen myös käyttäjä <code>kasper</code> roolilla <code>user</code>. Käyttäjän <code>kasper</code> salasana on <code>spring</code>.</p>

  <p>Kun olet muokannut konfiguraatiota, testaa sovellustasi ja lähetä se TMC:lle.</p>
</div>


          <h4>Näkymätason autorisointi</h4>


          <p>Autorisointi pelkkien polkujen perusteella ei aina riitä. Käyttöliitymissä halutaan esimerkiksi tarjota käyttäjäroolikohtaista toiminnallisuutta. Aiemmin lisäämämme riippuvuus <code>spring-security-taglibs</code> tarjoaa näkymissä käytettävän tägikirjaston, jonka perusteella sivun eri osa-alueiden näkymistä voidaan rajoittaa käyttäjäkohtaisesti.</p> 

<pre class="sh_xml">
        &lt;dependency&gt;
            &lt;groupId&gt;org.springframework.security&lt;/groupId&gt;
            &lt;artifactId&gt;spring-security-taglibs&lt;/artifactId&gt;
            &lt;version&gt;3.1.2.RELEASE&lt;/version&gt;
        &lt;/dependency&gt;
</pre>

          <p>Tägikirjaston saa käyttöön JSP-sivulla lisäämällä sivun alkuun seuraavan rivin, joka määrittelee nimiavaruuden <code>sec</code> tägikirjastoille.</p>

<pre class="sh_xml">
&lt;%@ taglib prefix="sec" uri="http://www.springframework.org/security/tags" %&gt;
</pre>

          <p>Nyt JSP-sivuilla voi määritellä alueita, joiden näkyminen vaatii tietyn roolin. Esimerkiksi vain <code>admin</code>-roolille näkyvä linkki määritellään <code>sec</code>-nimiavaruudessa olevan elementin <code>authorize</code> avulla seuraavasti:</p>

<pre class="sh_xml">
        &lt;!-- sivun muuta sisältöä --&gt;

        &lt;sec:authorize access="hasRole('admin')"&gt;
            &lt;a href="${pageContext.request.contextPath}/admin/"&gt;Admin pages&lt;/a&gt;
        &lt;/sec:authorize&gt;

        &lt;!-- sivun muuta sisältöä --&gt;
</pre>

          <p>Attribuutti <code>access</code> määrittelee käytössä olevat roolit. Attribuutille käy mm. arvot <code>isAuthenticated()</code>, <code>hasRole('...')</code> ja <code>hasAnyRole('...')</code>.</p>



          <h4>Metoditason autorisointi</h4>


          <p>Näkymätason autorisointi ei myöskään aina riitä. Usein halutaan rajoittaa toiminnallisuutta siten, että tietyt operaatiot (esim. poisto tai lisäys) halutaan mahdollistaa vain tietyille rooleille. Käyttöliittymän näkymää rajoittamalla ei voida rajoittaa kutsuja polkuihin, ja aiemmin luotu polkuihin tehtävien kutsujen rajoitus ei auta esimerkiksi REST-tyyppisissä osoitteissa, varsinkin jos GET-pyyntöihin halutaan oikeus kaikille.</p>

          <p>Sovelluskehykset tarjoavat usein myös metoditason autorisoinnin. Esimerkiksi Springissä metoditason autorisointi hoidetaan annotaatioilla: metodeille määritellään annotaatiot, jotka kertovat käytetyt rajoitukset. Koska metoditason autorisointi tapahtuu web-sovelluksen sisällä, tulee se konfiguroida osana <code>front-controller-servlet.xml</code>-tiedostoa (tai vastaavassa). Komento <code>sec:global-method-security pre-post-annotations="enabled"</code> lisää käyttöömme annotaatiot, joilla voimme rajata metodien käyttöä esimerkiksi käyttäjäroolien perusteella.</p>

<pre class="sh_xml">
        &lt;!-- ... --&gt;
        xmlns:sec="http://www.springframework.org/schema/security"
        &lt;!-- ... --&gt;
                            http://www.springframework.org/schema/security 
                            http://www.springframework.org/schema/security/spring-security-3.1.xsd
                            &lt;!-- ... --&gt;
        &lt;!-- ... --&gt;       
        &lt;sec:global-method-security pre-post-annotations="enabled" /&gt;
        &lt;!-- ... --&gt;
</pre>

          <p>Kun konfiguraatiotiedostoon on lisätty rivi <code>sec:global-method-security pre-post-annotations="enabled"</code>, on käytössämme mm. annotaatio <code>@PreAuthorize</code>, jolla voidaan määritellä roolit, jotka käyttäjällä tulee olla metodin suorittamiseen. Esimerkiksi annotaatio <code>@PreAuthorize("hasRole('ope')")</code> vaatii, että käyttäjän tulee olla kirjautunut roolissa <code>ope</code>, jotta annotoidun metodin suoritus onnistuu. Annotaatioon <code>@PreAuthorize</code> voidaan määritellä parametrina samoja komentoja kuin aiemminkin, esim. arvot <code>isAuthenticated()</code>, <code>hasRole('...')</code> ja <code>hasAnyRole('...')</code> ovat käytössä. Koska samalla komponentilla voi olla useita toteutuksia, tulee annotaatiot asettaa osaksi rajapintaa.</p>

<div class="tehtavat">

  <h3>Tiitinen List</h3>

  <p>Tiitisen lista on Supon 1990-luvulla saama lista henkilöistä, joiden uskotaan olleen vuorovaikutuksessa Stasin edustajan kanssa. Jatkokehitämme tässä Supon tietojärjestelmää, jotta saamme listan näkyville myös medialle.</p>

  <h4>Medialle näytettävä sivu</h4>

  <p>Lisää konfiguraatiotiedostoon <code>security.xml</code> käyttäjätunnus <code>media</code> jonka salasana on <code>media</code>, ja jonka rooli on <code>media</code>.</p>

  <p>Muokkaa tämän jälkeen kansiossa <code>WEB-INF/jsp</code> olevaa sivua <code>page.jsp</code> siten, että käyttäjäroolissa <code>media</code> sivulla <code>page.jsp</code> nähdään oikean listan tilalla kovakoodattu lista (myös lisäyslomake on piilossa):</p>

<pre class="sh_xml">
            &lt;ul&gt;
                &lt;li&gt;Susanna Reinboth&lt;/li&gt;
            &lt;/ul&gt;
</pre>

  <p>Kun käyttäjä kirjautuu sivulle rooleissa <code>admin</code> tai <code>supo</code> sivu käyttäytyy kuten ennen, eli käyttäjälle näytetään tiitisen listan sisältö. Jos käyttäjällä on rooli <code>admin</code>, voi listalla olevia asioita myös poistaa.</p>

  
  <h4>Tarkempi pääsynvalvonta</h4>

  <p>Huomaat järjestelmää jatkokehittäessäsi, että vaikka roolille <code>supo</code> ei näytetä DELETE-nappia, voi kuka tahansa sivuille kirjautunut tehdä HTTP-pyynnön listaelementtien poistamista hallinnoivaan osoitteeseen onnistuneesti. Kun lisäsit <code>media</code>-käyttäjätunnuksen, myös media voi lisätä tai poistaa listan elementtejä sopivia HTTP-pyyntöjä tekemällä  -- vaikkakaan itse listan sisältö ei heille näy.</p>

  <p>Korjataan tämä ongelma.</p>

  <p>Muokkaa <code><em>front-controller-servlet.xml</em></code>-tiedostoa siten, että annotaatioilla toimiva metoditason pääsynvalvonta kytketään päälle.</p>

  <p>Lisää tämän jälkeen listapalveluun annotaatiot, joilla rajoitetaan metodien kutsuoikeuksia. Metodia <code>create</code> kutsuttaessa tulee olla kirjautunut joko roolilla <code>admin</code> tai <code>supo</code>, metodin <code>remove</code> tulee toimia vain jos käyttäjä on kirjautunut roolilla <code>admin</code>.</p>

  <p>Kun olet valmis, testaa sovellustasi ja lähetä se TMC:lle.</p>

</div> 

                 <h4>Käyttäjien hakeminen tietokannasta</h4>

                 <p>Käyttäjien hakeminen tietokannasta tai muusta palvelusta onnistuu muuttamalla <code>security.xml</code>-tiedostossa olevaa konfiguraatiota. Esimerkiksi jos käytössämme on <code>USERS</code>- ja <code>ROLES</code>-taulut, voimme käyttää erillistä JDBC-yhteyttä käyttäjätunnusten hakemiseen. Kysely tulee toki muokata vastaamaan käytössä olevaa tietokantarakennetta.</p>

<pre class="sh_xml">
    &lt;!-- ... --&gt;

    &lt;sec:authentication-manager&gt;
        &lt;sec:authentication-provider&gt;
            &lt;sec:jdbc-user-service data-source-ref="dataSource"
                    users-by-username-query="SELECT name,password,enabled FROM USERS WHERE name=?" 
                    authorities-by-username-query="SELECT u.name, r.authority from USERS u, ROLES r
                      where u.user_id = r.user_id and u.name =?  "/>
        &lt;/sec:authentication-provider&gt;
    &lt;/sec:authentication-manager&gt;
    &lt;!-- ... --&gt;
</pre>

          <p>Jos pääsynhallinnan haluaa toteuttaa itse, tarjoaa Spring Security tarjoaa rajapinnan <code>UserDetailsService</code>, joka tulee toteuttaa omaa palvelua toteuttaessa. Kts. esim <a href="https://github.com/avihavai/wad-2012/blob/master/v6-runko-db/src/main/java/wad/spring/service/WadUserDetailsService.java" target="_blank">https://github.com/avihavai/wad-2012/blob/master/v6-runko-db/src/main/java/wad/spring/service/WadUserDetailsService.java</a>.</p>

          <p>Lisää tietoa tietokannan käytöstä osana autentikaatiota löytyy <a href="http://static.springsource.org/spring-security/site/docs/current/reference/springsecurity-single.html" target="_blank">Spring Securityn dokumentaatiosta</a>.</p>


          <h3>HTTPS</h3>

          <p>Usein kommunikointi selaimen ja palvelimen välillä halutaan salata, erityisesti salasanojen lähetyksen yhteydessä.</p>
          
          <p>HTTPS on HTTP-pyyntöjä SSL (nykyisin myös TLS)-rajapinnan yli. HTTPS mahdollistaa sekä käytetyn palvelun verifioinnin sertifikaattien avulla että lähetetyn ja vastaanotetun tiedon salauksen.</p>
          
          <p>HTTPS-pyynnöissä asiakas ja palvelin sopivat käytettävästä salausmekanismista ennen varsinaista kommunikaatiota. Käytännössä selain ottaa ensiksi yhteyden palvelimen HTTPS-pyyntöjä kuuntelevaan porttiin (yleensä 443), lähettäen palvelimelle listan selaimella käytössä olevista salausmekanismeista. Palvelin valitsee näistä parhaiten sille sopivan (käytännössä vahvimman) salausmekanismin, ja lähettää takaisin salaustunnisteen (palvelimen nimi, sertifikaatti, julkinen salausavain). Selain ottaa mahdollisesti yhteyttä sertifikaatin tarjoajaan -- joka on kolmas osapuoli -- ja tarkistaa onko sertifikaatti kunnossa.</p>

          <p>Selain lähettää palvelimelle salauksessa käytettävän satunnaisluvun palvelimen lähettämällä salausavaimella salattuna. Palvelin purkaa viestin ja saa haltuunsa selaimen haluaman satunnaisluvun. Viesti voidaan nyt lähettää salattuna satunnaislukua ja julkista salausavainta käyttäen.</p>

          <p>Käytännössä kaikki web-palvelimet tarjoavat HTTPS-toiminnallisuuden valmiina, joskin se täytyy ottaa palvelimilla käyttöön. Esimerkiksi Herokussa HTTPS:n saa käyttöön komennolla <code>heroku addons:add piggyback_ssl</code>. Lisätietoa Herokun SSL-tuesta osoitteessa <a href="http://devcenter.heroku.com/articles/ssl" target="_blank">http://devcenter.heroku.com/articles/ssl</a>.</p>



          <h2>Internationalisointi ja lokalisointi</h2>
          
          <p>Internationalisoinnilla (<code>i18n</code>) tarkoitetaan sovelluksen rakentamista siten, että sen toteuttaminen usealla kielellä on mahdollista. Lokalisoinnilla (<code>l10n</code>) taas tarkoitetaan yksttäiselle kieli- tai kulttuurialueelle tehtävää kielitoteutusta.</p>

          <p>Sovellusta internatinalisoidessa luodaan oletuskieli, joka ylikirjoitetaan erillisillä lokalisaatioilla. Sovelluksessa lopulta käytettävän kielen valinta tapahtuu ympäristön tai erillisen parametrin avulla. Esimerkiksi Javassa on käytössä <code><a href="http://docs.oracle.com/javase/6/docs/api/java/util/Locale.html" target="_blank">Locale</a></code>-luokka, joka sisältää määrittelyt eri maiden kielille.</p>

          <p>Käytännössä internationalisaatio alkaa määrittelemällä sovellukseen viestikohtaiset tägit. Tägeille tehdään kielikohtaiset resurssitiedostot, josta kielikohtaiset tekstit haetaan tägien paikalle. Lokalisoidun käyttöliittymän luominen tapahtuu siis käytännössä tägien ja resurssitiedostojen perusteella.</p>

          <p>Javassa on valmiina <code><a href="http://docs.oracle.com/javase/6/docs/api/java/util/ResourceBundle.html" target="_blank">ResourceBundle</a></code>-luokka, jota voi käyttää resurssien hakemiseen. Käytännössä resurssit ovat kielikohtaisissa <code>properties</code>-tiedostoissa. Esimerkiksi luokan <code>ResourceBundle</code> staattisella metodilla <code>getBundle</code> haetaan resursseja tietyllä kielellä.</p>

<pre class="sh_java">
    ResourceBundle resources = ResourceBundle.getBundle("resources", new Locale("fi", "FI"));
</pre> 

          <p>Hakee suomenkielisiä resursseja resources-tiedostosta. Käytännössä käytettävän tiedoston nimi yritetään päätellä annettavista parametreista, tarkempi sopivan tiedoston päättelyn kuvaus löytyy <a href="http://docs.oracle.com/javase/6/docs/api/java/util/ResourceBundle.html#getBundle(java.lang.String,%20java.util.Locale,%20java.lang.ClassLoader)" target="_blank">getBundle</a>-metodin API-kuvauksesta.</p>


          <p>Lokalisaatiotiedoston <code>resources_fi.properties</code> sisältö voi olla esimerkiksi seuraavanlainen:</p>
<pre>
welcome=Tervetuloa {0}!
currentTime=Tänään on {0} ja kello on {1}.
</pre>

          <p>Aaltosuluilla merkityillä tägeillä merkitään kohdat, johon voidaan lisätä muita parametreja. Esimerkiksi viestin <code>welcome</code> näyttäminen onnistuu <code>MessageFormatter</code>-luokan avulla seuraavasti.</p>

<pre class="sh_java">
    Locale locale = new Locale("fi", "FI");
    ResourceBundle resources = ResourceBundle.getBundle("resources", locale);
    MessageFormat formatter = new MessageFormat("");
    formatter.setLocale(locale);
 
    formatter.applyPattern(messages.getString("welcome"));
    String output = formatter.format(new Object[] {"Arto"});

    System.out.println(output);
</pre>
          <p>Tulostus näyttää seuraavalta:</p>

<pre>
Tervetuloa Arto!
</pre>

          <p>Koska dependency injection on jees, ja tämänkin voi tehdä hieman helpommin, käytämme jatkossa Springiä.</p>

          <h3>Spring-sovellusten lokalisointi</h3>

          <p>Spring tarjoaa erillisen luokan viestien hakemiseen. Luokka <code><a href="http://static.springsource.org/spring/docs/current/javadoc-api/org/springframework/context/support/ResourceBundleMessageSource.html" target="_blank">ResourceBundleMessageSource</a></code> osaa hakea tarvittavat resurssitiedostot sille konfiguroitavasta polusta. Esimerkiksi alla määrittelemme, että lokalisaatiotiedostot alkavat sanalla <code>resources</code> ja sijaitsevat sovelluksen juuripolussa. Käytännössä lokalisaatiotiedostot (esim. <code>resources_fi.properties</code>) asetettaisiin kansioon <code>src/main/resources</code>, josta ne kopioidaan sovellusta käännettäessä oikeaan paikkaan.</p>

<pre class="sh_xml">
    &lt;bean id="messageSource" class="org.springframework.context.support.ResourceBundleMessageSource"&gt;
        &lt;property name="basename"&gt;
            &lt;value&gt;resources&lt;/value&gt;
        &lt;/property&gt;
    &lt;/bean&gt;
</pre>
          

          <p>Nyt Springillä on käytössä viestien lataamiseen tarvittava luokka. Jos sovellus ladataan oliokontekstin kautta, voi sen injektoida osaksi sovellusta.</p>

<pre class="sh_java">
@Component
public class MyApplication {
    private Locale locale;
    @Autowired
    private MessageSource messageSource;

    public void setLocale(Locale locale) {
        this.locale = locale;
    }

    // ...
}
</pre>

          <p>Itse viestien käyttäminen on myös hieman helpompaa. Sovellus lataa käynnistyessään <em>kaikki</em> lokalisoidut tiedostot ja käytettävän tekstin päättely tapahtuu koodissa. Esimerkiksi aiemman <code>welcome</code>-tekstin tulostus tapahtuu seuraavasti:</p>

<pre class="sh_java">
    // ...
    String name = "Arto";
    System.out.println(messageSource.getMessage("welcome", new Object[] { name }, locale));
    // ...
</pre>

          <p>Tulostettaville viesteille määritellään siis oma tägi, käytettävät parametrit, ja käytettävä kieli.</p>

          
<div class="tehtavat">

  <h3>Gissningslek!</h3>

  <p>Tuttusi on koodannut ohjelmoinnin peruskurssilla binäärihakua simuloivan arvauspelin. Hänen ulkomaiset kaverinsa eivät kuitenkaan millään ymmärtäneet pelin ideaa, koska peli toimii ainoastaan suomen kielellä. Koska olet jo huomattavasti edistyneempi ohjelmoija, pyysi tuttusi kääntämään pelin myös ruotsin ja englannin kielelle.</p>

  <p>Tehtäväpohjassa on valmis arvauspeli, jossa on kiinteät suomenkieliset tekstit.</p>

  <h4>Kansainvälistämisen konfigurointi</h4>

  <p>Konfiguroi Springille <code>org.springframework.context.support.ResourceBundleMessageSource</code>-bean tunnuksella <code>messageSource</code>, joka etsii käännöstekstejä haluamastasi polusta. Voit itse valita minkä nimisiin tiedostoihin talletat tekstit.</p>

  <h4>Käännöstekstien luominen</h4>

  <p>Käännöstiedostojen viestien avaimet on määritelty etukäteen ja ne ovat seuraavat (suomenkielisillä esimerkeillä):
    <ul>
      <li><code>game.thinkNumber</code>: Ajattele jotain lukua väliltä 0...100.</li>
      <li><code>game.promiseGuess</code>: Lupaan pystyä arvaamaan ajattelemasi luvun 7 kysymyksellä.</li>
      <li><code>game.answerQuestions</code>: Esitän sinulle seuraavaksi sarjan kysymyksiä. Vastaa niihin rehellisesti.</li>
      <li><code>game.question</code>: Onko lukusi suurempi kuin 50? (k/e)</li>
      <li><code>game.answer.yes</code>: k</li>
      <li><code>game.guessedNumber</code>: Ajattelemasi luku on 28.</li>
    </ul>
  </p>

  <p>Voit tarkistaa suomenkieliset tekstit ja niiden käyttötavan tehtäväpohjan luokasta <code>wad.gissningslek.CommandLineGuessingGame</code>.</p>

  <p>Luo ohjelmalle käännöstekstitiedostot suomen, ruotsin ja englannin kielelle esimerkkien mukaisesti. Muista käyttää tiedostojen nimissä kielien kaksikirjaimisia tunnuksia. Kiinnitä huomiota paikkoihin, joissa tarvitset viestien interpolaatiota (<code>{n}</code>-merkinnöillä). Ole tarkka kirjoitusasun ja etenkin välilyöntien suhteen, sillä tehtävässä edellytetään täsmälleen oikeita vastauksia!</p>

  <p>Ruotsinkielisen arvauspelin tulisi näyttää tältä:</p>
<pre>
Tänk på något tal i intervallet 0...100.
Jag lovar att klara av att gissa talet du tänkte på med 7 frågor.

Nu frågar jag dig en serie frågor. Svara dem ärligt.

Är ditt tal större än 50? (j/n)
n
Är ditt tal större än 25? (j/n)
n
Är ditt tal större än 12? (j/n)
j
Är ditt tal större än 19? (j/n)
j
Är ditt tal större än 22? (j/n)
n
Är ditt tal större än 21? (j/n)
j
Talet du tänkte på var 22.
</pre>

  <p>Englanninkielisen arvauspelin tulisi näyttää tältä:</p>
<pre>
Choose a number in interval 0...100.
I promise that I can guess the number you chose by asking you 7 questions.

I'm going to ask you a series of questions. Please answer them honestly.

Is the number greater than 50? (y/n)
y
Is the number greater than 75? (y/n)
n
Is the number greater than 63? (y/n)
n
Is the number greater than 57? (y/n)
y
Is the number greater than 60? (y/n)
n
Is the number greater than 59? (y/n)
n
Is the number greater than 58? (y/n)
n
The number you chose was 58.
</pre>

  <h4>Pelin kansainvälistäminen</h4>

  <p>Muokkaa tehtäväpohjan luokkaa <code>wad.gissningslek.CommandLineGuessingGame</code> siten, että haet kaikki tulostettavat tekstit <code>MessageSource</code>-rajapinnan avulla käyttäen luokalle annettua <code>locale</code>-määrittelyä. Pelin logiikkaa <strong>ei</strong> tule muuttaa.</p>

  <p>Voit vaihtaa ohjelman käyttämää kieltä muokkaamalla luokan <code>wad.gissningslek.Main</code> määrittämää localea.</p>

  <p><strong>Huom!</strong> Myös käyttäjältä vastaanotettava vastaus kysymykseen riippuu valitusta kielestä!</p>
</div>

          <h3>Web-sovellusten internationalisointi</h3>


          <p>Web-sovellusten internationalisointi tapahtuu samalla lähestymistavalla kuin komentorivisovelluksen lokalisointi. Käyttöliittymätekstit muutetaan tageiksi, ja lokalisoidut tekstit tallennetaan niille sopivaan paikkaan. Web-sovellusten lokalisointiin käytetään usein luokkaa <code><a href="http://static.springsource.org/spring/docs/current/javadoc-api/org/springframework/context/support/ReloadableResourceBundleMessageSource.html" target="_blank">ReloadableResourceBundleMessageSource</a></code>, joka toimii lähes samoin kuin aiemmin näkemämme <code>ResourceBundleMessageSource</code>. Itse konfiguraatio asetetaan osaksi <code>front-controller-servlet.xml</code>-tiedostoa.</p>

          <p>Alla on määritelty konfiguraatio, joka hakee <code>resources</code>-nimisiä resurssitiedostoja sovelluksen juuripolusta. Tiedostot kopioidaan juuripolkuun kansiosta <code>src/main/resources</code>. Tämän lisäksi konfiguraatiolle on määritelty oletusmerkistöksi <code>UTF-8</code>.</p>

<pre class="sh_xml">
    &lt;bean id="messageSource" class="org.springframework.context.support.ReloadableResourceBundleMessageSource"&gt;
        &lt;property name="basename" value="classpath:resources" /&gt;
        &lt;property name="defaultEncoding" value="UTF-8" /&gt;
    &lt;/bean&gt;
</pre>

          <p>Jotta web-sovellus osaisi pitää kirjaa käytettävästä kielestä, tallennetaan valittu kieli evästeeseen. Spring tarjoaa tähän tarkoitukseen valmiin luokan <code><a href="http://static.springsource.org/spring/docs/current/javadoc-api/org/springframework/web/servlet/i18n/CookieLocaleResolver.html" target="_blank">CookieLocaleResolver</a></code>. Alla olevassa konfiguraatiossa on lisäksi määritelty oletuskieleksi englanti.</p>

<pre class="sh_xml">
    &lt;bean id="localeResolver" class="org.springframework.web.servlet.i18n.CookieLocaleResolver"&gt;
        &lt;property name="defaultLocale" value="en" /&gt;
    &lt;/bean&gt;
</pre>

          <p>Sovelluksen kielen vaihtaminen onnistuu helposti lisäämällä ylimääräinen pyynnön käsittelijä. Web-sovelluksiin kohdistuviin pyyntöihin voidaan määritellä (Javan standardilähestymistavan, eli filttereiden) lisäksi interceptor-olioita. Luokka <code><a href="http://static.springsource.org/spring/docs/current/javadoc-api/org/springframework/web/servlet/i18n/LocaleChangeInterceptor.html" target="_blank">LocaleChangeInterceptor</a></code> prosessoi palvelimelle tulevat pyynnöt, ja vaihtaa kieltä tarvittaessa. Käytännössä kielen vaihto tapahtuu esimerkiksi lisäämällä polkuun parametri <code>locale</code>. Esimerkiksi pyyntö osoitteeseen <code>http://..sovellusjne../polku?locale=fi</code> vaihtaa kieleksi suomen.</p>
    
<pre class="sh_xml">
    &lt;mvc:interceptors&gt;
        &lt;bean id="localeChangeInterceptor" class="org.springframework.web.servlet.i18n.LocaleChangeInterceptor" /&gt;
    &lt;/mvc:interceptors&gt;
</pre>

          <p>Internationalisointia varten tarvitsemme myös erillisen tägin käyttöliittymän viestien asetukseen. Spring tarjoaa tähän valmiin tägikirjaston.</p> 
    
<pre class="sh_xml">
<%@taglib prefix="spring" uri="http://www.springframework.org/tags" %>
</pre>

    <p>Tägikirjastoa käytetään seuraavasti. Attribuutin <code>code</code> arvo on aina näytettävän viestin avain. Attribuutille <code>code</code> lisätään argumentteja attribuutin <code>arguments</code> avulla.</p>
    
<pre class="sh_xml">
    &lt;spring:message code="welcome" arguments="${name}"/&gt;
</pre>

<div class="tehtavat">

  <h3>Parlez vous Français?</h3>
  
  <p>Euroopan Unionin kielikomissio haluaa selvittää kuinka monta EU-jäsenmaan kansalaista osaa puhua ranskaa. Web-sovellusta varten on luotu prototyyppi, johon on kovakoodattu englanninkielinen versio sovelluksesta. Hyvä ystäväsi Jean-Jacques-Antoine Courtois on myös ystävällisesti suunnitellut kielitiedostoissa käytettävät avaimet ja tehnyt ranskankielisen käännöksen sovellukseen vaadittavista ranskankielisistä viesteistä. Löydät tiedoston Netbeansistä Other Sources-kansion alta polusta <code>src/main/resources/bundles/messages_fr.properties</code>.</p>


  <h4>Konfiguraatio</h4>

  <p>Muokkaa konfiguraatiotiedostoa <code>front-controller-servlet.xml</code> ja lisää sinne seuraavat konfiguraatiot:</p>

  <ul>
    <li>Konfiguroi bean <code>org.springframework.context.support.ReloadableResourceBundleMessageSource</code> ja aseta sille <code>basename</code>:ksi <code>classpath:bundles/messages</code> ja <code>defaultEncoding</code>:ksi <code>UTF-8</code></li>
    <li>Konfiguroi bean <code>org.springframework.web.servlet.i18n.CookieLocaleResolver</code> ja aseta sille <code>defaultLocale</code>:ksi englanti</li>
    <li>Konfiguroi Springin <code>mvc:interceptors</code>:eihin bean <code>org.springframework.web.servlet.i18n.LocaleChangeInterceptor</code></li>
  </ul>
  
  <p>Ensimmäinen konfiguraatio mahdollistaa uudestaan ladattavien property-tiedostojen (tässä tapauksessa kielitiedostojen) käytön. Toinen konfiguraatio asettaa nykyisen lokaalin evästeen avulla ja kolmas konfiguraatio vaihtaa lokaalin (ja evästeen) kun sovelluksessa mihin tahansa polkuun lisätään parametri <code>?locale=KIELIKOODI</code>.</p>
          
  <h4>Näkymien internationalisointi</h4>
          
  <p>Sinun täytyy tehdä lokalisaatiotiedostot suomen- ja englanninkielistä lokalisaatiota varten. Katso mallia tarjotusta ranskankielisestä lokaalisaatiotiedostosta. Lokalisoi nyt näkymät <code>question.jsp</code>, <code>yes.jsp</code> ja <code>no.jsp</code> käyttämään tiedostoissa määritettyjä viestejä.</p>
 
  <p>Testaa lopuksi sovellus huolellisesti selaimessa. Voit vaihtaa kielen lisäämällä mihin tahansa polkuun parametrin <code>?locale=KIELIKOODI</code>. Asetus muistetaan evästeen avulla.</p>

</div>


<h2>Makupala selainohjelmointiin</h2>


          <p>Huomattava osa nykyaikaisista web-palveluista lataavat käyttäjälle palvelimelta vain staattisen käyttöliittymän. Käyttöliittymä sisältää joukon JavaScript-komponentteja, jotka tuovat ja vievät dataa tarvittaessa käyttäjälle -- esimerkiksi JSON-muodossa. Seuraavassa tehtäväsarjassa toteutetaan palvelintoiminnallisuus erillisille selainpuolen sovellukselle. Tehtävän sovelluksessa käytettävää selainpuolen toiminnallisuutta toteutetaan näillä näkymin kurssin <code>Web-selainohjelmointi</code> noin viikolla 4.</p>

<div class="tehtavat">

<h3>Tökkel</h3>

<p><img src="img/w6e06/tokkel-screenshot-tasks.png" border=1/></p>

<p>Kurssin viimeisessä ohjelmointitehtävässä toteutetaan palvelinpuolen REST-rajapinta pienelle selaimessa toimivalle tehtävänhallintasovellukselle. Kuten huomaat ylläolevasta kuvakaappauksesta, sovelluksen käyttöliittymä alkaa muistuttaa jo enemmän nykyisiä web-sovelluksia pelkän mustan tekstin ja valkoisen taustan sijaan.</p>

<p>Sovelluksessa on kaksi eri näkymää: projektit (projects) ja tehtävät (tasks). Tehtäviä voi luoda tehtävälistaan täysin ilman projekteja tai luokitella niitä eri projektien alle. Tehtävän voi merkitä aloitetuksi, jolloin selain laskee sekunteja aloitusajankohdasta. Tehtävän lopettamisen jälkeen listauksessa näkyy tehtävän aloitus- ja lopetusaika.</p>

<p>Sovelluksen käyttöliittymä toimii lähes täysin eri tavalla kuin aiempien tehtävien käyttöliittymät: palvelimelta ei ladatakaan JSP-sivuja, vaan käyttöliittymän JavaScript-koodi kommunikoi suoraan palvelimen REST-rajapinnan kanssa JSON-muotoisilla viesteillä. REST-rajapinnan ja JSON-tietomuodon käyttö onkin yleistä nykyaikaisissa web-sovelluksissa juuri sen takia, että JavaScript-koodilla on helppo käyttää tällaista rajapintaa. Lisäksi selaimessa näytettävää sivua ei koskaan vaihdeta tai ladata uudelleen -- selaimen näyttämän sivun sisältöä ainoastaan muutetaan käyttäjän tekemien toimintojen perusteella.</p>

<p>Tehtäväpohjassa on valmiina ainoastaan JavaScriptillä ja HTML:llä tehty käyttöliittymä, jota ei tarvitse muuttaa. Loppu tehtävä on jätetty avoimeksi siten, että palvelinpuolen tulee toteuttaa käyttöliittymän vaatima REST-rajapinta projektien ja tehtävien hallinnointiin.</p>

<p><strong>Huom!</strong> Tämän tehtävän testit tarkistavat ainoastaan REST-rajapinnan toiminnan, joten (kuten jo useassa aiemmassakin tehtävässä) tehtävään kirjoitettua koodia ei tarkisteta mitenkään. Joudut siis käynnistämään sovelluksen itse ja kokeilemaan käyttöliittymää, jotta voit todeta mitkä ominaisuudet toimivat oikein ja saada tarvittaessa selkeitä virheilmoituksia poikkeustilanteista.</p>

<div class="pohdi">
  <p><strong>JavaScript- ja HTML-pohjaiset käyttöliittymät</strong></p>

  <p>Tökkel-sovelluksen käyttöliittymää ei suinkaan ole toteutettu kokonaan itse, vaan siinä käytetään lukuisia valmiita komponentteja:
    <ul>
      <li><a href="http://jquery.org/">jQuery</a> - toimii apuvälineenä sivun sisällön muuttamiseen</li>
      <li><a href="http://backbonejs.org/">Backbone.js</a> - hallinnoi ohjelman logiikkaa, siirtymiä näkymien välillä ja kommunikaatiota palvelimen kanssa</li>
      <li><a href="http://twitter.github.com/bootstrap/">Twitter Bootstrap</a> - Twitterin kehittämä kirjasto, joka tarjoaa valmiita käyttöliittymäkomponentteja, kuten nappeja ja valikoita</li>
      <li><a href="https://github.com/janl/mustache.js">Mustache.js</a> - mahdollistaa selainpohjaisen käyttöliitymän kokoamisen lyhyistä HTML-kuvauskielen paloista (template)</li>
    </ul>
  </p>
</div>

<h4>Projektien hallinta</h4>

  <p>Tehtäväpohjassa on valmiina tyhjät pakkaukset ohjelman luokille aiempien tehtävien tapaan. Valmis Spring-konfiguraatio etsii Spring Data JPA:n repository-luokkia pakkauksesta <code>wad.tokkel.repositories</code>.</p>

  <p>Toteuta projektien hallintaan entiteetti, muut apuluokat, sekä controller-luokka, joka tarjoaa REST-rajapinnan projektien käsittelyyn:
    <ul>
      <li><code>POST /app/projects</code> luo uuden projektin ja palauttaa luodun projektin tiedot</li>
      <li><code>GET /app/projects</code> listaa kaikki talletetut projektit</li>
      <li><code>GET /app/projects/[id]</code> palauttaa yksittäisen projektin tiedot id-avaimen perusteella</li>
      <li><code>DELETE /app/projects/[id]</code> poistaa id-avaimen mukaisen projektin</li>
    </ul>
  </p>

  <p>Uusi projekti luodaan JSON-muotoisella pyynnöllä esimerkiksi näin:</p>

<pre>
{"name": "Wadillinen projekti"}
</pre>

  <p>Sovelluksen tallettama projekti näyttää esimerkiksi tältä:</p>

<pre>
{
    "id": 4,
    "name": "Wadillinen projekti",
    "creationTime": 1349682202493
}
</pre>

  <p>Attribuutti <code>creationTime</code> voidaan toteuttaa javassa <code>java.util.Date</code>-luokan avulla, kuten aiempienkin tehtävien aikaleimat.</p>

  <p>Projektien hallinnan pitäisi toimia käyttöliittymässä, joten testaa nyt ohjelmaa selaimessa!</p>

<h4>Tehtävien hallinta</h4>

  <p><strong>Huom!</strong> Tässä tehtävän kohdassa tehtäviä käsitellään vielä irrallaan projekteista eli tehtävää varten valittua projektia ei oteta vielä huomioon!</p>

  <p>Toteuta tehtävien hallintaan entiteetti, muut apuluokat, sekä controller-luokka, joka tarjoaa REST-rajapinnan tehtävien käsittelyyn:
    <ul>
      <li><code>POST /app/tasks</code> luo uuden tehtävän ja palauttaa luodun tehtävän tiedot</li>
      <li><code>GET /app/tasks</code> listaa kaikki talletetut tehtävät</li>
      <li><code>GET /app/tasks/[id]</code> palauttaa yksittäisen tehtävän tiedot id-avaimen perusteella</li>
      <li><code>DELETE /app/tasks/[id]</code> poistaa id-avaimen mukaisen tehtävän</li>
    </ul>
  </p>

  <p>Uusi tehtävä luodaan JSON-muotoisella pyynnöllä esimerkiksi näin:</p>

<pre>
{"description": "Keitä kahvia"}
</pre>

  <p>Sovelluksen tallettama tehtävä näyttää esimerkiksi tältä:</p>

<pre>
{
    "id": 5,
    "description": "Keitä kahvia"
}
</pre>

  <p>Kokeile nyt luoda ja tuhota tehtäviä selaimella sovelluksen käyttöliittymässä.</p>

<h4>Tiettyyn projektiin liittyvien tehtävien hallinta</h4>

  <p>Laajenna tehtävä-entiteettiä siten, että projekti voi sisältää tehtäviä. Tähän riittää yksisuuntainen viite tehtävästä projektiin, eli käytännössä tehtävän tulee ainoastaan tietää mihin projektiin se kuuluu.</p>

  <p>Muokkaa myös projektien poistamista siten, että projektia poistettaessa kaikki siihen kuuluvat tehtävät poistetaan.</p>

  <p>Laajenna tehtävien käsittelyyn käytettävää REST-rajapintaa seuraavilla toiminnoilla:
    <ul>
      <li><code>POST /app/projects/[id]/tasks</code> luo uuden tehtävän <code>id</code>-avaimen mukaiseen projektiin ja palauttaa luodun tehtävän tiedot</li>
      <li><code>GET /app/projects/[id]/tasks</code> listaa kaikki talletetut tehtävät id-avaimen mukaisesta projektista</li>
      <li><code>GET /app/projects/[projectId]/tasks/[taskId]</code> palauttaa yksittäisen tehtävän tiedot taskId-avaimen perusteella (projektin avainta ei ole pakko käyttää!)</li>
      <li><code>DELETE /app/projects/[projectId]/tasks/[taskId]</code> poistaa taskId-avaimen mukaisen tehtävän</li>
    </ul>
  </p>

  <p>Uusi tehtävä luodaan haluttuun projektiin JSON-muotoisella pyynnöllä esimerkiksi näin:</p>

<pre>
{
    "description": "Muista nukkua!"
}
</pre>

  <p><strong>Huom!</strong> Käyttöliittymän toteutuksen takia REST-rajapintaan täytyy tehdä yksi poikkeusratkaisu, jolla tehtäviä tulee voida liittää projekteihin myös seuraavalla tavalla:
    <ul>
      <li><code>POST /app/tasks</code> luo uuden tehtävän JSON-pyynnössä olevan <code>projectId</code>-avaimen mukaiseen projektiin ja palauttaa luodun tehtävän tiedot</li>
    </ul>
  </p>

  <p>Tässä poikkeustapauksessa  talletettavan tehtävän projektin avain tulee aina toimittaa JSON-pyynnössä kuten alla:</p>

<pre>
{
    "description": "Muista nukkua!",
    "projectId": 4
}
</pre>

  <p>Sovelluksen tulee siis lukea annettu <code>projectId</code>-attribuutti ja yhdistää tehtävä <code>projectId</code>-avaimen mukaiseen projektiin. Jos (kuten aiemmissa tehtävissä on neuvottu) käytät Springin <code>@RequestBody</code>-annotaatiota vastaanottamaan JSON-muotoisen pyynnön tiedot suoraan entiteettiolioon, on projektin avaimen vastaanottaminen mahdollista toteuttaa lisäämällä entiteettiin getter- ja setter-metodit pelkälle id-avaimelle. Tällöin myös palvelimen vaste tulee automaattisesti sisältämään projektin avaimen. Tarkoitus ei ole kuitenkaan tallettaa avainta erikseen tietokantaan, koska viittaus projektiin tulee tehdä käyttämällä JPA-annotaatioita. Jotta tiettyä oliomuuttujaa ei talletettaisi tietokantaan, voidaan se merkitä <code>@Transient</code>-annotaatiolla:</p>

<pre class="sh_java">
public class Task {
    // ...

    @Transient
    private Integer projectId;

    public Integer getProjectId() {
        return projectId;
    }

    public void setProjectId(Integer projectId) {
        this.projectId = projectId;
    }

    // ...
}
</pre>

  <p>Sovelluksen tallettama tehtävä näyttää esimerkiksi tältä (luotiin se kummalla tahansa tavalla yllämainituista):</p>

<pre>
{
    "id": 6
    "description": "Muista nukkua!",
    "projectId": 4
}
</pre>

  <p><strong>Huom!</strong> Tiettyyn projektiin kuuluvan tehtävän JSON-esityksen <strong>tulee aina sisältää</strong> <code>projectId</code>-attribuutti, myös tehtävälistausta tai yksittäisiä tehtäviä haettaessa.</p>

  <p>Kokeile nyt sovelluksen käyttöliittymässä lisätä tehtäviä projekteihin!</p>

<h4>Tehtävän aloittaminen ja lopettaminen</h4>

  <p>Lisätään sovellukseen lopuksi mahdollisuus merkitä tehtävä aloitetuksi ja lopetetuksi.</p>

  <p>Laajenna tehtävä-entiteettiä siten, että se sisältää tehtävän aloitusajan <code>startedTime</code> ja lopetusajan <code>stoppedTime</code>. Käytä jälleen <code>java.util.Date</code>-luokkaa aikaleimojen tallettamiseen.</p>

  <p>Laajenna tehtävien käsittelyyn käytettävää REST-rajapintaa seuraavilla toiminnoilla:
    <ul>
      <li><code>PUT /app/tasks/[taskId]</code> aloittaa tai lopettaa <code>taskId</code>-avaimen mukaisen tehtävän riippuen pyynnön sisällöstä</li>
      <li><code>PUT /app/projects/[projectId]/tasks/[taskId]</code> aloittaa tai lopettaa <code>taskId</code>-avaimen mukaisen tehtävän riippuen pyynnön sisällöstä (projektin avainta ei ole pakko käyttää!)</li>
    </ul>
  </p>

  <p>Aiemmin luotu tehtävä aloitetaan JSON-muotoisella PUT-pyynnöllä esimerkiksi osoitteeseen <code>/app/tasks/6</code>:</p>

<pre>
{"start": true}
</pre>

  <p>Palvelin palauttaa aloitetun tehtävän tiedot:</p>

<pre>
{
    "id": 6,
    "description": "Muista nukkua!",
    "startedTime": 1349684486981,
    "stoppedTime": null,
    "projectId": 4
}
</pre>

  <p>Paluuviestissä <code>startedTime</code> kertoo aloitusajankohdan. Lopetusajankohta <code>stoppedTime</code> on <code>null</code>-viite, koska tehtävää ei ole vielä lopetettu.</p>

  <p>Aiemmin aloitettu tehtävä lopetetaan JSON-muotoisella PUT-pyynnöllä esimerkiksi osoitteeseen <code>/app/tasks/6</code>:</p>

<pre>
{"stop": true}
</pre>

  <p>Palvelin palauttaa lopetetun tehtävän tiedot:</p>

<pre>
{
    "id": 6,
    "description": "Muista nukkua!",
    "startedTime": 1349684486981,
    "stoppedTime": 1349684668320,
    "projectId": 4
}
</pre>

  <p><strong>Huom!</strong> Voit toteuttaa <code>start</code>- ja <code>stop</code>-pyyntöjen vastaanottamisen vastaavasti kuin tehtävän edellisen kohdan <code>projectId</code>-avaimen väliaikaisen talletuksen käyttämällä <code>@Transient</code>-annotaatiota entiteetissä.</p>

  <p>Testaa lopuksi tehtävien aloitusta ja lopettamista sovelluksen käyttöliittymässä!</p>

</div>


<h2>Kurssikoe 16.10. 16:00-18:30, A111</h2>


          <p>Tekemisellä on ollut hyvin iso rooli kurssilla. Kurssin pisteistä 60% saa kurssin tehtävistä, loput kokeesta. Tämä tarkoittaa käytännössä sitä, että kurssilla vaadittu ohjelmointiosaaminen on varmistettu ja arvosteltu jo kurssin aikana. Ohjelmointi- tai konfigurointitehtäviä ei ole kokeessa. Kokeessa keskitytään teorian ja taustakäsitteiden ymmärryksen ja niiden selitystaidon varmistamiseen.</p>

          <p>Tiistain luennolla äänestetään kahdesta koevaihtoehdosta:</p>

          <p><strong>Vaihtoehto a</strong>) <em>Koepaperissa on 9 teoriakysymykstä, joista tulee vastata kuuteen. Yksittäisen vastauksen maksimipituus on 2 sivua ja yksittäisestä kysymyksestä voi saada maksimissaan 4 pistettä.</em></p>

          <p><strong>Vaihtoehto b</strong>) <em>Koepaperissa on 5 teoriakysymystä, joista tulee vastata neljään. Yksittäisen vastauksen maksimipituus on 4 sivua, ja yksittäisestä tehtävästä voi saada maksimissaan 6 pistettä.</em></p>

          <p>Kurssilla on käytössä koeleikkuri, joten kokeesta tulee saada yhteensä vähintään 12 pistettä.</p>

          <p>Kuvien piirtäminen on hyvin suositeltua kummassakin vaihtoehdossa. Luennolla valittiin vaihtoehto <strong><em>a</em></strong>, eli kokeessa tulee olemaan 9 teoriakysymystä, joista tulee vastata kuuteen.</p>

          <p>Luennolla pohdittiin myös sitä, millaisia tyypilliset koekysymykset voisivat olla. Osallistujilta tuli mm. seuraavia ehdotuksia:</p>

          <p>
            <ul>
              <li>Mikä on front-controller pattern ja mihin sitä käytetään? Mitä hyötyä siitä on?</li>
              <li>Miten web-sovelluksissamme käytetty MVC-malli poikkeaa työpöytäsovelluksissa käytettävästä MVC-mallista? Missä on Model, missä view, missä controller, ja miten ne kommunikoivat keskenään?</li>
              <li>Mikä on REST? Liittyykö se jotenkin nukkumiseen?</li>
            </ul>
          </p>
         

          <p><strong>Huom!</strong> Kokeessa tulee olemaan myös ylimääräinen tehtävä (max 6p). Ylimääräisellä tehtävällä voi korvata viikon, jolta on kerännyt vähiten pisteitä. Koe on kuitenkin ajoitettu siten, että ylimääräiseen tehtävään ei ole varsinaisesti aikaa. Vastaus ylimääräiseen tehtävään onnistunee jos varsinaisten vastausten jäsentelyyn ei tarvitse juurikaan käyttää aikaa. Ylimääräisestä tehtävästä saatuja pisteitä ei huomioida koeleikkurissa.</p>


<div class="tehtavat">

<h3>Kurssipalaute</h3>

<p>Käy antamassa kurssista palautetta laitoksen palautejärjestelmään. Mitä olisit toivonut enemmän, mitä vähemmän, mikä meni hyvin ja mitä pitäisi vielä parantaa? Palautejärjestelmän osoite on <a href="https://ilmo.cs.helsinki.fi/kurssit/servlet/Valinta" target="_blank">https://ilmo.cs.helsinki.fi/kurssit/servlet/Lomake</a></p>

<p>Koska palautteet ovat anoynyymejä, tästä tehtävästä ei saa pisteitä.</p>



</div>



</body>
</html>
