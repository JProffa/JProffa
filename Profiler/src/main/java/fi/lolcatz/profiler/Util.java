package fi.lolcatz.profiler;

import com.sun.tools.attach.VirtualMachine;
import static org.objectweb.asm.tree.AbstractInsnNode.*;

import java.io.DataOutputStream;
import java.io.File;
import java.io.FileOutputStream;
import java.lang.management.ManagementFactory;
import java.util.Iterator;
import java.util.Vector;
import java.util.logging.Level;
import java.util.logging.Logger;

import org.objectweb.asm.ClassReader;
import org.objectweb.asm.ClassWriter;
import org.objectweb.asm.Label;
import org.objectweb.asm.Opcodes;
import org.objectweb.asm.tree.*;

public class Util implements Opcodes {

    /**
     * Prints bytes as byte string with newline every 4 bytes.
     *
     * @param bytes Bytes to print.
     */
    public static void printBytes(byte[] bytes) {
        StringBuilder sb = new StringBuilder();
        int bytecounter = 1;
        for (byte b : bytes) {
            sb.append(String.format("%02X ", b));
            if (bytecounter % 4 == 0) {
                sb.append(System.getProperty("line.separator"));
            }
            bytecounter++;
        }
        System.out.println(sb.toString());
    }

    /**
     * Write byte array to file.
     *
     * @param filename Name of the file to write to.
     * @param bytes Byte array to write to file.
     */
    public static void writeByteArrayToFile(String filename, byte[] bytes) {
        try {
            DataOutputStream dout = new DataOutputStream(new FileOutputStream(new File(filename)));
            dout.write(bytes);
        } catch (Exception ex) {
            System.out.println(ex);
        }
    }

    /**
     * Create bytecode from ClassNode object.
     *
     * @param cn ClassNode to generate bytecode from.
     * @return Bytecode.
     */
    public static byte[] generateBytecode(ClassNode cn) {
        ClassWriter cw = new ClassWriter(0);
        cn.accept(cw);
        return cw.toByteArray();
    }

    /**
     * Init a ClassNode object using events generated by ClassReader from
     * <code>classFileBuffer</code>.
     *
     * @param classfileBuffer Class as byte[] to generate ClassNode from.
     * @return Initialized ClassNode object.
     */
    public static ClassNode initClassNode(byte[] classfileBuffer) {
        ClassNode cn = new ClassNode();
        ClassReader cr = new ClassReader(classfileBuffer);
        cr.accept(cn, 0);
        return cn;
    }

    public static void printInsnList(InsnList insns) {
        for (Iterator<AbstractInsnNode> iter = insns.iterator(); iter.hasNext();) {
            AbstractInsnNode node = iter.next();
            System.out.println("    " + getNodeString(node));
        }
    }

    public static String getNodeString(AbstractInsnNode node) {
        StringBuilder msg = new StringBuilder(getOpcodeString(node.getOpcode()) + " ");
        switch (node.getType()) {
            case LABEL:
                LabelNode labelNode = (LabelNode) node;
                Label label = labelNode.getLabel();
                msg.append("Label " + label.toString());
                break;
            case INSN:
                break;
            case LINE:
                LineNumberNode lineNumberNode = (LineNumberNode) node;
                msg.append("Line: " + lineNumberNode.line + ", Start: " + lineNumberNode.start.getLabel());
                break;
            case VAR_INSN:
                VarInsnNode varInsnNode = (VarInsnNode) node;
                msg.append(varInsnNode.var);
                break;
            case METHOD_INSN:
                MethodInsnNode methodInsnNode = (MethodInsnNode) node;
                msg.append(methodInsnNode.owner + "." + methodInsnNode.name + ":" + methodInsnNode.desc);
                break;
            case INT_INSN:
                IntInsnNode intInsnNode = (IntInsnNode) node;
                msg.append(intInsnNode.operand);
                break;
            case JUMP_INSN:
                JumpInsnNode jumpInsnNode = (JumpInsnNode) node;
                msg.append(jumpInsnNode.label.getLabel());
                break;
            case IINC_INSN:
                IincInsnNode iincInsnNode = (IincInsnNode) node;
                msg.append(iincInsnNode.var + ", " + iincInsnNode.incr);
                break;
            default:
                msg.append(node.toString());
                break;
        }
        return msg.toString();
    }

    public static String getOpcodeString(int opcode) {
        String s;
        switch (opcode) {
            case ALOAD:
                s = "ALOAD";
                break;
            case INVOKESPECIAL:
                s = "INVOKESPECIAL";
                break;
            case INVOKESTATIC:
                s = "INVOKESTATIC";
                break;
            case RETURN:
                s = "RETURN";
                break;
            case IRETURN:
                s = "IRETURN";
                break;
            case ICONST_M1:
                s = "ICONST_M1";
                break;
            case ICONST_0:
                s = "ICONST_0";
                break;
            case ICONST_1:
                s = "ICONST_1";
                break;
            case ICONST_2:
                s = "ICONST_2";
                break;
            case ISTORE:
                s = "ISTORE";
                break;
            case ILOAD:
                s = "ILOAD";
                break;
            case IINC:
                s = "IINC";
                break;
            case IADD:
                s = "IADD";
                break;
            case BIPUSH:
                s = "BIPUSH";
                break;
            case IF_ICMPGE:
                s = "IF_ICMPGE";
                break;
            case POP:
                s = "POP";
                break;
            case GOTO:
                s = "GOTO";
                break;
            case 0xFFFFFFFF:
                s = "FF";
                break;
            default:
                s = String.format("%02X", opcode);
                break;
        }
        return s;
    }

    public static void loadAgent() {
        String nameOfRunningVM = ManagementFactory.getRuntimeMXBean().getName();
        int p = nameOfRunningVM.indexOf('@');
        String pid = nameOfRunningVM.substring(0, p);
        System.out.println("VM pid: " + pid);
        try {
            VirtualMachine vm = VirtualMachine.attach(pid);
            vm.loadAgent("../Profiler/target/Profiler-1.0-SNAPSHOT.jar", "");
            vm.detach();
        } catch (Exception e) {
            throw new RuntimeException(e);
        }
        ClassLoader appLoader = ClassLoader.getSystemClassLoader();
        ClassLoader currentLoader = Util.class.getClassLoader();
        ClassLoader[] loaders = new ClassLoader[]{appLoader, currentLoader};
        try {
            final Class<?>[] classes = Util.class.getClasses();
            System.out.println("TROLL");
        } catch (Exception ex) {
            Logger.getLogger(Util.class.getName()).log(Level.SEVERE, null, ex);
        } 

    }
}

class ClassScope {

    private static java.lang.reflect.Field LIBRARIES;

    static {
        try {
            //LIBRARIES = ClassLoader.class.getDeclaredClasses();
            LIBRARIES.setAccessible(true);
        } catch (Exception ex) {
            Logger.getLogger(ClassScope.class.getName()).log(Level.SEVERE, null, ex);
        } 

    }

    public static String[] getLoadedClasses(final ClassLoader loader) throws IllegalArgumentException, IllegalAccessException {
        final Vector<String> libraries = (Vector<String>) LIBRARIES.get(loader);
        return libraries.toArray(new String[]{});
    }
}
